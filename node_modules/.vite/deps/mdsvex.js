import {
  require_prism
} from "./chunk-WTZ4ED4Y.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-YBOLLQGG.js";

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components.json
var require_components = __commonJS({
  "node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components.json"(exports, module) {
    module.exports = {
      core: {
        meta: {
          path: "components/prism-core.js",
          option: "mandatory"
        },
        core: "Core"
      },
      themes: {
        meta: {
          path: "themes/{id}.css",
          link: "index.html?theme={id}",
          exclusive: true
        },
        prism: {
          title: "Default",
          option: "default"
        },
        "prism-dark": "Dark",
        "prism-funky": "Funky",
        "prism-okaidia": {
          title: "Okaidia",
          owner: "ocodia"
        },
        "prism-twilight": {
          title: "Twilight",
          owner: "remybach"
        },
        "prism-coy": {
          title: "Coy",
          owner: "tshedor"
        },
        "prism-solarizedlight": {
          title: "Solarized Light",
          owner: "hectormatos2011 "
        },
        "prism-tomorrow": {
          title: "Tomorrow Night",
          owner: "Rosey"
        }
      },
      languages: {
        meta: {
          path: "components/prism-{id}",
          noCSS: true,
          examplesPath: "examples/prism-{id}",
          addCheckAll: true
        },
        markup: {
          title: "Markup",
          alias: ["html", "xml", "svg", "mathml", "ssml", "atom", "rss"],
          aliasTitles: {
            html: "HTML",
            xml: "XML",
            svg: "SVG",
            mathml: "MathML",
            ssml: "SSML",
            atom: "Atom",
            rss: "RSS"
          },
          option: "default"
        },
        css: {
          title: "CSS",
          option: "default",
          modify: "markup"
        },
        clike: {
          title: "C-like",
          option: "default"
        },
        javascript: {
          title: "JavaScript",
          require: "clike",
          modify: "markup",
          optional: "regex",
          alias: "js",
          option: "default"
        },
        abap: {
          title: "ABAP",
          owner: "dellagustin"
        },
        abnf: {
          title: "ABNF",
          owner: "RunDevelopment"
        },
        actionscript: {
          title: "ActionScript",
          require: "javascript",
          modify: "markup",
          owner: "Golmote"
        },
        ada: {
          title: "Ada",
          owner: "Lucretia"
        },
        agda: {
          title: "Agda",
          owner: "xy-ren"
        },
        al: {
          title: "AL",
          owner: "RunDevelopment"
        },
        antlr4: {
          title: "ANTLR4",
          alias: "g4",
          owner: "RunDevelopment"
        },
        apacheconf: {
          title: "Apache Configuration",
          owner: "GuiTeK"
        },
        apex: {
          title: "Apex",
          require: ["clike", "sql"],
          owner: "RunDevelopment"
        },
        apl: {
          title: "APL",
          owner: "ngn"
        },
        applescript: {
          title: "AppleScript",
          owner: "Golmote"
        },
        aql: {
          title: "AQL",
          owner: "RunDevelopment"
        },
        arduino: {
          title: "Arduino",
          require: "cpp",
          alias: "ino",
          owner: "dkern"
        },
        arff: {
          title: "ARFF",
          owner: "Golmote"
        },
        armasm: {
          title: "ARM Assembly",
          alias: "arm-asm",
          owner: "RunDevelopment"
        },
        arturo: {
          title: "Arturo",
          alias: "art",
          optional: [
            "bash",
            "css",
            "javascript",
            "markup",
            "markdown",
            "sql"
          ],
          owner: "drkameleon"
        },
        asciidoc: {
          alias: "adoc",
          title: "AsciiDoc",
          owner: "Golmote"
        },
        aspnet: {
          title: "ASP.NET (C#)",
          require: ["markup", "csharp"],
          owner: "nauzilus"
        },
        asm6502: {
          title: "6502 Assembly",
          owner: "kzurawel"
        },
        asmatmel: {
          title: "Atmel AVR Assembly",
          owner: "cerkit"
        },
        autohotkey: {
          title: "AutoHotkey",
          owner: "aviaryan"
        },
        autoit: {
          title: "AutoIt",
          owner: "Golmote"
        },
        avisynth: {
          title: "AviSynth",
          alias: "avs",
          owner: "Zinfidel"
        },
        "avro-idl": {
          title: "Avro IDL",
          alias: "avdl",
          owner: "RunDevelopment"
        },
        awk: {
          title: "AWK",
          alias: "gawk",
          aliasTitles: {
            gawk: "GAWK"
          },
          owner: "RunDevelopment"
        },
        bash: {
          title: "Bash",
          alias: ["sh", "shell"],
          aliasTitles: {
            sh: "Shell",
            shell: "Shell"
          },
          owner: "zeitgeist87"
        },
        basic: {
          title: "BASIC",
          owner: "Golmote"
        },
        batch: {
          title: "Batch",
          owner: "Golmote"
        },
        bbcode: {
          title: "BBcode",
          alias: "shortcode",
          aliasTitles: {
            shortcode: "Shortcode"
          },
          owner: "RunDevelopment"
        },
        bbj: {
          title: "BBj",
          owner: "hyyan"
        },
        bicep: {
          title: "Bicep",
          owner: "johnnyreilly"
        },
        birb: {
          title: "Birb",
          require: "clike",
          owner: "Calamity210"
        },
        bison: {
          title: "Bison",
          require: "c",
          owner: "Golmote"
        },
        bnf: {
          title: "BNF",
          alias: "rbnf",
          aliasTitles: {
            rbnf: "RBNF"
          },
          owner: "RunDevelopment"
        },
        bqn: {
          title: "BQN",
          owner: "yewscion"
        },
        brainfuck: {
          title: "Brainfuck",
          owner: "Golmote"
        },
        brightscript: {
          title: "BrightScript",
          owner: "RunDevelopment"
        },
        bro: {
          title: "Bro",
          owner: "wayward710"
        },
        bsl: {
          title: "BSL (1C:Enterprise)",
          alias: "oscript",
          aliasTitles: {
            oscript: "OneScript"
          },
          owner: "Diversus23"
        },
        c: {
          title: "C",
          require: "clike",
          owner: "zeitgeist87"
        },
        csharp: {
          title: "C#",
          require: "clike",
          alias: ["cs", "dotnet"],
          owner: "mvalipour"
        },
        cpp: {
          title: "C++",
          require: "c",
          owner: "zeitgeist87"
        },
        cfscript: {
          title: "CFScript",
          require: "clike",
          alias: "cfc",
          owner: "mjclemente"
        },
        chaiscript: {
          title: "ChaiScript",
          require: ["clike", "cpp"],
          owner: "RunDevelopment"
        },
        cil: {
          title: "CIL",
          owner: "sbrl"
        },
        cilkc: {
          title: "Cilk/C",
          require: "c",
          alias: "cilk-c",
          owner: "OpenCilk"
        },
        cilkcpp: {
          title: "Cilk/C++",
          require: "cpp",
          alias: ["cilk-cpp", "cilk"],
          owner: "OpenCilk"
        },
        clojure: {
          title: "Clojure",
          owner: "troglotit"
        },
        cmake: {
          title: "CMake",
          owner: "mjrogozinski"
        },
        cobol: {
          title: "COBOL",
          owner: "RunDevelopment"
        },
        coffeescript: {
          title: "CoffeeScript",
          require: "javascript",
          alias: "coffee",
          owner: "R-osey"
        },
        concurnas: {
          title: "Concurnas",
          alias: "conc",
          owner: "jasontatton"
        },
        csp: {
          title: "Content-Security-Policy",
          owner: "ScottHelme"
        },
        cooklang: {
          title: "Cooklang",
          owner: "ahue"
        },
        coq: {
          title: "Coq",
          owner: "RunDevelopment"
        },
        crystal: {
          title: "Crystal",
          require: "ruby",
          owner: "MakeNowJust"
        },
        "css-extras": {
          title: "CSS Extras",
          require: "css",
          modify: "css",
          owner: "milesj"
        },
        csv: {
          title: "CSV",
          owner: "RunDevelopment"
        },
        cue: {
          title: "CUE",
          owner: "RunDevelopment"
        },
        cypher: {
          title: "Cypher",
          owner: "RunDevelopment"
        },
        d: {
          title: "D",
          require: "clike",
          owner: "Golmote"
        },
        dart: {
          title: "Dart",
          require: "clike",
          owner: "Golmote"
        },
        dataweave: {
          title: "DataWeave",
          owner: "machaval"
        },
        dax: {
          title: "DAX",
          owner: "peterbud"
        },
        dhall: {
          title: "Dhall",
          owner: "RunDevelopment"
        },
        diff: {
          title: "Diff",
          owner: "uranusjr"
        },
        django: {
          title: "Django/Jinja2",
          require: "markup-templating",
          alias: "jinja2",
          owner: "romanvm"
        },
        "dns-zone-file": {
          title: "DNS zone file",
          owner: "RunDevelopment",
          alias: "dns-zone"
        },
        docker: {
          title: "Docker",
          alias: "dockerfile",
          owner: "JustinBeckwith"
        },
        dot: {
          title: "DOT (Graphviz)",
          alias: "gv",
          optional: "markup",
          owner: "RunDevelopment"
        },
        ebnf: {
          title: "EBNF",
          owner: "RunDevelopment"
        },
        editorconfig: {
          title: "EditorConfig",
          owner: "osipxd"
        },
        eiffel: {
          title: "Eiffel",
          owner: "Conaclos"
        },
        ejs: {
          title: "EJS",
          require: ["javascript", "markup-templating"],
          owner: "RunDevelopment",
          alias: "eta",
          aliasTitles: {
            eta: "Eta"
          }
        },
        elixir: {
          title: "Elixir",
          owner: "Golmote"
        },
        elm: {
          title: "Elm",
          owner: "zwilias"
        },
        etlua: {
          title: "Embedded Lua templating",
          require: ["lua", "markup-templating"],
          owner: "RunDevelopment"
        },
        erb: {
          title: "ERB",
          require: ["ruby", "markup-templating"],
          owner: "Golmote"
        },
        erlang: {
          title: "Erlang",
          owner: "Golmote"
        },
        "excel-formula": {
          title: "Excel Formula",
          alias: ["xlsx", "xls"],
          owner: "RunDevelopment"
        },
        fsharp: {
          title: "F#",
          require: "clike",
          owner: "simonreynolds7"
        },
        factor: {
          title: "Factor",
          owner: "catb0t"
        },
        false: {
          title: "False",
          owner: "edukisto"
        },
        "firestore-security-rules": {
          title: "Firestore security rules",
          require: "clike",
          owner: "RunDevelopment"
        },
        flow: {
          title: "Flow",
          require: "javascript",
          owner: "Golmote"
        },
        fortran: {
          title: "Fortran",
          owner: "Golmote"
        },
        ftl: {
          title: "FreeMarker Template Language",
          require: "markup-templating",
          owner: "RunDevelopment"
        },
        gml: {
          title: "GameMaker Language",
          alias: "gamemakerlanguage",
          require: "clike",
          owner: "LiarOnce"
        },
        gap: {
          title: "GAP (CAS)",
          owner: "RunDevelopment"
        },
        gcode: {
          title: "G-code",
          owner: "RunDevelopment"
        },
        gdscript: {
          title: "GDScript",
          owner: "RunDevelopment"
        },
        gedcom: {
          title: "GEDCOM",
          owner: "Golmote"
        },
        gettext: {
          title: "gettext",
          alias: "po",
          owner: "RunDevelopment"
        },
        gherkin: {
          title: "Gherkin",
          owner: "hason"
        },
        git: {
          title: "Git",
          owner: "lgiraudel"
        },
        glsl: {
          title: "GLSL",
          require: "c",
          owner: "Golmote"
        },
        gn: {
          title: "GN",
          alias: "gni",
          owner: "RunDevelopment"
        },
        "linker-script": {
          title: "GNU Linker Script",
          alias: "ld",
          owner: "RunDevelopment"
        },
        go: {
          title: "Go",
          require: "clike",
          owner: "arnehormann"
        },
        "go-module": {
          title: "Go module",
          alias: "go-mod",
          owner: "RunDevelopment"
        },
        gradle: {
          title: "Gradle",
          require: "clike",
          owner: "zeabdelkhalek-badido18"
        },
        graphql: {
          title: "GraphQL",
          optional: "markdown",
          owner: "Golmote"
        },
        groovy: {
          title: "Groovy",
          require: "clike",
          owner: "robfletcher"
        },
        haml: {
          title: "Haml",
          require: "ruby",
          optional: [
            "css",
            "css-extras",
            "coffeescript",
            "erb",
            "javascript",
            "less",
            "markdown",
            "scss",
            "textile"
          ],
          owner: "Golmote"
        },
        handlebars: {
          title: "Handlebars",
          require: "markup-templating",
          alias: ["hbs", "mustache"],
          aliasTitles: {
            mustache: "Mustache"
          },
          owner: "Golmote"
        },
        haskell: {
          title: "Haskell",
          alias: "hs",
          owner: "bholst"
        },
        haxe: {
          title: "Haxe",
          require: "clike",
          optional: "regex",
          owner: "Golmote"
        },
        hcl: {
          title: "HCL",
          owner: "outsideris"
        },
        hlsl: {
          title: "HLSL",
          require: "c",
          owner: "RunDevelopment"
        },
        hoon: {
          title: "Hoon",
          owner: "matildepark"
        },
        http: {
          title: "HTTP",
          optional: [
            "csp",
            "css",
            "hpkp",
            "hsts",
            "javascript",
            "json",
            "markup",
            "uri"
          ],
          owner: "danielgtaylor"
        },
        hpkp: {
          title: "HTTP Public-Key-Pins",
          owner: "ScottHelme"
        },
        hsts: {
          title: "HTTP Strict-Transport-Security",
          owner: "ScottHelme"
        },
        ichigojam: {
          title: "IchigoJam",
          owner: "BlueCocoa"
        },
        icon: {
          title: "Icon",
          owner: "Golmote"
        },
        "icu-message-format": {
          title: "ICU Message Format",
          owner: "RunDevelopment"
        },
        idris: {
          title: "Idris",
          alias: "idr",
          owner: "KeenS",
          require: "haskell"
        },
        ignore: {
          title: ".ignore",
          owner: "osipxd",
          alias: [
            "gitignore",
            "hgignore",
            "npmignore"
          ],
          aliasTitles: {
            gitignore: ".gitignore",
            hgignore: ".hgignore",
            npmignore: ".npmignore"
          }
        },
        inform7: {
          title: "Inform 7",
          owner: "Golmote"
        },
        ini: {
          title: "Ini",
          owner: "aviaryan"
        },
        io: {
          title: "Io",
          owner: "AlesTsurko"
        },
        j: {
          title: "J",
          owner: "Golmote"
        },
        java: {
          title: "Java",
          require: "clike",
          owner: "sherblot"
        },
        javadoc: {
          title: "JavaDoc",
          require: ["markup", "java", "javadoclike"],
          modify: "java",
          optional: "scala",
          owner: "RunDevelopment"
        },
        javadoclike: {
          title: "JavaDoc-like",
          modify: [
            "java",
            "javascript",
            "php"
          ],
          owner: "RunDevelopment"
        },
        javastacktrace: {
          title: "Java stack trace",
          owner: "RunDevelopment"
        },
        jexl: {
          title: "Jexl",
          owner: "czosel"
        },
        jolie: {
          title: "Jolie",
          require: "clike",
          owner: "thesave"
        },
        jq: {
          title: "JQ",
          owner: "RunDevelopment"
        },
        jsdoc: {
          title: "JSDoc",
          require: ["javascript", "javadoclike", "typescript"],
          modify: "javascript",
          optional: [
            "actionscript",
            "coffeescript"
          ],
          owner: "RunDevelopment"
        },
        "js-extras": {
          title: "JS Extras",
          require: "javascript",
          modify: "javascript",
          optional: [
            "actionscript",
            "coffeescript",
            "flow",
            "n4js",
            "typescript"
          ],
          owner: "RunDevelopment"
        },
        json: {
          title: "JSON",
          alias: "webmanifest",
          aliasTitles: {
            webmanifest: "Web App Manifest"
          },
          owner: "CupOfTea696"
        },
        json5: {
          title: "JSON5",
          require: "json",
          owner: "RunDevelopment"
        },
        jsonp: {
          title: "JSONP",
          require: "json",
          owner: "RunDevelopment"
        },
        jsstacktrace: {
          title: "JS stack trace",
          owner: "sbrl"
        },
        "js-templates": {
          title: "JS Templates",
          require: "javascript",
          modify: "javascript",
          optional: [
            "css",
            "css-extras",
            "graphql",
            "markdown",
            "markup",
            "sql"
          ],
          owner: "RunDevelopment"
        },
        julia: {
          title: "Julia",
          owner: "cdagnino"
        },
        keepalived: {
          title: "Keepalived Configure",
          owner: "dev-itsheng"
        },
        keyman: {
          title: "Keyman",
          owner: "mcdurdin"
        },
        kotlin: {
          title: "Kotlin",
          alias: ["kt", "kts"],
          aliasTitles: {
            kts: "Kotlin Script"
          },
          require: "clike",
          owner: "Golmote"
        },
        kumir: {
          title: "KuMir (КуМир)",
          alias: "kum",
          owner: "edukisto"
        },
        kusto: {
          title: "Kusto",
          owner: "RunDevelopment"
        },
        latex: {
          title: "LaTeX",
          alias: ["tex", "context"],
          aliasTitles: {
            tex: "TeX",
            context: "ConTeXt"
          },
          owner: "japborst"
        },
        latte: {
          title: "Latte",
          require: ["clike", "markup-templating", "php"],
          owner: "nette"
        },
        less: {
          title: "Less",
          require: "css",
          optional: "css-extras",
          owner: "Golmote"
        },
        lilypond: {
          title: "LilyPond",
          require: "scheme",
          alias: "ly",
          owner: "RunDevelopment"
        },
        liquid: {
          title: "Liquid",
          require: "markup-templating",
          owner: "cinhtau"
        },
        lisp: {
          title: "Lisp",
          alias: ["emacs", "elisp", "emacs-lisp"],
          owner: "JuanCaicedo"
        },
        livescript: {
          title: "LiveScript",
          owner: "Golmote"
        },
        llvm: {
          title: "LLVM IR",
          owner: "porglezomp"
        },
        log: {
          title: "Log file",
          optional: "javastacktrace",
          owner: "RunDevelopment"
        },
        lolcode: {
          title: "LOLCODE",
          owner: "Golmote"
        },
        lua: {
          title: "Lua",
          owner: "Golmote"
        },
        magma: {
          title: "Magma (CAS)",
          owner: "RunDevelopment"
        },
        makefile: {
          title: "Makefile",
          owner: "Golmote"
        },
        markdown: {
          title: "Markdown",
          require: "markup",
          optional: "yaml",
          alias: "md",
          owner: "Golmote"
        },
        "markup-templating": {
          title: "Markup templating",
          require: "markup",
          owner: "Golmote"
        },
        mata: {
          title: "Mata",
          owner: "RunDevelopment"
        },
        matlab: {
          title: "MATLAB",
          owner: "Golmote"
        },
        maxscript: {
          title: "MAXScript",
          owner: "RunDevelopment"
        },
        mel: {
          title: "MEL",
          owner: "Golmote"
        },
        mermaid: {
          title: "Mermaid",
          owner: "RunDevelopment"
        },
        metafont: {
          title: "METAFONT",
          owner: "LaeriExNihilo"
        },
        mizar: {
          title: "Mizar",
          owner: "Golmote"
        },
        mongodb: {
          title: "MongoDB",
          owner: "airs0urce",
          require: "javascript"
        },
        monkey: {
          title: "Monkey",
          owner: "Golmote"
        },
        moonscript: {
          title: "MoonScript",
          alias: "moon",
          owner: "RunDevelopment"
        },
        n1ql: {
          title: "N1QL",
          owner: "TMWilds"
        },
        n4js: {
          title: "N4JS",
          require: "javascript",
          optional: "jsdoc",
          alias: "n4jsd",
          owner: "bsmith-n4"
        },
        "nand2tetris-hdl": {
          title: "Nand To Tetris HDL",
          owner: "stephanmax"
        },
        naniscript: {
          title: "Naninovel Script",
          owner: "Elringus",
          alias: "nani"
        },
        nasm: {
          title: "NASM",
          owner: "rbmj"
        },
        neon: {
          title: "NEON",
          owner: "nette"
        },
        nevod: {
          title: "Nevod",
          owner: "nezaboodka"
        },
        nginx: {
          title: "nginx",
          owner: "volado"
        },
        nim: {
          title: "Nim",
          owner: "Golmote"
        },
        nix: {
          title: "Nix",
          owner: "Golmote"
        },
        nsis: {
          title: "NSIS",
          owner: "idleberg"
        },
        objectivec: {
          title: "Objective-C",
          require: "c",
          alias: "objc",
          owner: "uranusjr"
        },
        ocaml: {
          title: "OCaml",
          owner: "Golmote"
        },
        odin: {
          title: "Odin",
          owner: "edukisto"
        },
        opencl: {
          title: "OpenCL",
          require: "c",
          modify: [
            "c",
            "cpp"
          ],
          owner: "Milania1"
        },
        openqasm: {
          title: "OpenQasm",
          alias: "qasm",
          owner: "RunDevelopment"
        },
        oz: {
          title: "Oz",
          owner: "Golmote"
        },
        parigp: {
          title: "PARI/GP",
          owner: "Golmote"
        },
        parser: {
          title: "Parser",
          require: "markup",
          owner: "Golmote"
        },
        pascal: {
          title: "Pascal",
          alias: "objectpascal",
          aliasTitles: {
            objectpascal: "Object Pascal"
          },
          owner: "Golmote"
        },
        pascaligo: {
          title: "Pascaligo",
          owner: "DefinitelyNotAGoat"
        },
        psl: {
          title: "PATROL Scripting Language",
          owner: "bertysentry"
        },
        pcaxis: {
          title: "PC-Axis",
          alias: "px",
          owner: "RunDevelopment"
        },
        peoplecode: {
          title: "PeopleCode",
          alias: "pcode",
          owner: "RunDevelopment"
        },
        perl: {
          title: "Perl",
          owner: "Golmote"
        },
        php: {
          title: "PHP",
          require: "markup-templating",
          owner: "milesj"
        },
        phpdoc: {
          title: "PHPDoc",
          require: ["php", "javadoclike"],
          modify: "php",
          owner: "RunDevelopment"
        },
        "php-extras": {
          title: "PHP Extras",
          require: "php",
          modify: "php",
          owner: "milesj"
        },
        "plant-uml": {
          title: "PlantUML",
          alias: "plantuml",
          owner: "RunDevelopment"
        },
        plsql: {
          title: "PL/SQL",
          require: "sql",
          owner: "Golmote"
        },
        powerquery: {
          title: "PowerQuery",
          alias: ["pq", "mscript"],
          owner: "peterbud"
        },
        powershell: {
          title: "PowerShell",
          owner: "nauzilus"
        },
        processing: {
          title: "Processing",
          require: "clike",
          owner: "Golmote"
        },
        prolog: {
          title: "Prolog",
          owner: "Golmote"
        },
        promql: {
          title: "PromQL",
          owner: "arendjr"
        },
        properties: {
          title: ".properties",
          owner: "Golmote"
        },
        protobuf: {
          title: "Protocol Buffers",
          require: "clike",
          owner: "just-boris"
        },
        pug: {
          title: "Pug",
          require: ["markup", "javascript"],
          optional: [
            "coffeescript",
            "ejs",
            "handlebars",
            "less",
            "livescript",
            "markdown",
            "scss",
            "stylus",
            "twig"
          ],
          owner: "Golmote"
        },
        puppet: {
          title: "Puppet",
          owner: "Golmote"
        },
        pure: {
          title: "Pure",
          optional: [
            "c",
            "cpp",
            "fortran"
          ],
          owner: "Golmote"
        },
        purebasic: {
          title: "PureBasic",
          require: "clike",
          alias: "pbfasm",
          owner: "HeX0R101"
        },
        purescript: {
          title: "PureScript",
          require: "haskell",
          alias: "purs",
          owner: "sriharshachilakapati"
        },
        python: {
          title: "Python",
          alias: "py",
          owner: "multipetros"
        },
        qsharp: {
          title: "Q#",
          require: "clike",
          alias: "qs",
          owner: "fedonman"
        },
        q: {
          title: "Q (kdb+ database)",
          owner: "Golmote"
        },
        qml: {
          title: "QML",
          require: "javascript",
          owner: "RunDevelopment"
        },
        qore: {
          title: "Qore",
          require: "clike",
          owner: "temnroegg"
        },
        r: {
          title: "R",
          owner: "Golmote"
        },
        racket: {
          title: "Racket",
          require: "scheme",
          alias: "rkt",
          owner: "RunDevelopment"
        },
        cshtml: {
          title: "Razor C#",
          alias: "razor",
          require: ["markup", "csharp"],
          optional: [
            "css",
            "css-extras",
            "javascript",
            "js-extras"
          ],
          owner: "RunDevelopment"
        },
        jsx: {
          title: "React JSX",
          require: ["markup", "javascript"],
          optional: [
            "jsdoc",
            "js-extras",
            "js-templates"
          ],
          owner: "vkbansal"
        },
        tsx: {
          title: "React TSX",
          require: ["jsx", "typescript"]
        },
        reason: {
          title: "Reason",
          require: "clike",
          owner: "Golmote"
        },
        regex: {
          title: "Regex",
          owner: "RunDevelopment"
        },
        rego: {
          title: "Rego",
          owner: "JordanSh"
        },
        renpy: {
          title: "Ren'py",
          alias: "rpy",
          owner: "HyuchiaDiego"
        },
        rescript: {
          title: "ReScript",
          alias: "res",
          owner: "vmarcosp"
        },
        rest: {
          title: "reST (reStructuredText)",
          owner: "Golmote"
        },
        rip: {
          title: "Rip",
          owner: "ravinggenius"
        },
        roboconf: {
          title: "Roboconf",
          owner: "Golmote"
        },
        robotframework: {
          title: "Robot Framework",
          alias: "robot",
          owner: "RunDevelopment"
        },
        ruby: {
          title: "Ruby",
          require: "clike",
          alias: "rb",
          owner: "samflores"
        },
        rust: {
          title: "Rust",
          owner: "Golmote"
        },
        sas: {
          title: "SAS",
          optional: ["groovy", "lua", "sql"],
          owner: "Golmote"
        },
        sass: {
          title: "Sass (Sass)",
          require: "css",
          optional: "css-extras",
          owner: "Golmote"
        },
        scss: {
          title: "Sass (SCSS)",
          require: "css",
          optional: "css-extras",
          owner: "MoOx"
        },
        scala: {
          title: "Scala",
          require: "java",
          owner: "jozic"
        },
        scheme: {
          title: "Scheme",
          owner: "bacchus123"
        },
        "shell-session": {
          title: "Shell session",
          require: "bash",
          alias: ["sh-session", "shellsession"],
          owner: "RunDevelopment"
        },
        smali: {
          title: "Smali",
          owner: "RunDevelopment"
        },
        smalltalk: {
          title: "Smalltalk",
          owner: "Golmote"
        },
        smarty: {
          title: "Smarty",
          require: "markup-templating",
          optional: "php",
          owner: "Golmote"
        },
        sml: {
          title: "SML",
          alias: "smlnj",
          aliasTitles: {
            smlnj: "SML/NJ"
          },
          owner: "RunDevelopment"
        },
        solidity: {
          title: "Solidity (Ethereum)",
          alias: "sol",
          require: "clike",
          owner: "glachaud"
        },
        "solution-file": {
          title: "Solution file",
          alias: "sln",
          owner: "RunDevelopment"
        },
        soy: {
          title: "Soy (Closure Template)",
          require: "markup-templating",
          owner: "Golmote"
        },
        sparql: {
          title: "SPARQL",
          require: "turtle",
          owner: "Triply-Dev",
          alias: "rq"
        },
        "splunk-spl": {
          title: "Splunk SPL",
          owner: "RunDevelopment"
        },
        sqf: {
          title: "SQF: Status Quo Function (Arma 3)",
          require: "clike",
          owner: "RunDevelopment"
        },
        sql: {
          title: "SQL",
          owner: "multipetros"
        },
        squirrel: {
          title: "Squirrel",
          require: "clike",
          owner: "RunDevelopment"
        },
        stan: {
          title: "Stan",
          owner: "RunDevelopment"
        },
        stata: {
          title: "Stata Ado",
          require: ["mata", "java", "python"],
          owner: "RunDevelopment"
        },
        iecst: {
          title: "Structured Text (IEC 61131-3)",
          owner: "serhioromano"
        },
        stylus: {
          title: "Stylus",
          owner: "vkbansal"
        },
        supercollider: {
          title: "SuperCollider",
          alias: "sclang",
          owner: "RunDevelopment"
        },
        swift: {
          title: "Swift",
          owner: "chrischares"
        },
        systemd: {
          title: "Systemd configuration file",
          owner: "RunDevelopment"
        },
        "t4-templating": {
          title: "T4 templating",
          owner: "RunDevelopment"
        },
        "t4-cs": {
          title: "T4 Text Templates (C#)",
          require: ["t4-templating", "csharp"],
          alias: "t4",
          owner: "RunDevelopment"
        },
        "t4-vb": {
          title: "T4 Text Templates (VB)",
          require: ["t4-templating", "vbnet"],
          owner: "RunDevelopment"
        },
        tap: {
          title: "TAP",
          owner: "isaacs",
          require: "yaml"
        },
        tcl: {
          title: "Tcl",
          owner: "PeterChaplin"
        },
        tt2: {
          title: "Template Toolkit 2",
          require: ["clike", "markup-templating"],
          owner: "gflohr"
        },
        textile: {
          title: "Textile",
          require: "markup",
          optional: "css",
          owner: "Golmote"
        },
        toml: {
          title: "TOML",
          owner: "RunDevelopment"
        },
        tremor: {
          title: "Tremor",
          alias: [
            "trickle",
            "troy"
          ],
          owner: "darach",
          aliasTitles: {
            trickle: "trickle",
            troy: "troy"
          }
        },
        turtle: {
          title: "Turtle",
          alias: "trig",
          aliasTitles: {
            trig: "TriG"
          },
          owner: "jakubklimek"
        },
        twig: {
          title: "Twig",
          require: "markup-templating",
          owner: "brandonkelly"
        },
        typescript: {
          title: "TypeScript",
          require: "javascript",
          optional: "js-templates",
          alias: "ts",
          owner: "vkbansal"
        },
        typoscript: {
          title: "TypoScript",
          alias: "tsconfig",
          aliasTitles: {
            tsconfig: "TSConfig"
          },
          owner: "dkern"
        },
        unrealscript: {
          title: "UnrealScript",
          alias: ["uscript", "uc"],
          owner: "RunDevelopment"
        },
        uorazor: {
          title: "UO Razor Script",
          owner: "jaseowns"
        },
        uri: {
          title: "URI",
          alias: "url",
          aliasTitles: {
            url: "URL"
          },
          owner: "RunDevelopment"
        },
        v: {
          title: "V",
          require: "clike",
          owner: "taggon"
        },
        vala: {
          title: "Vala",
          require: "clike",
          optional: "regex",
          owner: "TemplarVolk"
        },
        vbnet: {
          title: "VB.Net",
          require: "basic",
          owner: "Bigsby"
        },
        velocity: {
          title: "Velocity",
          require: "markup",
          owner: "Golmote"
        },
        verilog: {
          title: "Verilog",
          owner: "a-rey"
        },
        vhdl: {
          title: "VHDL",
          owner: "a-rey"
        },
        vim: {
          title: "vim",
          owner: "westonganger"
        },
        "visual-basic": {
          title: "Visual Basic",
          alias: ["vb", "vba"],
          aliasTitles: {
            vba: "VBA"
          },
          owner: "Golmote"
        },
        warpscript: {
          title: "WarpScript",
          owner: "RunDevelopment"
        },
        wasm: {
          title: "WebAssembly",
          owner: "Golmote"
        },
        "web-idl": {
          title: "Web IDL",
          alias: "webidl",
          owner: "RunDevelopment"
        },
        wgsl: {
          title: "WGSL",
          owner: "Dr4gonthree"
        },
        wiki: {
          title: "Wiki markup",
          require: "markup",
          owner: "Golmote"
        },
        wolfram: {
          title: "Wolfram language",
          alias: ["mathematica", "nb", "wl"],
          aliasTitles: {
            mathematica: "Mathematica",
            nb: "Mathematica Notebook"
          },
          owner: "msollami"
        },
        wren: {
          title: "Wren",
          owner: "clsource"
        },
        xeora: {
          title: "Xeora",
          require: "markup",
          alias: "xeoracube",
          aliasTitles: {
            xeoracube: "XeoraCube"
          },
          owner: "freakmaxi"
        },
        "xml-doc": {
          title: "XML doc (.net)",
          require: "markup",
          modify: ["csharp", "fsharp", "vbnet"],
          owner: "RunDevelopment"
        },
        xojo: {
          title: "Xojo (REALbasic)",
          owner: "Golmote"
        },
        xquery: {
          title: "XQuery",
          require: "markup",
          owner: "Golmote"
        },
        yaml: {
          title: "YAML",
          alias: "yml",
          owner: "hason"
        },
        yang: {
          title: "YANG",
          owner: "RunDevelopment"
        },
        zig: {
          title: "Zig",
          owner: "RunDevelopment"
        }
      },
      plugins: {
        meta: {
          path: "plugins/{id}/prism-{id}",
          link: "plugins/{id}/"
        },
        "line-highlight": {
          title: "Line Highlight",
          description: "Highlights specific lines and/or line ranges."
        },
        "line-numbers": {
          title: "Line Numbers",
          description: "Line number at the beginning of code lines.",
          owner: "kuba-kubula"
        },
        "show-invisibles": {
          title: "Show Invisibles",
          description: "Show hidden characters such as tabs and line breaks.",
          optional: [
            "autolinker",
            "data-uri-highlight"
          ]
        },
        autolinker: {
          title: "Autolinker",
          description: "Converts URLs and emails in code to clickable links. Parses Markdown links in comments."
        },
        wpd: {
          title: "WebPlatform Docs",
          description: 'Makes tokens link to <a href="https://webplatform.github.io/docs/">WebPlatform.org documentation</a>. The links open in a new tab.'
        },
        "custom-class": {
          title: "Custom Class",
          description: "This plugin allows you to prefix Prism's default classes (<code>.comment</code> can become <code>.namespace--comment</code>) or replace them with your defined ones (like <code>.editor__comment</code>). You can even add new classes.",
          owner: "dvkndn",
          noCSS: true
        },
        "file-highlight": {
          title: "File Highlight",
          description: "Fetch external files and highlight them with Prism. Used on the Prism website itself.",
          noCSS: true
        },
        "show-language": {
          title: "Show Language",
          description: "Display the highlighted language in code blocks (inline code does not show the label).",
          owner: "nauzilus",
          noCSS: true,
          require: "toolbar"
        },
        "jsonp-highlight": {
          title: "JSONP Highlight",
          description: "Fetch content with JSONP and highlight some interesting content (e.g. GitHub/Gists or Bitbucket API).",
          noCSS: true,
          owner: "nauzilus"
        },
        "highlight-keywords": {
          title: "Highlight Keywords",
          description: "Adds special CSS classes for each keyword for fine-grained highlighting.",
          owner: "vkbansal",
          noCSS: true
        },
        "remove-initial-line-feed": {
          title: "Remove initial line feed",
          description: "Removes the initial line feed in code blocks.",
          owner: "Golmote",
          noCSS: true
        },
        "inline-color": {
          title: "Inline color",
          description: "Adds a small inline preview for colors in style sheets.",
          require: "css-extras",
          owner: "RunDevelopment"
        },
        previewers: {
          title: "Previewers",
          description: "Previewers for angles, colors, gradients, easing and time.",
          require: "css-extras",
          owner: "Golmote"
        },
        autoloader: {
          title: "Autoloader",
          description: "Automatically loads the needed languages to highlight the code blocks.",
          owner: "Golmote",
          noCSS: true
        },
        "keep-markup": {
          title: "Keep Markup",
          description: "Prevents custom markup from being dropped out during highlighting.",
          owner: "Golmote",
          optional: "normalize-whitespace",
          noCSS: true
        },
        "command-line": {
          title: "Command Line",
          description: "Display a command line with a prompt and, optionally, the output/response from the commands.",
          owner: "chriswells0"
        },
        "unescaped-markup": {
          title: "Unescaped Markup",
          description: "Write markup without having to escape anything."
        },
        "normalize-whitespace": {
          title: "Normalize Whitespace",
          description: "Supports multiple operations to normalize whitespace in code blocks.",
          owner: "zeitgeist87",
          optional: "unescaped-markup",
          noCSS: true
        },
        "data-uri-highlight": {
          title: "Data-URI Highlight",
          description: "Highlights data-URI contents.",
          owner: "Golmote",
          noCSS: true
        },
        toolbar: {
          title: "Toolbar",
          description: "Attach a toolbar for plugins to easily register buttons on the top of a code block.",
          owner: "mAAdhaTTah"
        },
        "copy-to-clipboard": {
          title: "Copy to Clipboard Button",
          description: "Add a button that copies the code block to the clipboard when clicked.",
          owner: "mAAdhaTTah",
          require: "toolbar",
          noCSS: true
        },
        "download-button": {
          title: "Download Button",
          description: "A button in the toolbar of a code block adding a convenient way to download a code file.",
          owner: "Golmote",
          require: "toolbar",
          noCSS: true
        },
        "match-braces": {
          title: "Match braces",
          description: "Highlights matching braces.",
          owner: "RunDevelopment"
        },
        "diff-highlight": {
          title: "Diff Highlight",
          description: "Highlights the code inside diff blocks.",
          owner: "RunDevelopment",
          require: "diff"
        },
        "filter-highlight-all": {
          title: "Filter highlightAll",
          description: "Filters the elements the <code>highlightAll</code> and <code>highlightAllUnder</code> methods actually highlight.",
          owner: "RunDevelopment",
          noCSS: true
        },
        treeview: {
          title: "Treeview",
          description: "A language with special styles to highlight file system tree structures.",
          owner: "Golmote"
        }
      }
    };
  }
});

// node_modules/.pnpm/mdsvex@0.10.6_svelte@3.59.1/node_modules/mdsvex/dist/main.es.js
var path = __toESM(require_path());
var import_path = __toESM(require_path());
var import_fs = __toESM(require_fs());

// node_modules/.pnpm/svelte@3.59.1/node_modules/svelte/compiler.mjs
var now = typeof process !== "undefined" && process.hrtime ? () => {
  const t = process.hrtime();
  return t[0] * 1e3 + t[1] / 1e6;
} : () => self.performance.now();
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code2, set2) {
  var pos = 65536;
  for (var i = 0; i < set2.length; i += 2) {
    pos += set2[i];
    if (pos > code2) {
      return false;
    }
    pos += set2[i + 1];
    if (pos >= code2) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code2, astral) {
  if (code2 < 65) {
    return code2 === 36;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes);
}
function isIdentifierChar(code2, astral) {
  if (code2 < 48) {
    return code2 === 36;
  }
  if (code2 < 58) {
    return true;
  }
  if (code2 < 65) {
    return false;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name3, prec2) {
  return new TokenType(name3, { beforeExpr: true, binop: prec2 });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name3, options2) {
  if (options2 === void 0)
    options2 = {};
  options2.keyword = name3;
  return keywords[name3] = new TokenType(name3, options2);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code2) {
  return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
}
function nextLineBreak(code2, from, end2) {
  if (end2 === void 0)
    end2 = code2.length;
  for (var i = from; i < end2; i++) {
    var next = code2.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end2 - 1 && next === 13 && code2.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty$1 = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty$1.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code2) {
  if (code2 <= 65535) {
    return String.fromCharCode(code2);
  }
  code2 -= 65536;
  return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line2, col) {
  this.line = line2;
  this.column = col;
};
Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};
var SourceLocation = function SourceLocation2(p2, start2, end2) {
  this.start = start2;
  this.end = end2;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line2 = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line2, offset2 - cur);
    }
    ++line2;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options2 = {};
  for (var opt in defaultOptions) {
    options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options2.ecmaVersion === "latest") {
    options2.ecmaVersion = 1e8;
  } else if (options2.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options2.ecmaVersion = 11;
  } else if (options2.ecmaVersion >= 2015) {
    options2.ecmaVersion -= 2009;
  }
  if (options2.allowReserved == null) {
    options2.allowReserved = options2.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options2.allowHashBang = options2.ecmaVersion >= 14;
  }
  if (isArray(options2.onToken)) {
    var tokens = options2.onToken;
    options2.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options2.onComment)) {
    options2.onComment = pushComment(options2, options2.onComment);
  }
  return options2;
}
function pushComment(options2, array) {
  return function(block2, text3, start2, end2, startLoc, endLoc) {
    var comment2 = {
      type: block2 ? "Block" : "Line",
      value: text3,
      start: start2,
      end: end2
    };
    if (options2.locations) {
      comment2.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options2.ranges) {
      comment2.range = [start2, end2];
    }
    array.push(comment2);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options2, input, startPos) {
  this.options = options2 = getOptions(options2);
  this.sourceFile = options2.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
  var reserved2 = "";
  if (options2.allowReserved !== true) {
    reserved2 = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
    if (options2.sourceType === "module") {
      reserved2 += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved2);
  var reservedStrict = (reserved2 ? reserved2 + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options2.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node2 = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node2);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--)
    plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options2) {
  return new this(options2, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
  var parser2 = new this(options2, input, pos);
  parser2.nextToken();
  return parser2.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options2) {
  return new this(options2, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start2) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start2));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start2 + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end2 = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end2);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end2 + 1) === "=");
    }
    start2 += match[0].length;
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start2] === ";") {
      start2++;
    }
  }
};
pp$9.eat = function(type2) {
  if (this.type === type2) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name3) {
  return this.type === types$1.name && this.value === name3 && !this.containsEsc;
};
pp$9.eatContextual = function(name3) {
  if (!this.isContextual(name3)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name3) {
  if (!this.eatContextual(name3)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type2) {
  this.eat(type2) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node2) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node2.body) {
    node2.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node2.body.push(stmt);
  }
  if (this.inModule) {
    for (var i = 0, list2 = Object.keys(this.undefinedExports); i < list2.length; i += 1) {
      var name3 = list2[i];
      this.raiseRecoverable(this.undefinedExports[name3].start, "Export '" + name3 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node2.body);
  this.next();
  node2.sourceType = this.options.sourceType;
  return this.finishNode(node2, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context2) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context2) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after2;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after2 = this.input.charCodeAt(next + 8)) || after2 > 55295 && after2 < 56320));
};
pp$8.parseStatement = function(context2, topLevel, exports) {
  var starttype = this.type, node2 = this.startNode(), kind;
  if (this.isLet(context2)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node2, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node2);
    case types$1._do:
      return this.parseDoStatement(node2);
    case types$1._for:
      return this.parseForStatement(node2);
    case types$1._function:
      if (context2 && (this.strict || context2 !== "if" && context2 !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node2, false, !context2);
    case types$1._class:
      if (context2) {
        this.unexpected();
      }
      return this.parseClass(node2, true);
    case types$1._if:
      return this.parseIfStatement(node2);
    case types$1._return:
      return this.parseReturnStatement(node2);
    case types$1._switch:
      return this.parseSwitchStatement(node2);
    case types$1._throw:
      return this.parseThrowStatement(node2);
    case types$1._try:
      return this.parseTryStatement(node2);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context2 && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node2, kind);
    case types$1._while:
      return this.parseWhileStatement(node2);
    case types$1._with:
      return this.parseWithStatement(node2);
    case types$1.braceL:
      return this.parseBlock(true, node2);
    case types$1.semi:
      return this.parseEmptyStatement(node2);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node2, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context2) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node2, true, !context2);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node2, maybeName, expr, context2);
      } else {
        return this.parseExpressionStatement(node2, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node2, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node2.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node2.label == null || lab.name === node2.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node2.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node2.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node2) {
  this.next();
  this.semicolon();
  return this.finishNode(node2, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node2) {
  this.next();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node2.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node2, "DoWhileStatement");
};
pp$8.parseForStatement = function(node2) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node2.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node2, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node2.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node2, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node2, init);
};
pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  node2.consequent = this.parseStatement("if");
  node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node2, "IfStatement");
};
pp$8.parseReturnStatement = function(node2) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.argument = null;
  } else {
    node2.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node2, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node2) {
  this.next();
  node2.discriminant = this.parseParenExpression();
  node2.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node2.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node2, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node2) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node2.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node2, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseTryStatement = function(node2) {
  this.next();
  node2.block = this.parseBlock();
  node2.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node2.handler = this.finishNode(clause, "CatchClause");
  }
  node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node2.handler && !node2.finalizer) {
    this.raise(node2.start, "Missing catch or finally clause");
  }
  return this.finishNode(node2, "TryStatement");
};
pp$8.parseVarStatement = function(node2, kind) {
  this.next();
  this.parseVar(node2, false, kind);
  this.semicolon();
  return this.finishNode(node2, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node2, "WhileStatement");
};
pp$8.parseWithStatement = function(node2) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node2.object = this.parseParenExpression();
  node2.body = this.parseStatement("with");
  return this.finishNode(node2, "WithStatement");
};
pp$8.parseEmptyStatement = function(node2) {
  this.next();
  return this.finishNode(node2, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node2, maybeName, expr, context2) {
  for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
    var label = list2[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node2.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node2.body = this.parseStatement(context2 ? context2.indexOf("label") === -1 ? context2 + "label" : context2 : "label");
  this.labels.pop();
  node2.label = expr;
  return this.finishNode(node2, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node2, expr) {
  node2.expression = expr;
  this.semicolon();
  return this.finishNode(node2, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node2 === void 0)
    node2 = this.startNode();
  node2.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node2, "BlockStatement");
};
pp$8.parseFor = function(node2, init) {
  node2.init = init;
  this.expect(types$1.semi);
  node2.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node2.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, "ForStatement");
};
pp$8.parseForIn = function(node2, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node2.left = init;
  node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node2, isFor, kind) {
  node2.declarations = [];
  node2.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node2;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node2.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node2.async, node2.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node2.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node2);
  this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node2) {
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node2, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node2, isStatement);
  this.parseClassSuper(node2);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element2 = this.parseClassElement(node2.superClass !== null);
    if (element2) {
      classBody.body.push(element2);
      if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
        if (hadConstructor) {
          this.raise(element2.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
        this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node2.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node2 = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node2);
      return node2;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node2.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node2.computed = false;
    node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node2.key.name = keyName;
    this.finishNode(node2.key, "Identifier");
  } else {
    this.parseClassElementName(node2);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node2.static && checkKeyName(node2, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node2.key.start, "Constructor can't have get/set modifier");
    }
    node2.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node2);
  }
  return node2;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element2) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element2.computed = false;
    element2.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element2);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node2) {
  node2.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node2, "StaticBlock");
};
pp$8.parseClassId = function(node2, isStatement) {
  if (this.type === types$1.name) {
    node2.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node2.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node2.id = null;
  }
};
pp$8.parseClassSuper = function(node2) {
  node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element2);
  return element2.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id2 = used[i];
    if (!hasOwn(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element2) {
  var name3 = element2.key.name;
  var curr = privateNameMap[name3];
  var next = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name3] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name3] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node2, name3) {
  var computed = node2.computed;
  var key = node2.key;
  return !computed && (key.type === "Identifier" && key.name === name3 || key.type === "Literal" && key.value === name3);
}
pp$8.parseExport = function(node2, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node2.exported = this.parseModuleExportName();
        this.checkExport(exports, node2.exported, this.lastTokStart);
      } else {
        node2.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node2.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node2, "ExportAllDeclaration");
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) {
        this.next();
      }
      node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      node2.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node2.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node2, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node2.declaration = this.parseStatement(null);
    if (node2.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node2.declaration.declarations);
    } else {
      this.checkExport(exports, node2.declaration.id, node2.declaration.id.start);
    }
    node2.specifiers = [];
    node2.source = null;
  } else {
    node2.declaration = null;
    node2.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node2.source = this.parseExprAtom();
    } else {
      for (var i = 0, list2 = node2.specifiers; i < list2.length; i += 1) {
        var spec = list2[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node2.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node2, "ExportNamedDeclaration");
};
pp$8.checkExport = function(exports, name3, pos) {
  if (!exports) {
    return;
  }
  if (typeof name3 !== "string") {
    name3 = name3.type === "Identifier" ? name3.name : name3.value;
  }
  if (hasOwn(exports, name3)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name3 + "'");
  }
  exports[name3] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type2 = pat.type;
  if (type2 === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type2 === "ObjectPattern") {
    for (var i = 0, list2 = pat.properties; i < list2.length; i += 1) {
      var prop2 = list2[i];
      this.checkPatternExport(exports, prop2);
    }
  } else if (type2 === "ArrayPattern") {
    for (var i$1 = 0, list$13 = pat.elements; i$1 < list$13.length; i$1 += 1) {
      var elt = list$13[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type2 === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type2 === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type2 === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  } else if (type2 === "ParenthesizedExpression") {
    this.checkPatternExport(exports, pat.expression);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list2 = decls; i < list2.length; i += 1) {
    var decl = list2[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first2 = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var node2 = this.startNode();
    node2.local = this.parseModuleExportName();
    node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
    this.checkExport(
      exports,
      node2.exported,
      node2.exported.start
    );
    nodes.push(this.finishNode(node2, "ExportSpecifier"));
  }
  return nodes;
};
pp$8.parseImport = function(node2) {
  this.next();
  if (this.type === types$1.string) {
    node2.specifiers = empty$1;
    node2.source = this.parseExprAtom();
  } else {
    node2.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node2, "ImportDeclaration");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first2 = true;
  if (this.type === types$1.name) {
    var node2 = this.startNode();
    node2.local = this.parseIdent();
    this.checkLValSimple(node2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    var node$12 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$12.local = this.parseIdent();
    this.checkLValSimple(node$12.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$12, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var node$2 = this.startNode();
    node$2.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLValSimple(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node2) {
    switch (node2.type) {
      case "Identifier":
        if (this.inAsync && node2.name === "await") {
          this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node2.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list2 = node2.properties; i < list2.length; i += 1) {
          var prop2 = list2[i];
          this.toAssignable(prop2, isBinding);
          if (prop2.type === "RestElement" && (prop2.argument.type === "ArrayPattern" || prop2.argument.type === "ObjectPattern")) {
            this.raise(prop2.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node2.kind !== "init") {
          this.raise(node2.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node2.value, isBinding);
        break;
      case "ArrayExpression":
        node2.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node2.elements, isBinding);
        break;
      case "SpreadElement":
        node2.type = "RestElement";
        this.toAssignable(node2.argument, isBinding);
        if (node2.argument.type === "AssignmentPattern") {
          this.raise(node2.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node2.operator !== "=") {
          this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node2.type = "AssignmentPattern";
        delete node2.operator;
        this.toAssignable(node2.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node2.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node2;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end2 = exprList.length;
  for (var i = 0; i < end2; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end2) {
    var last = exprList[end2 - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node2, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node2.argument = this.parseBindingAtom();
  return this.finishNode(node2, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node2 = this.startNode();
        this.next();
        node2.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node2, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first2 = true;
  while (!this.eat(close)) {
    if (first2) {
      first2 = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left2) {
  left2 = left2 || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left2;
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left2;
  node2.right = this.parseMaybeAssign();
  return this.finishNode(node2, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list2 = expr.properties; i < list2.length; i += 1) {
        var prop2 = list2[i];
        this.checkLValInnerPattern(prop2, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$13 = expr.elements; i$1 < list$13.length; i$1 += 1) {
        var elem = list$13[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context2 = this.context[i];
    if (context2.token === "function") {
      return context2.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type2 = this.type;
  if (type2.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type2.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type2.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types.f_expr) {
      this.context[index2] = types.f_expr_gen;
    } else {
      this.context[index2] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop2, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop2.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop2.computed || prop2.method || prop2.shorthand)) {
    return;
  }
  var key = prop2.key;
  var name3;
  switch (key.type) {
    case "Identifier":
      name3 = key.name;
      break;
    case "Literal":
      name3 = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop2.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name3 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name3 = "$" + name3;
  var other = propHash[name3];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name3] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node2, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left2 = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left2 = afterLeftParse.call(this, left2, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.operator = this.value;
    if (this.type === types$1.eq) {
      left2 = this.toAssignable(left2, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left2.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left2);
    } else {
      this.checkLValSimple(left2);
    }
    node2.left = left2;
    this.next();
    node2.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node2, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left2;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.test = expr;
    node2.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node2.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node2, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left2, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec2 = this.type.binop;
  if (prec2 != null && (!forInit || this.type !== types$1._in)) {
    if (prec2 > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec2 = types$1.logicalAND.binop;
      }
      var op2 = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right2 = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec2, forInit);
      var node2 = this.buildBinary(leftStartPos, leftStartLoc, left2, right2, op2, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left2;
};
pp$5.buildBinary = function(startPos, startLoc, left2, right2, op2, logical) {
  if (right2.type === "PrivateIdentifier") {
    this.raise(right2.start, "Private identifier can only be left side of binary expression");
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left2;
  node2.operator = op2;
  node2.right = right2;
  return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node2 = this.startNode(), update = this.type === types$1.incDec;
    node2.operator = this.value;
    node2.prefix = true;
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node2.argument);
    } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
      this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
    } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if (forInit || this.privateNameStack.length === 0) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$12 = this.startNodeAt(startPos, startLoc);
      node$12.operator = this.value;
      node$12.prefix = false;
      node$12.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$12, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node2) {
  return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element2.optional) {
      optionalChained = true;
    }
    if (element2 === base || element2.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element2;
        element2 = this.finishNode(chainNode, "ChainExpression");
      }
      return element2;
    }
    base = element2;
  }
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional2 = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional2) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional2 && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.object = base;
    if (computed) {
      node2.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node2.property = this.parsePrivateIdent();
    } else {
      node2.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node2.computed = !!computed;
    if (optionalSupported) {
      node2.optional = optional2;
    }
    base = this.finishNode(node2, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional2 && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$12 = this.startNodeAt(startPos, startLoc);
    node$12.callee = base;
    node$12.arguments = exprList;
    if (optionalSupported) {
      node$12.optional = optional2;
    }
    base = this.finishNode(node$12, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional2 || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node2, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node2 = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node2.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node2, "Super");
    case types$1._this:
      node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value = this.value;
      node2 = this.parseLiteral(value.value);
      node2.regex = { pattern: value.pattern, flags: value.flags };
      return node2;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node2 = this.startNode();
      node2.value = this.type === types$1._null ? null : this.type === types$1._true;
      node2.raw = this.type.keyword;
      this.next();
      return this.finishNode(node2, "Literal");
    case types$1.parenL:
      var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start2;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start2;
        }
      }
      return expr;
    case types$1.bracketL:
      node2 = this.startNode();
      this.next();
      node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node2, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node2 = this.startNode();
      this.next();
      return this.parseFunction(node2, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport();
      } else {
        return this.unexpected();
      }
    default:
      this.unexpected();
  }
};
pp$5.parseExprImport = function() {
  var node2 = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  var meta2 = this.parseIdent(true);
  switch (this.type) {
    case types$1.parenL:
      return this.parseDynamicImport(node2);
    case types$1.dot:
      node2.meta = meta2;
      return this.parseImportMeta(node2);
    default:
      this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node2) {
  this.next();
  node2.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node2, "ImportExpression");
};
pp$5.parseImportMeta = function(node2) {
  this.next();
  var containsEsc = this.containsEsc;
  node2.property = this.parseIdent(true);
  if (node2.property.name !== "meta") {
    this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node2, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node2 = this.startNode();
  node2.value = value;
  node2.raw = this.input.slice(this.start, this.end);
  if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
    node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node2, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first2 = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first2 ? first2 = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par2 = this.startNodeAt(startPos, startLoc);
    par2.expression = val;
    return this.finishNode(par2, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node2 = this.startNode();
  var meta2 = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node2.meta = meta2;
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "target") {
      this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node2, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
  node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
  if (isImport && node2.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types$1.parenL)) {
    node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node2.arguments = empty;
  }
  return this.finishNode(node2, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node2 = this.startNode();
  this.next();
  node2.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node2.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node2.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node2, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop2) {
  return !prop2.computed && prop2.key.type === "Identifier" && prop2.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node2 = this.startNode(), first2 = true, propHash = {};
  node2.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var prop2 = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop2, propHash, refDestructuringErrors);
    }
    node2.properties.push(prop2);
  }
  return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop2 = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop2.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop2, "RestElement");
    }
    prop2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop2, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop2.method = false;
    prop2.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop2);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop2)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop2);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop2, "Property");
};
pp$5.parsePropertyValue = function(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop2.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop2.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop2.kind = "init";
    prop2.method = true;
    prop2.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop2.computed && prop2.key.type === "Identifier" && (prop2.key.name === "get" || prop2.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    prop2.kind = prop2.key.name;
    this.parsePropertyName(prop2);
    prop2.value = this.parseMethod(false);
    var paramCount = prop2.kind === "get" ? 0 : 1;
    if (prop2.value.params.length !== paramCount) {
      var start2 = prop2.value.start;
      if (prop2.kind === "get") {
        this.raiseRecoverable(start2, "getter should have no params");
      } else {
        this.raiseRecoverable(start2, "setter should have exactly one param");
      }
    } else {
      if (prop2.kind === "set" && prop2.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop2.value.params[0].start, "Setter cannot use rest params");
      }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop2.computed && prop2.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop2.key);
    if (prop2.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop2.kind = "init";
    if (isPattern) {
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else {
      prop2.value = this.copyNode(prop2.key);
    }
    prop2.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop2) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop2.computed = true;
      prop2.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop2.key;
    } else {
      prop2.computed = false;
    }
  }
  return prop2.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node2) {
  node2.id = null;
  if (this.options.ecmaVersion >= 6) {
    node2.generator = node2.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 6) {
    node2.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node2, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node2.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node2, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node2.body = this.parseMaybeAssign(forInit);
    node2.expression = true;
    this.checkParams(node2, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
    if (this.strict && node2.id) {
      this.checkLValSimple(node2.id, BIND_OUTSIDE);
    }
    node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node2.expression = false;
    this.adaptDirectivePrologue(node2.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list2 = params; i < list2.length; i += 1) {
    var param = list2[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node2, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list2 = node2.params; i < list2.length; i += 1) {
    var param = list2[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first2 = true;
  while (!this.eat(close)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first2 = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start2 = ref2.start;
  var end2 = ref2.end;
  var name3 = ref2.name;
  if (this.inGenerator && name3 === "yield") {
    this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name3 === "await") {
    this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name3 === "arguments") {
    this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name3 === "arguments" || name3 === "await")) {
    this.raise(start2, "Cannot use " + name3 + " in class static initialization block");
  }
  if (this.keywords.test(name3)) {
    this.raise(start2, "Unexpected keyword '" + name3 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start2, end2).indexOf("\\") !== -1) {
    return;
  }
  var re3 = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re3.test(name3)) {
    if (!this.inAsync && name3 === "await") {
      this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start2, "The keyword '" + name3 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node2 = this.startNode();
  if (this.type === types$1.name) {
    node2.name = this.value;
  } else if (this.type.keyword) {
    node2.name = this.type.keyword;
    if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next(!!liberal);
  this.finishNode(node2, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node2);
    if (node2.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node2.start;
    }
  }
  return node2;
};
pp$5.parsePrivateIdent = function() {
  var node2 = this.startNode();
  if (this.type === types$1.privateId) {
    node2.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node2, "PrivateIdentifier");
  if (this.privateNameStack.length === 0) {
    this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
  } else {
    this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
  }
  return node2;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node2.delegate = false;
    node2.argument = null;
  } else {
    node2.delegate = this.eat(types$1.star);
    node2.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node2, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node2, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message2) {
  var loc = getLineInfo(this.input, pos);
  message2 += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message2);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name3, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name3) > -1 || scope.functions.indexOf(name3) > -1 || scope.var.indexOf(name3) > -1;
    scope.lexical.push(name3);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name3];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name3);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name3) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name3) > -1 || scope$2.var.indexOf(name3) > -1;
    }
    scope$2.functions.push(name3);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name3) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name3) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name3) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name3);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name3];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name3 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser2, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser2.options.locations) {
    this.loc = new SourceLocation(parser2, loc);
  }
  if (parser2.options.directSourceFile) {
    this.sourceFile = parser2.options.directSourceFile;
  }
  if (parser2.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node2, type2, pos, loc) {
  node2.type = type2;
  node2.end = pos;
  if (this.options.locations) {
    node2.loc.end = loc;
  }
  if (this.options.ranges) {
    node2.range[1] = pos;
  }
  return node2;
}
pp$2.finishNode = function(node2, type2) {
  return finishNodeAt.call(this, node2, type2, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node2, type2, pos, loc) {
  return finishNodeAt.call(this, node2, type2, pos, loc);
};
pp$2.copyNode = function(node2) {
  var newNode = new Node(this, node2.start, this.startLoc);
  for (var prop2 in node2) {
    newNode[prop2] = node2[prop2];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Kawi Nag_Mundari Nagm";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d2 = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
  d2.nonBinary.gc = d2.nonBinary.General_Category;
  d2.nonBinary.sc = d2.nonBinary.Script;
  d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
}
for (i = 0, list2 = [9, 10, 11, 12, 13, 14]; i < list2.length; i += 1) {
  ecmaVersion = list2[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list2;
var pp$1 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState2(parser2) {
  this.parser = parser2;
  this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "");
  this.unicodeProperties = data[parser2.options.ecmaVersion >= 14 ? 14 : parser2.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start2, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start2 | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};
RegExpValidationState.prototype.raise = function raise(message2) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message2);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l2 = s.length;
  if (i >= l2) {
    return -1;
  }
  var c2 = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l2) {
    return c2;
  }
  var next = s.charCodeAt(i + 1);
  return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l2 = s.length;
  if (i >= l2) {
    return l2;
  }
  var c2 = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l2 || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch2, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch2) {
    this.advance(forceU);
    return true;
  }
  return false;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list2 = state.backReferenceNames; i < list2.length; i += 1) {
    var name3 = list2[i];
    if (state.groupNames.indexOf(name3) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    this.regexp_alternative(state);
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start2 = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start2;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start2;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start2 = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start2 = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    ) && state.eat(
      58
      /* : */
    )) {
      this.regexp_disjunction(state);
      if (state.eat(
        41
        /* ) */
      )) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch2 = state.current();
  if (isSyntaxCharacter(ch2)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch2) {
  return ch2 === 36 || ch2 >= 40 && ch2 <= 43 || ch2 === 46 || ch2 === 63 || ch2 >= 91 && ch2 <= 94 || ch2 >= 123 && ch2 <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start2 = state.pos;
  var ch2 = 0;
  while ((ch2 = state.current()) !== -1 && !isSyntaxCharacter(ch2)) {
    state.advance();
  }
  return state.pos !== start2;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch2 = state.current();
  if (ch2 !== -1 && ch2 !== 36 && !(ch2 >= 40 && ch2 <= 43) && ch2 !== 46 && ch2 !== 63 && ch2 !== 91 && ch2 !== 94 && ch2 !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return;
    }
    state.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch2 = state.current(forceU);
  state.advance(forceU);
  if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch2 = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch2)) {
    state.lastIntValue = ch2;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierStart(ch2) {
  return isIdentifierStart(ch2, true) || ch2 === 36 || ch2 === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch2 = state.current(forceU);
  state.advance(forceU);
  if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch2 = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch2)) {
    state.lastIntValue = ch2;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierPart(ch2) {
  return isIdentifierChar(ch2, true) || ch2 === 36 || ch2 === 95 || ch2 === 8204 || ch2 === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true;
    }
    if (n <= state.numCapturingParens) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start2 = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch2 = state.current();
  if (ch2 === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch2 === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch2 === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch2 === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch2 === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch2 = state.current();
  if (isControlLetter(ch2)) {
    state.lastIntValue = ch2 % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch2) {
  return ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start2 = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start2;
  }
  return false;
};
function isValidUnicode(ch2) {
  return ch2 >= 0 && ch2 <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch2 = state.current();
  if (ch2 !== 99 && (!state.switchN || ch2 !== 107)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch2 = state.current();
  if (ch2 >= 49 && ch2 <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
      state.advance();
    } while ((ch2 = state.current()) >= 48 && ch2 <= 57);
    return true;
  }
  return false;
};
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch2 = state.current();
  if (isCharacterClassEscape(ch2)) {
    state.lastIntValue = -1;
    state.advance();
    return true;
  }
  if (state.switchU && this.options.ecmaVersion >= 9 && (ch2 === 80 || ch2 === 112)) {
    state.lastIntValue = -1;
    state.advance();
    if (state.eat(
      123
      /* { */
    ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(
      125
      /* } */
    )) {
      return true;
    }
    state.raise("Invalid property name");
  }
  return false;
};
function isCharacterClassEscape(ch2) {
  return ch2 === 100 || ch2 === 68 || ch2 === 115 || ch2 === 83 || ch2 === 119 || ch2 === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name3 = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name3, value);
      return true;
    }
  }
  state.pos = start2;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true;
  }
  return false;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name3, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name3)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name3].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue)) {
    state.raise("Invalid property name");
  }
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch2 = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch2 = state.current())) {
    state.lastStringValue += codePointToString(ch2);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch2) {
  return isControlLetter(ch2) || ch2 === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch2 = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch2 = state.current())) {
    state.lastStringValue += codePointToString(ch2);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch2) {
  return isUnicodePropertyNameCharacter(ch2) || isDecimalDigit(ch2);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    state.eat(
      94
      /* ^ */
    );
    this.regexp_classRanges(state);
    if (state.eat(
      93
      /* ] */
    )) {
      return true;
    }
    state.raise("Unterminated character class");
  }
  return false;
};
pp$1.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left2 = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right2 = state.lastIntValue;
      if (state.switchU && (left2 === -1 || right2 === -1)) {
        state.raise("Invalid character class");
      }
      if (left2 !== -1 && right2 !== -1 && left2 > right2) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  var ch2 = state.current();
  if (ch2 !== 93) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch2 = state.current();
  if (isDecimalDigit(ch2) || ch2 === 95) {
    state.lastIntValue = ch2 % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start2 = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start2 = state.pos;
  var ch2 = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch2 = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
    state.advance();
  }
  return state.pos !== start2;
};
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start2 = state.pos;
  var ch2 = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch2 = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
    state.advance();
  }
  return state.pos !== start2;
};
function isHexDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57 || ch2 >= 65 && ch2 <= 70 || ch2 >= 97 && ch2 <= 102;
}
function hexToInt(ch2) {
  if (ch2 >= 65 && ch2 <= 70) {
    return 10 + (ch2 - 65);
  }
  if (ch2 >= 97 && ch2 <= 102) {
    return 10 + (ch2 - 97);
  }
  return ch2 - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch2 = state.current();
  if (isOctalDigit(ch2)) {
    state.lastIntValue = ch2 - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start2 = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch2 = state.current();
    if (!isHexDigit(ch2)) {
      state.pos = start2;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code2) {
  if (isIdentifierStart(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code2);
};
pp.fullCharCodeAtPos = function() {
  var code2 = this.input.charCodeAt(this.pos);
  if (code2 <= 55295 || code2 >= 56320) {
    return code2;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code2 : (code2 << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start2 = this.pos, end2 = this.input.indexOf("*/", this.pos += 2);
  if (end2 === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end2 + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start2; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start2 + 2, end2),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start2 = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch2 = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch2)) {
    ch2 = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start2 + startSkip, this.pos),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch2 = this.input.charCodeAt(this.pos);
      switch (ch2) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch2 > 8 && ch2 < 14 || ch2 >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch2))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type2, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type2;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code2 === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code2) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code2) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code2) {
    size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code2 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code2 = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code2 = this.fullCharCodeAtPos();
    if (isIdentifierStart(code2, true) || code2 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.getTokenFromCode = function(code2) {
  switch (code2) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code2);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code2);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code2);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code2);
    case 60:
    case 62:
      return this.readToken_lt_gt(code2);
    case 61:
    case 33:
      return this.readToken_eq_excl(code2);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.finishOp = function(type2, size) {
  var str2 = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type2, str2);
};
pp.readRegexp = function() {
  var escaped, inClass, start2 = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start2, "Unterminated regular expression");
    }
    var ch2 = this.input.charAt(this.pos);
    if (lineBreak.test(ch2)) {
      this.raise(start2, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch2 === "[") {
        inClass = true;
      } else if (ch2 === "]" && inClass) {
        inClass = false;
      } else if (ch2 === "/" && !inClass) {
        break;
      }
      escaped = ch2 === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start2, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start2, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start2 = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code2 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code2 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code2;
      continue;
    }
    if (code2 >= 97) {
      val = code2 - 97 + 10;
    } else if (code2 >= 65) {
      val = code2 - 65 + 10;
    } else if (code2 >= 48 && code2 <= 57) {
      val = code2 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code2;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start2 || len != null && this.pos - start2 !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str2, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str2, 8);
  }
  return parseFloat(str2.replace(/_/g, ""));
}
function stringToBigInt(str2) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str2.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start2 = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start2 = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start2, "Invalid number");
  }
  var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
  if (octal && this.strict) {
    this.raise(start2, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start2, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start2, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch2 = this.input.charCodeAt(this.pos), code2;
  if (ch2 === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code2 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code2 = this.readHexChar(4);
  }
  return code2;
};
pp.readString = function(quote2) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch2 = this.input.charCodeAt(this.pos);
    if (ch2 === quote2) {
      break;
    }
    if (ch2 === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch2 === 8232 || ch2 === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch2)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position2, message2) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position2, message2);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch2 = this.input.charCodeAt(this.pos);
    if (ch2 === 96 || ch2 === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch2 === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch2 === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch2)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch2) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch2);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch2 = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch2) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch2 >= 48 && ch2 <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch2 = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch2 === 56 || ch2 === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch2)) {
        return "";
      }
      return String.fromCharCode(ch2);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word2 = "", first2 = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch2 = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch2, astral)) {
      this.pos += ch2 <= 65535 ? 1 : 2;
    } else if (ch2 === 92) {
      this.containsEsc = true;
      word2 += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first2 ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word2 += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first2 = false;
  }
  return word2 + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word2 = this.readWord1();
  var type2 = types$1.name;
  if (this.keywords.test(word2)) {
    type2 = keywords[word2];
  }
  return this.finishToken(type2, word2);
};
var version = "8.8.2";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options2) {
  return Parser.parse(input, options2);
}
function parseExpressionAt2(input, pos, options2) {
  return Parser.parseExpressionAt(input, pos, options2);
}
var regex_whitespace = /\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]*/;
var regex_ends_with_whitespaces = /[ \t\r\n]*$/;
var regex_not_newline_characters = /[^\n]/g;
var regex_svelte_ignore = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;
function extract_svelte_ignore(text3) {
  const match = regex_svelte_ignore.exec(text3);
  return match ? match[1].split(regex_whitespace).map((x2) => x2.trim()).filter(Boolean) : [];
}
function fuzzymatch(name3, names) {
  const set2 = new FuzzySet(names);
  const matches = set2.get(name3);
  return matches && matches[0] && matches[0][0] > 0.7 ? matches[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null)
    return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  if (str1.length > str2.length) {
    return 1 - distance / str1.length;
  } else {
    return 1 - distance / str2.length;
  }
}
function levenshtein(str1, str2) {
  const current2 = [];
  let prev;
  let value;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value = prev;
        } else {
          value = Math.min(current2[j], current2[j - 1], prev) + 1;
        }
      } else {
        value = i + j;
      }
      prev = current2[j];
      current2[j] = value;
    }
  }
  return current2.pop();
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value, gram_size = 2) {
  const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b) {
  return b[0] - a[0];
}
var FuzzySet = class {
  constructor(arr) {
    this.exact_set = {};
    this.match_dict = {};
    this.items = {};
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  add(value) {
    const normalized_value = value.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value, i);
    }
  }
  _add(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const items = this.items[gram_size] || [];
    const index2 = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index2, gram_count]);
      } else {
        this.match_dict[gram] = [[index2, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index2] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value;
  }
  get(value) {
    const normalized_value = value.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return [[1, result]];
    }
    let results = [];
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      results = this.__get(value, gram_size);
      if (results) {
        return results;
      }
    }
    return null;
  }
  __get(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const matches = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index2;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index2 = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index2 in matches) {
            matches[index2] += gram_count * other_gram_count;
          } else {
            matches[index2] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches) {
      match_score = matches[match_index];
      results.push([
        match_score / (vector_normal * items[match_index][0]),
        items[match_index][1]
      ]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([
        _distance(results[i2][1], normalized_value),
        results[i2][1]
      ]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] == results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};
var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function is_void(name3) {
  return void_element_names.test(name3) || name3.toLowerCase() === "!doctype";
}
function list$1(items, conjunction = "or") {
  if (items.length === 1)
    return items[0];
  return `${items.slice(0, -1).join(", ")} ${conjunction} ${items[items.length - 1]}`;
}
var parser_errors = {
  css_syntax_error: (message2) => ({
    code: "css-syntax-error",
    message: message2
  }),
  duplicate_attribute: {
    code: "duplicate-attribute",
    message: "Attributes need to be unique"
  },
  duplicate_element: (slug, name3) => ({
    code: `duplicate-${slug}`,
    message: `A component can only have one <${name3}> tag`
  }),
  duplicate_style: {
    code: "duplicate-style",
    message: "You can only have one top-level <style> tag per component"
  },
  empty_attribute_shorthand: {
    code: "empty-attribute-shorthand",
    message: "Attribute shorthand cannot be empty"
  },
  empty_directive_name: (type2) => ({
    code: "empty-directive-name",
    message: `${type2} name cannot be empty`
  }),
  empty_global_selector: {
    code: "css-syntax-error",
    message: ":global() must contain a selector"
  },
  expected_block_type: {
    code: "expected-block-type",
    message: "Expected if, each or await"
  },
  expected_name: {
    code: "expected-name",
    message: "Expected name"
  },
  invalid_catch_placement_unclosed_block: (block2) => ({
    code: "invalid-catch-placement",
    message: `Expected to close ${block2} before seeing {:catch} block`
  }),
  invalid_catch_placement_without_await: {
    code: "invalid-catch-placement",
    message: "Cannot have an {:catch} block outside an {#await ...} block"
  },
  invalid_component_definition: {
    code: "invalid-component-definition",
    message: "invalid component definition"
  },
  invalid_closing_tag_unopened: (name3) => ({
    code: "invalid-closing-tag",
    message: `</${name3}> attempted to close an element that was not open`
  }),
  invalid_closing_tag_autoclosed: (name3, reason) => ({
    code: "invalid-closing-tag",
    message: `</${name3}> attempted to close <${name3}> that was already automatically closed by <${reason}>`
  }),
  invalid_debug_args: {
    code: "invalid-debug-args",
    message: "{@debug ...} arguments must be identifiers, not arbitrary expressions"
  },
  invalid_declaration: {
    code: "invalid-declaration",
    message: "Declaration cannot be empty"
  },
  invalid_directive_value: {
    code: "invalid-directive-value",
    message: "Directive value must be a JavaScript expression enclosed in curly braces"
  },
  invalid_elseif: {
    code: "invalid-elseif",
    message: "'elseif' should be 'else if'"
  },
  invalid_elseif_placement_outside_if: {
    code: "invalid-elseif-placement",
    message: "Cannot have an {:else if ...} block outside an {#if ...} block"
  },
  invalid_elseif_placement_unclosed_block: (block2) => ({
    code: "invalid-elseif-placement",
    message: `Expected to close ${block2} before seeing {:else if ...} block`
  }),
  invalid_else_placement_outside_if: {
    code: "invalid-else-placement",
    message: "Cannot have an {:else} block outside an {#if ...} or {#each ...} block"
  },
  invalid_else_placement_unclosed_block: (block2) => ({
    code: "invalid-else-placement",
    message: `Expected to close ${block2} before seeing {:else} block`
  }),
  invalid_element_content: (slug, name3) => ({
    code: `invalid-${slug}-content`,
    message: `<${name3}> cannot have children`
  }),
  invalid_element_definition: {
    code: "invalid-element-definition",
    message: "Invalid element definition"
  },
  invalid_element_placement: (slug, name3) => ({
    code: `invalid-${slug}-placement`,
    message: `<${name3}> tags cannot be inside elements or blocks`
  }),
  invalid_logic_block_placement: (location, name3) => ({
    code: "invalid-logic-block-placement",
    message: `{#${name3}} logic block cannot be ${location}`
  }),
  invalid_tag_placement: (location, name3) => ({
    code: "invalid-tag-placement",
    message: `{@${name3}} tag cannot be ${location}`
  }),
  invalid_ref_directive: (name3) => ({
    code: "invalid-ref-directive",
    message: `The ref directive is no longer supported — use \`bind:this={${name3}}\` instead`
  }),
  invalid_ref_selector: {
    code: "invalid-ref-selector",
    message: "ref selectors are no longer supported"
  },
  invalid_self_placement: {
    code: "invalid-self-placement",
    message: "<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components"
  },
  invalid_script_instance: {
    code: "invalid-script",
    message: "A component can only have one instance-level <script> element"
  },
  invalid_script_module: {
    code: "invalid-script",
    message: 'A component can only have one <script context="module"> element'
  },
  invalid_script_context_attribute: {
    code: "invalid-script",
    message: "context attribute must be static"
  },
  invalid_script_context_value: {
    code: "invalid-script",
    message: 'If the context attribute is supplied, its value must be "module"'
  },
  invalid_tag_name: {
    code: "invalid-tag-name",
    message: "Expected valid tag name"
  },
  invalid_tag_name_svelte_element: (tags, match) => ({
    code: "invalid-tag-name",
    message: `Valid <svelte:...> tag names are ${list$1(tags)}${match ? " (did you mean " + match + "?)" : ""}`
  }),
  invalid_then_placement_unclosed_block: (block2) => ({
    code: "invalid-then-placement",
    message: `Expected to close ${block2} before seeing {:then} block`
  }),
  invalid_then_placement_without_await: {
    code: "invalid-then-placement",
    message: "Cannot have an {:then} block outside an {#await ...} block"
  },
  invalid_void_content: (name3) => ({
    code: "invalid-void-content",
    message: `<${name3}> is a void element and cannot have children, or a closing tag`
  }),
  missing_component_definition: {
    code: "missing-component-definition",
    message: "<svelte:component> must have a 'this' attribute"
  },
  missing_attribute_value: {
    code: "missing-attribute-value",
    message: "Expected value for the attribute"
  },
  missing_element_definition: {
    code: "missing-element-definition",
    message: "<svelte:element> must have a 'this' attribute"
  },
  unclosed_script: {
    code: "unclosed-script",
    message: "<script> must have a closing tag"
  },
  unclosed_style: {
    code: "unclosed-style",
    message: "<style> must have a closing tag"
  },
  unclosed_comment: {
    code: "unclosed-comment",
    message: "comment was left open, expected -->"
  },
  unclosed_attribute_value: (token) => ({
    code: "unclosed-attribute-value",
    message: `Expected to close the attribute value with ${token}`
  }),
  unexpected_block_close: {
    code: "unexpected-block-close",
    message: "Unexpected block closing tag"
  },
  unexpected_eof: {
    code: "unexpected-eof",
    message: "Unexpected end of input"
  },
  unexpected_eof_token: (token) => ({
    code: "unexpected-eof",
    message: `Unexpected ${token}`
  }),
  unexpected_token: (token) => ({
    code: "unexpected-token",
    message: `Expected ${token}`
  }),
  unexpected_token_destructure: {
    code: "unexpected-token",
    message: "Expected identifier or destructure pattern"
  }
};
var WalkerBase = class {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node2) => this.replacement = node2
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(parent, prop2, index2, node2) {
    if (parent && prop2) {
      if (index2 != null) {
        parent[prop2][index2] = node2;
      } else {
        parent[prop2] = node2;
      }
    }
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(parent, prop2, index2) {
    if (parent && prop2) {
      if (index2 !== null && index2 !== void 0) {
        parent[prop2].splice(index2, 1);
      } else {
        delete parent[prop2];
      }
    }
  }
};
var SyncWalker = class extends WalkerBase {
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(enter, leave) {
    super();
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node2) => this.replacement = node2
    };
    this.enter = enter;
    this.leave = leave;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(node2, parent, prop2, index2) {
    if (node2) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node2, parent, prop2, index2);
        if (this.replacement) {
          node2 = this.replacement;
          this.replace(parent, prop2, index2, node2);
        }
        if (this.should_remove) {
          this.remove(parent, prop2, index2);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node2;
        if (removed)
          return null;
      }
      let key;
      for (key in node2) {
        const value = node2[key];
        if (value && typeof value === "object") {
          if (Array.isArray(value)) {
            const nodes = (
              /** @type {Array<unknown>} */
              value
            );
            for (let i = 0; i < nodes.length; i += 1) {
              const item = nodes[i];
              if (isNode(item)) {
                if (!this.visit(item, node2, key, i)) {
                  i--;
                }
              }
            }
          } else if (isNode(value)) {
            this.visit(value, node2, key, null);
          }
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node2, parent, prop2, index2);
        if (this.replacement) {
          node2 = this.replacement;
          this.replace(parent, prop2, index2, node2);
        }
        if (this.should_remove) {
          this.remove(parent, prop2, index2);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node2;
  }
};
function isNode(value) {
  return value !== null && typeof value === "object" && "type" in value && typeof value.type === "string";
}
function walk(ast2, { enter, leave }) {
  const instance = new SyncWalker(enter, leave);
  return instance.visit(ast2, null);
}
var id = Math.round(Math.random() * 1e20).toString(36);
var re = new RegExp(`_${id}_(?:(\\d+)|(AT)|(HASH))_(\\w+)?`, "g");
var get_comment_handlers = (comments, raw2) => ({
  // pass to acorn options
  /**
   * @param {boolean} block
   * @param {string} value
   * @param {number} start
   * @param {number} end
   */
  onComment: (block2, value, start2, end2) => {
    if (block2 && /\n/.test(value)) {
      let a = start2;
      while (a > 0 && raw2[a - 1] !== "\n")
        a -= 1;
      let b = a;
      while (/[ \t]/.test(raw2[b]))
        b += 1;
      const indentation2 = raw2.slice(a, b);
      value = value.replace(new RegExp(`^${indentation2}`, "gm"), "");
    }
    comments.push({ type: block2 ? "Block" : "Line", value, start: start2, end: end2 });
  },
  // pass to estree-walker options
  /** @param {NodeWithLocation} node */
  enter(node2) {
    let comment2;
    while (comments[0] && comments[0].start < node2.start) {
      comment2 = comments.shift();
      comment2.value = comment2.value.replace(
        re,
        (match, id2, at3, hash, value) => {
          if (hash)
            return `#${value}`;
          if (at3)
            return `@${value}`;
          return match;
        }
      );
      const next = comments[0] || node2;
      comment2.has_trailing_newline = comment2.type === "Line" || /\n/.test(raw2.slice(comment2.end, next.start));
      (node2.leadingComments || (node2.leadingComments = [])).push(comment2);
    }
  },
  /** @param {NodeWithLocation} node */
  leave(node2) {
    if (comments[0]) {
      const slice3 = raw2.slice(node2.end, comments[0].start);
      if (/^[,) \t]*$/.test(slice3)) {
        node2.trailingComments = [comments.shift()];
      }
    }
  }
});
function push_array(array, items) {
  for (let i = 0; i < items.length; i++) {
    array.push(items[i]);
  }
}
function handle(node2, state) {
  const handler = handlers[node2.type];
  if (!handler) {
    throw new Error(`Not implemented ${node2.type}`);
  }
  const result = handler(node2, state);
  if (node2.leadingComments) {
    result.unshift(
      c(
        node2.leadingComments.map(
          (comment2) => comment2.type === "Block" ? `/*${comment2.value}*/${/** @type {any} */
          comment2.has_trailing_newline ? `
${state.indent}` : ` `}` : `//${comment2.value}${/** @type {any} */
          comment2.has_trailing_newline ? `
${state.indent}` : ` `}`
        ).join(``)
      )
    );
  }
  if (node2.trailingComments) {
    state.comments.push(node2.trailingComments[0]);
  }
  return result;
}
function c(content, node2) {
  return {
    content,
    loc: node2 && node2.loc,
    has_newline: /\n/.test(content)
  };
}
var OPERATOR_PRECEDENCE = {
  "||": 2,
  "&&": 3,
  "??": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
};
var EXPRESSIONS_PRECEDENCE = {
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  MemberExpression: 19,
  CallExpression: 19,
  NewExpression: 19,
  AwaitExpression: 17,
  ClassExpression: 17,
  FunctionExpression: 17,
  ObjectExpression: 17,
  UpdateExpression: 16,
  UnaryExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  ArrowFunctionExpression: 3,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function needs_parens(node2, parent, is_right) {
  if (node2.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node2.operator !== "??" || parent.operator !== "??" && node2.operator === "??")) {
    return true;
  }
  const precedence = EXPRESSIONS_PRECEDENCE[node2.type];
  const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
  if (precedence !== parent_precedence) {
    return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
  }
  if (precedence !== 13 && precedence !== 14) {
    return false;
  }
  if (
    /** @type {BinaryExpression} */
    node2.operator === "**" && parent.operator === "**"
  ) {
    return !is_right;
  }
  if (is_right) {
    return OPERATOR_PRECEDENCE[
      /** @type {BinaryExpression} */
      node2.operator
    ] <= OPERATOR_PRECEDENCE[parent.operator];
  }
  return OPERATOR_PRECEDENCE[
    /** @type {BinaryExpression} */
    node2.operator
  ] < OPERATOR_PRECEDENCE[parent.operator];
}
function has_call_expression(node2) {
  while (node2) {
    if (node2.type[0] === "CallExpression") {
      return true;
    } else if (node2.type === "MemberExpression") {
      node2 = node2.object;
    } else {
      return false;
    }
  }
}
var has_newline = (chunks) => {
  for (let i = 0; i < chunks.length; i += 1) {
    if (chunks[i].has_newline)
      return true;
  }
  return false;
};
var get_length = (chunks) => {
  let total = 0;
  for (let i = 0; i < chunks.length; i += 1) {
    total += chunks[i].content.length;
  }
  return total;
};
var sum = (a, b) => a + b;
var join = (nodes, separator) => {
  if (nodes.length === 0)
    return [];
  const joined = [...nodes[0]];
  for (let i = 1; i < nodes.length; i += 1) {
    joined.push(separator);
    push_array(joined, nodes[i]);
  }
  return joined;
};
var scoped = (fn2) => {
  const scoped_fn = (node2, state) => {
    return fn2(node2, {
      ...state,
      scope: state.scope_map.get(node2)
    });
  };
  return scoped_fn;
};
var deconflict = (name3, names) => {
  const original = name3;
  let i = 1;
  while (names.has(name3)) {
    name3 = `${original}$${i++}`;
  }
  return name3;
};
var handle_body = (nodes, state) => {
  const chunks = [];
  const body2 = nodes.map((statement) => {
    const chunks2 = handle(statement, {
      ...state,
      indent: state.indent
    });
    let add_newline = false;
    while (state.comments.length) {
      const comment2 = state.comments.shift();
      const prefix = add_newline ? `
${state.indent}` : ` `;
      chunks2.push(
        c(
          comment2.type === "Block" ? `${prefix}/*${comment2.value}*/` : `${prefix}//${comment2.value}`
        )
      );
      add_newline = comment2.type === "Line";
    }
    return chunks2;
  });
  let needed_padding = false;
  for (let i = 0; i < body2.length; i += 1) {
    const needs_padding = has_newline(body2[i]);
    if (i > 0) {
      chunks.push(
        c(
          needs_padding || needed_padding ? `

${state.indent}` : `
${state.indent}`
        )
      );
    }
    push_array(chunks, body2[i]);
    needed_padding = needs_padding;
  }
  return chunks;
};
var handle_var_declaration = (node2, state) => {
  const chunks = [c(`${node2.kind} `)];
  const declarators = node2.declarations.map(
    (d2) => handle(d2, {
      ...state,
      indent: state.indent + (node2.declarations.length === 1 ? "" : "	")
    })
  );
  const multiple_lines = declarators.some(has_newline) || declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2 > 80;
  const separator = c(multiple_lines ? `,
${state.indent}	` : ", ");
  push_array(chunks, join(declarators, separator));
  return chunks;
};
var handlers = {
  Program(node2, state) {
    return handle_body(node2.body, state);
  },
  BlockStatement: scoped((node2, state) => {
    return [
      c(`{
${state.indent}	`),
      ...handle_body(node2.body, { ...state, indent: state.indent + "	" }),
      c(`
${state.indent}}`)
    ];
  }),
  EmptyStatement(node2, state) {
    return [c(";")];
  },
  ParenthesizedExpression(node2, state) {
    return handle(node2.expression, state);
  },
  ExpressionStatement(node2, state) {
    if (node2.expression.type === "AssignmentExpression" && node2.expression.left.type === "ObjectPattern") {
      return [c("("), ...handle(node2.expression, state), c(");")];
    }
    return [...handle(node2.expression, state), c(";")];
  },
  IfStatement(node2, state) {
    const chunks = [
      c("if ("),
      ...handle(node2.test, state),
      c(") "),
      ...handle(node2.consequent, state)
    ];
    if (node2.alternate) {
      chunks.push(c(" else "));
      push_array(chunks, handle(node2.alternate, state));
    }
    return chunks;
  },
  LabeledStatement(node2, state) {
    return [...handle(node2.label, state), c(": "), ...handle(node2.body, state)];
  },
  BreakStatement(node2, state) {
    return node2.label ? [c("break "), ...handle(node2.label, state), c(";")] : [c("break;")];
  },
  ContinueStatement(node2, state) {
    return node2.label ? [c("continue "), ...handle(node2.label, state), c(";")] : [c("continue;")];
  },
  WithStatement(node2, state) {
    return [
      c("with ("),
      ...handle(node2.object, state),
      c(") "),
      ...handle(node2.body, state)
    ];
  },
  SwitchStatement(node2, state) {
    const chunks = [
      c("switch ("),
      ...handle(node2.discriminant, state),
      c(") {")
    ];
    node2.cases.forEach((block2) => {
      if (block2.test) {
        chunks.push(c(`
${state.indent}	case `));
        push_array(
          chunks,
          handle(block2.test, { ...state, indent: `${state.indent}	` })
        );
        chunks.push(c(":"));
      } else {
        chunks.push(c(`
${state.indent}	default:`));
      }
      block2.consequent.forEach((statement) => {
        chunks.push(c(`
${state.indent}		`));
        push_array(
          chunks,
          handle(statement, { ...state, indent: `${state.indent}		` })
        );
      });
    });
    chunks.push(c(`
${state.indent}}`));
    return chunks;
  },
  ReturnStatement(node2, state) {
    if (node2.argument) {
      const contains_comment = node2.argument.leadingComments && node2.argument.leadingComments.some(
        (comment2) => comment2.has_trailing_newline
      );
      return [
        c(contains_comment ? "return (" : "return "),
        ...handle(node2.argument, state),
        c(contains_comment ? ");" : ";")
      ];
    } else {
      return [c("return;")];
    }
  },
  ThrowStatement(node2, state) {
    return [c("throw "), ...handle(node2.argument, state), c(";")];
  },
  TryStatement(node2, state) {
    const chunks = [c("try "), ...handle(node2.block, state)];
    if (node2.handler) {
      if (node2.handler.param) {
        chunks.push(c(" catch("));
        push_array(chunks, handle(node2.handler.param, state));
        chunks.push(c(") "));
      } else {
        chunks.push(c(" catch "));
      }
      push_array(chunks, handle(node2.handler.body, state));
    }
    if (node2.finalizer) {
      chunks.push(c(" finally "));
      push_array(chunks, handle(node2.finalizer, state));
    }
    return chunks;
  },
  WhileStatement(node2, state) {
    return [
      c("while ("),
      ...handle(node2.test, state),
      c(") "),
      ...handle(node2.body, state)
    ];
  },
  DoWhileStatement(node2, state) {
    return [
      c("do "),
      ...handle(node2.body, state),
      c(" while ("),
      ...handle(node2.test, state),
      c(");")
    ];
  },
  ForStatement: scoped((node2, state) => {
    const chunks = [c("for (")];
    if (node2.init) {
      if (node2.init.type === "VariableDeclaration") {
        push_array(chunks, handle_var_declaration(node2.init, state));
      } else {
        push_array(chunks, handle(node2.init, state));
      }
    }
    chunks.push(c("; "));
    if (node2.test)
      push_array(chunks, handle(node2.test, state));
    chunks.push(c("; "));
    if (node2.update)
      push_array(chunks, handle(node2.update, state));
    chunks.push(c(") "));
    push_array(chunks, handle(node2.body, state));
    return chunks;
  }),
  ForInStatement: scoped((node2, state) => {
    const chunks = [c(`for ${node2.await ? "await " : ""}(`)];
    if (node2.left.type === "VariableDeclaration") {
      push_array(chunks, handle_var_declaration(node2.left, state));
    } else {
      push_array(chunks, handle(node2.left, state));
    }
    chunks.push(c(node2.type === "ForInStatement" ? ` in ` : ` of `));
    push_array(chunks, handle(node2.right, state));
    chunks.push(c(") "));
    push_array(chunks, handle(node2.body, state));
    return chunks;
  }),
  DebuggerStatement(node2, state) {
    return [c("debugger", node2), c(";")];
  },
  FunctionDeclaration: scoped(
    (node2, state) => {
      const chunks = [];
      if (node2.async)
        chunks.push(c("async "));
      chunks.push(c(node2.generator ? "function* " : "function "));
      if (node2.id)
        push_array(chunks, handle(node2.id, state));
      chunks.push(c("("));
      const params = node2.params.map(
        (p2) => handle(p2, {
          ...state,
          indent: state.indent + "	"
        })
      );
      const multiple_lines = params.some(has_newline) || params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2 > 80;
      const separator = c(multiple_lines ? `,
${state.indent}` : ", ");
      if (multiple_lines) {
        chunks.push(c(`
${state.indent}	`));
        push_array(chunks, join(params, separator));
        chunks.push(c(`
${state.indent}`));
      } else {
        push_array(chunks, join(params, separator));
      }
      chunks.push(c(") "));
      push_array(chunks, handle(node2.body, state));
      return chunks;
    }
  ),
  VariableDeclaration(node2, state) {
    return handle_var_declaration(node2, state).concat(c(";"));
  },
  VariableDeclarator(node2, state) {
    if (node2.init) {
      return [...handle(node2.id, state), c(" = "), ...handle(node2.init, state)];
    } else {
      return handle(node2.id, state);
    }
  },
  ClassDeclaration(node2, state) {
    const chunks = [c("class ")];
    if (node2.id) {
      push_array(chunks, handle(node2.id, state));
      chunks.push(c(" "));
    }
    if (node2.superClass) {
      chunks.push(c("extends "));
      push_array(chunks, handle(node2.superClass, state));
      chunks.push(c(" "));
    }
    push_array(chunks, handle(node2.body, state));
    return chunks;
  },
  ImportDeclaration(node2, state) {
    const chunks = [c("import ")];
    const { length } = node2.specifiers;
    const source = handle(node2.source, state);
    if (length > 0) {
      let i = 0;
      while (i < length) {
        if (i > 0) {
          chunks.push(c(", "));
        }
        const specifier = node2.specifiers[i];
        if (specifier.type === "ImportDefaultSpecifier") {
          chunks.push(c(specifier.local.name, specifier));
          i += 1;
        } else if (specifier.type === "ImportNamespaceSpecifier") {
          chunks.push(c("* as " + specifier.local.name, specifier));
          i += 1;
        } else {
          break;
        }
      }
      if (i < length) {
        const specifiers = node2.specifiers.slice(i).map((specifier) => {
          const name3 = handle(specifier.imported, state)[0];
          const as2 = handle(specifier.local, state)[0];
          if (name3.content === as2.content) {
            return [as2];
          }
          return [name3, c(" as "), as2];
        });
        const width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length + 6 + get_length(source);
        if (width > 80) {
          chunks.push(c(`{
	`));
          push_array(chunks, join(specifiers, c(",\n	")));
          chunks.push(c("\n}"));
        } else {
          chunks.push(c(`{ `));
          push_array(chunks, join(specifiers, c(", ")));
          chunks.push(c(" }"));
        }
      }
      chunks.push(c(" from "));
    }
    push_array(chunks, source);
    chunks.push(c(";"));
    return chunks;
  },
  ImportExpression(node2, state) {
    return [c("import("), ...handle(node2.source, state), c(")")];
  },
  ExportDefaultDeclaration(node2, state) {
    const chunks = [c(`export default `), ...handle(node2.declaration, state)];
    if (node2.declaration.type !== "FunctionDeclaration") {
      chunks.push(c(";"));
    }
    return chunks;
  },
  ExportNamedDeclaration(node2, state) {
    const chunks = [c("export ")];
    if (node2.declaration) {
      push_array(chunks, handle(node2.declaration, state));
    } else {
      const specifiers = node2.specifiers.map(
        (specifier) => {
          const name3 = handle(specifier.local, state)[0];
          const as2 = handle(specifier.exported, state)[0];
          if (name3.content === as2.content) {
            return [name3];
          }
          return [name3, c(" as "), as2];
        }
      );
      const width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;
      if (width > 80) {
        chunks.push(c("{\n	"));
        push_array(chunks, join(specifiers, c(",\n	")));
        chunks.push(c("\n}"));
      } else {
        chunks.push(c("{ "));
        push_array(chunks, join(specifiers, c(", ")));
        chunks.push(c(" }"));
      }
      if (node2.source) {
        chunks.push(c(" from "));
        push_array(chunks, handle(node2.source, state));
      }
    }
    chunks.push(c(";"));
    return chunks;
  },
  ExportAllDeclaration(node2, state) {
    return [c(`export * from `), ...handle(node2.source, state), c(`;`)];
  },
  MethodDefinition(node2, state) {
    const chunks = [];
    if (node2.static) {
      chunks.push(c("static "));
    }
    if (node2.kind === "get" || node2.kind === "set") {
      chunks.push(c(node2.kind + " "));
    }
    if (node2.value.async) {
      chunks.push(c("async "));
    }
    if (node2.value.generator) {
      chunks.push(c("*"));
    }
    if (node2.computed) {
      chunks.push(c("["));
      push_array(chunks, handle(node2.key, state));
      chunks.push(c("]"));
    } else {
      push_array(chunks, handle(node2.key, state));
    }
    chunks.push(c("("));
    const { params } = node2.value;
    for (let i = 0; i < params.length; i += 1) {
      push_array(chunks, handle(params[i], state));
      if (i < params.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(") "));
    push_array(chunks, handle(node2.value.body, state));
    return chunks;
  },
  ArrowFunctionExpression: scoped(
    (node2, state) => {
      const chunks = [];
      if (node2.async)
        chunks.push(c("async "));
      if (node2.params.length === 1 && node2.params[0].type === "Identifier") {
        push_array(chunks, handle(node2.params[0], state));
      } else {
        const params = node2.params.map(
          (param) => handle(param, {
            ...state,
            indent: state.indent + "	"
          })
        );
        chunks.push(c("("));
        push_array(chunks, join(params, c(", ")));
        chunks.push(c(")"));
      }
      chunks.push(c(" => "));
      if (node2.body.type === "ObjectExpression" || node2.body.type === "AssignmentExpression" && node2.body.left.type === "ObjectPattern") {
        chunks.push(c("("));
        push_array(chunks, handle(node2.body, state));
        chunks.push(c(")"));
      } else {
        push_array(chunks, handle(node2.body, state));
      }
      return chunks;
    }
  ),
  ThisExpression(node2, state) {
    return [c("this", node2)];
  },
  Super(node2, state) {
    return [c("super", node2)];
  },
  RestElement(node2, state) {
    return [c("..."), ...handle(node2.argument, state)];
  },
  YieldExpression(node2, state) {
    if (node2.argument) {
      return [
        c(node2.delegate ? `yield* ` : `yield `),
        ...handle(node2.argument, state)
      ];
    }
    return [c(node2.delegate ? `yield*` : `yield`)];
  },
  AwaitExpression(node2, state) {
    if (node2.argument) {
      const precedence = EXPRESSIONS_PRECEDENCE[node2.argument.type];
      if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
        return [c("await ("), ...handle(node2.argument, state), c(")")];
      } else {
        return [c("await "), ...handle(node2.argument, state)];
      }
    }
    return [c("await")];
  },
  TemplateLiteral(node2, state) {
    const chunks = [c("`")];
    const { quasis, expressions: expressions2 } = node2;
    for (let i = 0; i < expressions2.length; i++) {
      chunks.push(c(quasis[i].value.raw), c("${"));
      push_array(chunks, handle(expressions2[i], state));
      chunks.push(c("}"));
    }
    chunks.push(c(quasis[quasis.length - 1].value.raw), c("`"));
    return chunks;
  },
  TaggedTemplateExpression(node2, state) {
    return handle(node2.tag, state).concat(handle(node2.quasi, state));
  },
  ArrayExpression(node2, state) {
    const chunks = [c("[")];
    const elements = [];
    let sparse_commas = [];
    for (let i = 0; i < node2.elements.length; i += 1) {
      const element2 = node2.elements[i];
      if (element2) {
        elements.push([
          ...sparse_commas,
          ...handle(element2, {
            ...state,
            indent: state.indent + "	"
          })
        ]);
        sparse_commas = [];
      } else {
        sparse_commas.push(c(","));
      }
    }
    const multiple_lines = elements.some(has_newline) || elements.map(get_length).reduce(sum, 0) + (state.indent.length + elements.length - 1) * 2 > 80;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}	`));
      push_array(chunks, join(elements, c(`,
${state.indent}	`)));
      chunks.push(c(`
${state.indent}`));
      push_array(chunks, sparse_commas);
    } else {
      push_array(chunks, join(elements, c(", ")));
      push_array(chunks, sparse_commas);
    }
    chunks.push(c("]"));
    return chunks;
  },
  ObjectExpression(node2, state) {
    if (node2.properties.length === 0) {
      return [c("{}")];
    }
    let has_inline_comment = false;
    const chunks = [];
    const separator = c(", ");
    node2.properties.forEach((p2, i) => {
      push_array(
        chunks,
        handle(p2, {
          ...state,
          indent: state.indent + "	"
        })
      );
      if (state.comments.length) {
        chunks.push(c(", "));
        while (state.comments.length) {
          const comment2 = state.comments.shift();
          chunks.push(
            c(
              comment2.type === "Block" ? `/*${comment2.value}*/
${state.indent}	` : `//${comment2.value}
${state.indent}	`
            )
          );
          if (comment2.type === "Line") {
            has_inline_comment = true;
          }
        }
      } else {
        if (i < node2.properties.length - 1) {
          chunks.push(separator);
        }
      }
    });
    const multiple_lines = has_inline_comment || has_newline(chunks) || get_length(chunks) > 40;
    if (multiple_lines) {
      separator.content = `,
${state.indent}	`;
    }
    return [
      c(multiple_lines ? `{
${state.indent}	` : `{ `),
      ...chunks,
      c(multiple_lines ? `
${state.indent}}` : ` }`)
    ];
  },
  Property(node2, state) {
    const value = handle(node2.value, state);
    if (node2.key === node2.value) {
      return value;
    }
    if (!node2.computed && node2.value.type === "AssignmentPattern" && node2.value.left.type === "Identifier" && node2.value.left.name === node2.key.name) {
      return value;
    }
    if (!node2.computed && node2.value.type === "Identifier" && (node2.key.type === "Identifier" && node2.key.name === value[0].content || node2.key.type === "Literal" && node2.key.value === value[0].content)) {
      return value;
    }
    const key = handle(node2.key, state);
    if (node2.value.type === "FunctionExpression" && !node2.value.id) {
      state = {
        ...state,
        scope: state.scope_map.get(node2.value)
      };
      const chunks = node2.kind !== "init" ? [c(`${node2.kind} `)] : [];
      if (node2.value.async) {
        chunks.push(c("async "));
      }
      if (node2.value.generator) {
        chunks.push(c("*"));
      }
      push_array(chunks, node2.computed ? [c("["), ...key, c("]")] : key);
      chunks.push(c("("));
      push_array(
        chunks,
        join(
          node2.value.params.map(
            (param) => handle(param, state)
          ),
          c(", ")
        )
      );
      chunks.push(c(") "));
      push_array(chunks, handle(node2.value.body, state));
      return chunks;
    }
    if (node2.computed) {
      return [c("["), ...key, c("]: "), ...value];
    }
    return [...key, c(": "), ...value];
  },
  ObjectPattern(node2, state) {
    const chunks = [c("{ ")];
    for (let i = 0; i < node2.properties.length; i += 1) {
      push_array(chunks, handle(node2.properties[i], state));
      if (i < node2.properties.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(" }"));
    return chunks;
  },
  SequenceExpression(node2, state) {
    const expressions2 = node2.expressions.map((e) => handle(e, state));
    return [c("("), ...join(expressions2, c(", ")), c(")")];
  },
  UnaryExpression(node2, state) {
    const chunks = [c(node2.operator)];
    if (node2.operator.length > 1) {
      chunks.push(c(" "));
    }
    if (EXPRESSIONS_PRECEDENCE[node2.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.argument, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.argument, state));
    }
    return chunks;
  },
  UpdateExpression(node2, state) {
    return node2.prefix ? [c(node2.operator), ...handle(node2.argument, state)] : [...handle(node2.argument, state), c(node2.operator)];
  },
  AssignmentExpression(node2, state) {
    return [
      ...handle(node2.left, state),
      c(` ${node2.operator || "="} `),
      ...handle(node2.right, state)
    ];
  },
  BinaryExpression(node2, state) {
    const chunks = [];
    if (needs_parens(node2.left, node2, false)) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.left, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.left, state));
    }
    chunks.push(c(` ${node2.operator} `));
    if (needs_parens(node2.right, node2, true)) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.right, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.right, state));
    }
    return chunks;
  },
  ConditionalExpression(node2, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node2.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
      push_array(chunks, handle(node2.test, state));
    } else {
      chunks.push(c("("));
      push_array(chunks, handle(node2.test, state));
      chunks.push(c(")"));
    }
    const child_state = { ...state, indent: state.indent + "	" };
    const consequent = handle(node2.consequent, child_state);
    const alternate = handle(node2.alternate, child_state);
    const multiple_lines = has_newline(consequent) || has_newline(alternate) || get_length(chunks) + get_length(consequent) + get_length(alternate) > 50;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}? `));
      push_array(chunks, consequent);
      chunks.push(c(`
${state.indent}: `));
      push_array(chunks, alternate);
    } else {
      chunks.push(c(` ? `));
      push_array(chunks, consequent);
      chunks.push(c(` : `));
      push_array(chunks, alternate);
    }
    return chunks;
  },
  NewExpression(node2, state) {
    const chunks = [c("new ")];
    if (EXPRESSIONS_PRECEDENCE[node2.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node2.callee)) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.callee, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.callee, state));
    }
    const args = node2.arguments.map(
      (arg) => handle(arg, {
        ...state,
        indent: state.indent + "	"
      })
    );
    const separator = args.some(has_newline) ? c(",\n" + state.indent) : c(", ");
    chunks.push(c("("));
    push_array(chunks, join(args, separator));
    chunks.push(c(")"));
    return chunks;
  },
  ChainExpression(node2, state) {
    return handle(node2.expression, state);
  },
  CallExpression(node2, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node2.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.callee, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.callee, state));
    }
    if (
      /** @type {SimpleCallExpression} */
      node2.optional
    ) {
      chunks.push(c("?."));
    }
    const args = node2.arguments.map((arg) => handle(arg, state));
    const multiple_lines = args.slice(0, -1).some(has_newline);
    if (multiple_lines) {
      const args2 = node2.arguments.map(
        (arg) => handle(arg, {
          ...state,
          indent: `${state.indent}	`
        })
      );
      chunks.push(c(`(
${state.indent}	`));
      push_array(chunks, join(args2, c(`,
${state.indent}	`)));
      chunks.push(c(`
${state.indent})`));
    } else {
      chunks.push(c("("));
      push_array(chunks, join(args, c(", ")));
      chunks.push(c(")"));
    }
    return chunks;
  },
  MemberExpression(node2, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node2.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.object, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.object, state));
    }
    if (node2.computed) {
      if (node2.optional) {
        chunks.push(c("?."));
      }
      chunks.push(c("["));
      push_array(chunks, handle(node2.property, state));
      chunks.push(c("]"));
    } else {
      chunks.push(c(node2.optional ? "?." : "."));
      push_array(chunks, handle(node2.property, state));
    }
    return chunks;
  },
  MetaProperty(node2, state) {
    return [
      ...handle(node2.meta, state),
      c("."),
      ...handle(node2.property, state)
    ];
  },
  Identifier(node2, state) {
    let name3 = node2.name;
    if (name3[0] === "@") {
      name3 = state.getName(name3.slice(1));
    } else if (node2.name[0] === "#") {
      const owner = state.scope.find_owner(node2.name);
      if (!owner) {
        throw new Error(`Could not find owner for node`);
      }
      if (!state.deconflicted.has(owner)) {
        state.deconflicted.set(owner, /* @__PURE__ */ new Map());
      }
      const deconflict_map = state.deconflicted.get(owner);
      if (!deconflict_map.has(node2.name)) {
        deconflict_map.set(
          node2.name,
          deconflict(node2.name.slice(1), owner.references)
        );
      }
      name3 = deconflict_map.get(node2.name);
    }
    return [c(name3, node2)];
  },
  Literal(node2, state) {
    if (typeof node2.value === "string") {
      return [
        // TODO do we need to handle weird unicode characters somehow?
        // str.replace(/\\u(\d{4})/g, (m, n) => String.fromCharCode(+n))
        c(
          (node2.raw || JSON.stringify(node2.value)).replace(
            re,
            (_m, _i2, at3, hash, name3) => {
              if (at3)
                return "@" + name3;
              if (hash)
                return "#" + name3;
              throw new Error(`this shouldn't happen`);
            }
          ),
          node2
        )
      ];
    }
    return [c(node2.raw || String(node2.value), node2)];
  },
  PropertyDefinition(node2, state) {
    const chunks = [];
    if (node2.static) {
      chunks.push(c("static "));
    }
    if (node2.computed) {
      chunks.push(c("["), ...handle(node2.key, state), c("]"));
    } else {
      chunks.push(...handle(node2.key, state));
    }
    if (node2.value) {
      chunks.push(c(" = "));
      chunks.push(...handle(node2.value, state));
    }
    chunks.push(c(";"));
    return chunks;
  },
  StaticBlock(node2, state) {
    const chunks = [c("static ")];
    push_array(chunks, handlers.BlockStatement(node2, state));
    return chunks;
  },
  PrivateIdentifier(node2, state) {
    const chunks = [c("#")];
    push_array(chunks, [c(node2.name, node2)]);
    return chunks;
  }
};
handlers.ForOfStatement = handlers.ForInStatement;
handlers.FunctionExpression = handlers.FunctionDeclaration;
handlers.ClassExpression = handlers.ClassDeclaration;
handlers.ClassBody = handlers.BlockStatement;
handlers.SpreadElement = handlers.RestElement;
handlers.ArrayPattern = handlers.ArrayExpression;
handlers.LogicalExpression = handlers.BinaryExpression;
handlers.AssignmentPattern = handlers.AssignmentExpression;
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c2 = chars.charCodeAt(i);
  intToChar[i] = c2;
  charToInt[c2] = i;
}
var td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
var btoa$1 = () => {
  throw new Error(
    "Unsupported environment: `window.btoa` or `Buffer` should be supported."
  );
};
if (typeof window !== "undefined" && typeof window.btoa === "function") {
  btoa$1 = (str2) => window.btoa(unescape(encodeURIComponent(str2)));
} else if (typeof Buffer === "function") {
  btoa$1 = (str2) => Buffer.from(str2, "utf-8").toString("base64");
}
var sigils = {
  "@": "AT",
  "#": "HASH"
};
var join$1 = (strings) => {
  let str2 = strings[0];
  for (let i = 1; i < strings.length; i += 1) {
    str2 += `_${id}_${i - 1}_${strings[i]}`;
  }
  return str2.replace(
    /([@#])(\w+)/g,
    (_m, sigil, name3) => `_${id}_${sigils[sigil]}_${name3}`
  );
};
var flatten_body = (array, target2) => {
  for (let i = 0; i < array.length; i += 1) {
    const statement = array[i];
    if (Array.isArray(statement)) {
      flatten_body(statement, target2);
      continue;
    }
    if (statement.type === "ExpressionStatement") {
      if (statement.expression === EMPTY)
        continue;
      if (Array.isArray(statement.expression)) {
        let node2 = statement.expression[0];
        while (Array.isArray(node2))
          node2 = node2[0];
        if (node2)
          node2.leadingComments = statement.leadingComments;
        flatten_body(statement.expression, target2);
        continue;
      }
      if (/(Expression|Literal)$/.test(statement.expression.type)) {
        target2.push(statement);
        continue;
      }
      if (statement.leadingComments)
        statement.expression.leadingComments = statement.leadingComments;
      if (statement.trailingComments)
        statement.expression.trailingComments = statement.trailingComments;
      target2.push(statement.expression);
      continue;
    }
    target2.push(statement);
  }
  return target2;
};
var flatten_properties = (array, target2) => {
  for (let i = 0; i < array.length; i += 1) {
    const property = array[i];
    if (property.value === EMPTY)
      continue;
    if (property.key === property.value && Array.isArray(property.key)) {
      flatten_properties(property.key, target2);
      continue;
    }
    target2.push(property);
  }
  return target2;
};
var flatten$1 = (nodes, target2) => {
  for (let i = 0; i < nodes.length; i += 1) {
    const node2 = nodes[i];
    if (node2 === EMPTY)
      continue;
    if (Array.isArray(node2)) {
      flatten$1(node2, target2);
      continue;
    }
    target2.push(node2);
  }
  return target2;
};
var EMPTY = { type: "Empty" };
var acorn_opts = (comments, raw2) => {
  const { onComment } = get_comment_handlers(comments, raw2);
  return {
    ecmaVersion: 2022,
    sourceType: "module",
    allowAwaitOutsideFunction: true,
    allowImportExportEverywhere: true,
    allowReturnOutsideFunction: true,
    onComment
  };
};
var inject = (raw2, node2, values2, comments) => {
  comments.forEach((comment2) => {
    comment2.value = comment2.value.replace(
      re,
      (m, i) => +i in values2 ? values2[+i] : m
    );
  });
  const { enter, leave } = get_comment_handlers(comments, raw2);
  return walk(node2, {
    enter,
    /** @param {any} node */
    leave(node3) {
      if (node3.type === "Identifier") {
        re.lastIndex = 0;
        const match = re.exec(node3.name);
        if (match) {
          if (match[1]) {
            if (+match[1] in values2) {
              let value = values2[+match[1]];
              if (typeof value === "string") {
                value = {
                  type: "Identifier",
                  name: value,
                  leadingComments: node3.leadingComments,
                  trailingComments: node3.trailingComments
                };
              } else if (typeof value === "number") {
                value = {
                  type: "Literal",
                  value,
                  leadingComments: node3.leadingComments,
                  trailingComments: node3.trailingComments
                };
              }
              this.replace(value || EMPTY);
            }
          } else {
            node3.name = `${match[2] ? `@` : `#`}${match[4]}`;
          }
        }
      }
      if (node3.type === "Literal") {
        if (typeof node3.value === "string") {
          re.lastIndex = 0;
          const new_value = (
            /** @type {string} */
            node3.value.replace(
              re,
              (m, i) => +i in values2 ? values2[+i] : m
            )
          );
          const has_changed = new_value !== node3.value;
          node3.value = new_value;
          if (has_changed && node3.raw) {
            node3.raw = `${node3.raw[0]}${JSON.stringify(node3.value).slice(
              1,
              -1
            )}${node3.raw[node3.raw.length - 1]}`;
          }
        }
      }
      if (node3.type === "TemplateElement") {
        re.lastIndex = 0;
        node3.value.raw = /** @type {string} */
        node3.value.raw.replace(
          re,
          (m, i) => +i in values2 ? values2[+i] : m
        );
      }
      if (node3.type === "Program" || node3.type === "BlockStatement") {
        node3.body = flatten_body(node3.body, []);
      }
      if (node3.type === "ObjectExpression" || node3.type === "ObjectPattern") {
        node3.properties = flatten_properties(node3.properties, []);
      }
      if (node3.type === "ArrayExpression" || node3.type === "ArrayPattern") {
        node3.elements = flatten$1(node3.elements, []);
      }
      if (node3.type === "FunctionExpression" || node3.type === "FunctionDeclaration" || node3.type === "ArrowFunctionExpression") {
        node3.params = flatten$1(node3.params, []);
      }
      if (node3.type === "CallExpression" || node3.type === "NewExpression") {
        node3.arguments = flatten$1(node3.arguments, []);
      }
      if (node3.type === "ImportDeclaration" || node3.type === "ExportNamedDeclaration") {
        node3.specifiers = flatten$1(node3.specifiers, []);
      }
      if (node3.type === "ForStatement") {
        node3.init = node3.init === EMPTY ? null : node3.init;
        node3.test = node3.test === EMPTY ? null : node3.test;
        node3.update = node3.update === EMPTY ? null : node3.update;
      }
      leave(node3);
    }
  });
};
function x(strings, ...values2) {
  const str2 = join$1(strings);
  const comments = [];
  try {
    let expression = (
      /** @type {Expression & { start: Number, end: number }} */
      parseExpressionAt2(str2, 0, acorn_opts(comments, str2))
    );
    const match = /\S+/.exec(str2.slice(expression.end));
    if (match) {
      throw new Error(`Unexpected token '${match[0]}'`);
    }
    expression = /** @type {Expression & { start: Number, end: number }} */
    inject(str2, expression, values2, comments);
    return expression;
  } catch (err) {
    handle_error(str2, err);
  }
}
function handle_error(str2, err) {
  re.lastIndex = 0;
  str2 = str2.replace(re, (m, i, at3, hash, name3) => {
    if (at3)
      return `@${name3}`;
    if (hash)
      return `#${name3}`;
    return "${...}";
  });
  console.log(`failed to parse:
${str2}`);
  throw err;
}
var parse$1 = (source, opts) => {
  const comments = [];
  const { onComment, enter, leave } = get_comment_handlers(comments, source);
  const ast2 = (
    /** @type {any} */
    parse3(source, { onComment, ...opts })
  );
  walk(ast2, { enter, leave });
  return ast2;
};
var parseExpressionAt$1 = (source, index2, opts) => {
  const comments = [];
  const { onComment, enter, leave } = get_comment_handlers(comments, source);
  const ast2 = (
    /** @type {any} */
    parseExpressionAt2(source, index2, { onComment, ...opts })
  );
  walk(ast2, { enter, leave });
  return ast2;
};
var parse$2 = (source) => parse$1(source, {
  sourceType: "module",
  ecmaVersion: 13,
  locations: true
});
var parse_expression_at = (source, index2) => parseExpressionAt$1(source, index2, {
  sourceType: "module",
  ecmaVersion: 13,
  locations: true
});
function read_expression(parser2) {
  try {
    const node2 = parse_expression_at(parser2.template, parser2.index);
    let num_parens = 0;
    for (let i = parser2.index; i < node2.start; i += 1) {
      if (parser2.template[i] === "(")
        num_parens += 1;
    }
    let index2 = node2.end;
    while (num_parens > 0) {
      const char = parser2.template[index2];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        parser2.error(parser_errors.unexpected_token(")"), index2);
      }
      index2 += 1;
    }
    parser2.index = index2;
    return node2;
  } catch (err) {
    parser2.acorn_error(err);
  }
}
var regex_closing_script_tag = /<\/script\s*>/;
var regex_starts_with_closing_script_tag = /^<\/script\s*>/;
function get_context(parser2, attributes2, start2) {
  const context2 = attributes2.find((attribute2) => attribute2.name === "context");
  if (!context2)
    return "default";
  if (context2.value.length !== 1 || context2.value[0].type !== "Text") {
    parser2.error(parser_errors.invalid_script_context_attribute, start2);
  }
  const value = context2.value[0].data;
  if (value !== "module") {
    parser2.error(parser_errors.invalid_script_context_value, context2.start);
  }
  return value;
}
function read_script(parser2, start2, attributes2) {
  const script_start = parser2.index;
  const data3 = parser2.read_until(regex_closing_script_tag, parser_errors.unclosed_script);
  if (parser2.index >= parser2.template.length) {
    parser2.error(parser_errors.unclosed_script);
  }
  const source = parser2.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data3;
  parser2.read(regex_starts_with_closing_script_tag);
  let ast2;
  try {
    ast2 = parse$2(source);
  } catch (err) {
    parser2.acorn_error(err);
  }
  ast2.start = script_start;
  return {
    type: "Script",
    start: start2,
    end: parser2.index,
    context: get_context(parser2, attributes2, start2),
    content: ast2
  };
}
var rs = Object.create;
var tr = Object.defineProperty;
var ns = Object.getOwnPropertyDescriptor;
var os = Object.getOwnPropertyNames;
var is = Object.getPrototypeOf;
var as = Object.prototype.hasOwnProperty;
var Oe = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var b$1 = (e, t) => {
  for (var r in t)
    tr(e, r, { get: t[r], enumerable: true });
};
var ss = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of os(t))
      !as.call(e, o) && o !== r && tr(e, o, { get: () => t[o], enumerable: !(n = ns(t, o)) || n.enumerable });
  return e;
};
var ls = (e, t, r) => (r = e != null ? rs(is(e)) : {}, ss(t || !e || !e.__esModule ? tr(r, "default", { value: e, enumerable: true }) : r, e));
var Jo = Oe((ur) => {
  var Zo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  ur.encode = function(e) {
    if (0 <= e && e < Zo.length)
      return Zo[e];
    throw new TypeError("Must be between 0 and 63: " + e);
  };
  ur.decode = function(e) {
    var t = 65, r = 90, n = 97, o = 122, i = 48, s = 57, u2 = 43, c2 = 47, a = 26, l2 = 52;
    return t <= e && e <= r ? e - t : n <= e && e <= o ? e - n + a : i <= e && e <= s ? e - i + l2 : e == u2 ? 62 : e == c2 ? 63 : -1;
  };
});
var oi = Oe((hr) => {
  var ei = Jo(), pr2 = 5, ti = 1 << pr2, ri = ti - 1, ni2 = ti;
  function ks(e) {
    return e < 0 ? (-e << 1) + 1 : (e << 1) + 0;
  }
  function ws2(e) {
    var t = (e & 1) === 1, r = e >> 1;
    return t ? -r : r;
  }
  hr.encode = function(t) {
    var r = "", n, o = ks(t);
    do
      n = o & ri, o >>>= pr2, o > 0 && (n |= ni2), r += ei.encode(n);
    while (o > 0);
    return r;
  };
  hr.decode = function(t, r, n) {
    var o = t.length, i = 0, s = 0, u2, c2;
    do {
      if (r >= o)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (c2 = ei.decode(t.charCodeAt(r++)), c2 === -1)
        throw new Error("Invalid base64 digit: " + t.charAt(r - 1));
      u2 = !!(c2 & ni2), c2 &= ri, i = i + (c2 << s), s += pr2;
    } while (u2);
    n.value = ws2(i), n.rest = r;
  };
});
var Et = Oe((K) => {
  function vs(e, t, r) {
    if (t in e)
      return e[t];
    if (arguments.length === 3)
      return r;
    throw new Error('"' + t + '" is a required argument.');
  }
  K.getArg = vs;
  var ii2 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, Ss = /^data:.+\,.+$/;
  function nt(e) {
    var t = e.match(ii2);
    return t ? { scheme: t[1], auth: t[2], host: t[3], port: t[4], path: t[5] } : null;
  }
  K.urlParse = nt;
  function qe(e) {
    var t = "";
    return e.scheme && (t += e.scheme + ":"), t += "//", e.auth && (t += e.auth + "@"), e.host && (t += e.host), e.port && (t += ":" + e.port), e.path && (t += e.path), t;
  }
  K.urlGenerate = qe;
  var Cs = 32;
  function As(e) {
    var t = [];
    return function(r) {
      for (var n = 0; n < t.length; n++)
        if (t[n].input === r) {
          var o = t[0];
          return t[0] = t[n], t[n] = o, t[0].result;
        }
      var i = e(r);
      return t.unshift({ input: r, result: i }), t.length > Cs && t.pop(), i;
    };
  }
  var mr = As(function(t) {
    var r = t, n = nt(t);
    if (n) {
      if (!n.path)
        return t;
      r = n.path;
    }
    for (var o = K.isAbsolute(r), i = [], s = 0, u2 = 0; ; )
      if (s = u2, u2 = r.indexOf("/", s), u2 === -1) {
        i.push(r.slice(s));
        break;
      } else
        for (i.push(r.slice(s, u2)); u2 < r.length && r[u2] === "/"; )
          u2++;
    for (var c2, a = 0, u2 = i.length - 1; u2 >= 0; u2--)
      c2 = i[u2], c2 === "." ? i.splice(u2, 1) : c2 === ".." ? a++ : a > 0 && (c2 === "" ? (i.splice(u2 + 1, a), a = 0) : (i.splice(u2, 2), a--));
    return r = i.join("/"), r === "" && (r = o ? "/" : "."), n ? (n.path = r, qe(n)) : r;
  });
  K.normalize = mr;
  function ai(e, t) {
    e === "" && (e = "."), t === "" && (t = ".");
    var r = nt(t), n = nt(e);
    if (n && (e = n.path || "/"), r && !r.scheme)
      return n && (r.scheme = n.scheme), qe(r);
    if (r || t.match(Ss))
      return t;
    if (n && !n.host && !n.path)
      return n.host = t, qe(n);
    var o = t.charAt(0) === "/" ? t : mr(e.replace(/\/+$/, "") + "/" + t);
    return n ? (n.path = o, qe(n)) : o;
  }
  K.join = ai;
  K.isAbsolute = function(e) {
    return e.charAt(0) === "/" || ii2.test(e);
  };
  function Ts(e, t) {
    e === "" && (e = "."), e = e.replace(/\/$/, "");
    for (var r = 0; t.indexOf(e + "/") !== 0; ) {
      var n = e.lastIndexOf("/");
      if (n < 0 || (e = e.slice(0, n), e.match(/^([^\/]+:\/)?\/*$/)))
        return t;
      ++r;
    }
    return Array(r + 1).join("../") + t.substr(e.length + 1);
  }
  K.relative = Ts;
  var si = function() {
    var e = /* @__PURE__ */ Object.create(null);
    return !("__proto__" in e);
  }();
  function li2(e) {
    return e;
  }
  function Es(e) {
    return ci(e) ? "$" + e : e;
  }
  K.toSetString = si ? li2 : Es;
  function Ls(e) {
    return ci(e) ? e.slice(1) : e;
  }
  K.fromSetString = si ? li2 : Ls;
  function ci(e) {
    if (!e)
      return false;
    var t = e.length;
    if (t < 9 || e.charCodeAt(t - 1) !== 95 || e.charCodeAt(t - 2) !== 95 || e.charCodeAt(t - 3) !== 111 || e.charCodeAt(t - 4) !== 116 || e.charCodeAt(t - 5) !== 111 || e.charCodeAt(t - 6) !== 114 || e.charCodeAt(t - 7) !== 112 || e.charCodeAt(t - 8) !== 95 || e.charCodeAt(t - 9) !== 95)
      return false;
    for (var r = t - 10; r >= 0; r--)
      if (e.charCodeAt(r) !== 36)
        return false;
    return true;
  }
  function Ps(e, t, r) {
    var n = be(e.source, t.source);
    return n !== 0 || (n = e.originalLine - t.originalLine, n !== 0) || (n = e.originalColumn - t.originalColumn, n !== 0 || r) || (n = e.generatedColumn - t.generatedColumn, n !== 0) || (n = e.generatedLine - t.generatedLine, n !== 0) ? n : be(e.name, t.name);
  }
  K.compareByOriginalPositions = Ps;
  function Is(e, t, r) {
    var n;
    return n = e.originalLine - t.originalLine, n !== 0 || (n = e.originalColumn - t.originalColumn, n !== 0 || r) || (n = e.generatedColumn - t.generatedColumn, n !== 0) || (n = e.generatedLine - t.generatedLine, n !== 0) ? n : be(e.name, t.name);
  }
  K.compareByOriginalPositionsNoSource = Is;
  function Ds(e, t, r) {
    var n = e.generatedLine - t.generatedLine;
    return n !== 0 || (n = e.generatedColumn - t.generatedColumn, n !== 0 || r) || (n = be(e.source, t.source), n !== 0) || (n = e.originalLine - t.originalLine, n !== 0) || (n = e.originalColumn - t.originalColumn, n !== 0) ? n : be(e.name, t.name);
  }
  K.compareByGeneratedPositionsDeflated = Ds;
  function Os(e, t, r) {
    var n = e.generatedColumn - t.generatedColumn;
    return n !== 0 || r || (n = be(e.source, t.source), n !== 0) || (n = e.originalLine - t.originalLine, n !== 0) || (n = e.originalColumn - t.originalColumn, n !== 0) ? n : be(e.name, t.name);
  }
  K.compareByGeneratedPositionsDeflatedNoLine = Os;
  function be(e, t) {
    return e === t ? 0 : e === null ? 1 : t === null ? -1 : e > t ? 1 : -1;
  }
  function Ns(e, t) {
    var r = e.generatedLine - t.generatedLine;
    return r !== 0 || (r = e.generatedColumn - t.generatedColumn, r !== 0) || (r = be(e.source, t.source), r !== 0) || (r = e.originalLine - t.originalLine, r !== 0) || (r = e.originalColumn - t.originalColumn, r !== 0) ? r : be(e.name, t.name);
  }
  K.compareByGeneratedPositionsInflated = Ns;
  function zs(e) {
    return JSON.parse(e.replace(/^\)]}'[^\n]*\n/, ""));
  }
  K.parseSourceMapInput = zs;
  function Ms(e, t, r) {
    if (t = t || "", e && (e[e.length - 1] !== "/" && t[0] !== "/" && (e += "/"), t = e + t), r) {
      var n = nt(r);
      if (!n)
        throw new Error("sourceMapURL could not be parsed");
      if (n.path) {
        var o = n.path.lastIndexOf("/");
        o >= 0 && (n.path = n.path.substring(0, o + 1));
      }
      t = ai(qe(n), t);
    }
    return mr(t);
  }
  K.computeSourceURL = Ms;
});
var pi = Oe((ui) => {
  var fr = Et(), dr = Object.prototype.hasOwnProperty, Le = typeof Map < "u";
  function xe() {
    this._array = [], this._set = Le ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  xe.fromArray = function(t, r) {
    for (var n = new xe(), o = 0, i = t.length; o < i; o++)
      n.add(t[o], r);
    return n;
  };
  xe.prototype.size = function() {
    return Le ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  xe.prototype.add = function(t, r) {
    var n = Le ? t : fr.toSetString(t), o = Le ? this.has(t) : dr.call(this._set, n), i = this._array.length;
    (!o || r) && this._array.push(t), o || (Le ? this._set.set(t, i) : this._set[n] = i);
  };
  xe.prototype.has = function(t) {
    if (Le)
      return this._set.has(t);
    var r = fr.toSetString(t);
    return dr.call(this._set, r);
  };
  xe.prototype.indexOf = function(t) {
    if (Le) {
      var r = this._set.get(t);
      if (r >= 0)
        return r;
    } else {
      var n = fr.toSetString(t);
      if (dr.call(this._set, n))
        return this._set[n];
    }
    throw new Error('"' + t + '" is not in the set.');
  };
  xe.prototype.at = function(t) {
    if (t >= 0 && t < this._array.length)
      return this._array[t];
    throw new Error("No element indexed by " + t);
  };
  xe.prototype.toArray = function() {
    return this._array.slice();
  };
  ui.ArraySet = xe;
});
var fi = Oe((mi) => {
  var hi = Et();
  function Rs(e, t) {
    var r = e.generatedLine, n = t.generatedLine, o = e.generatedColumn, i = t.generatedColumn;
    return n > r || n == r && i >= o || hi.compareByGeneratedPositionsInflated(e, t) <= 0;
  }
  function Lt2() {
    this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  Lt2.prototype.unsortedForEach = function(t, r) {
    this._array.forEach(t, r);
  };
  Lt2.prototype.add = function(t) {
    Rs(this._last, t) ? (this._last = t, this._array.push(t)) : (this._sorted = false, this._array.push(t));
  };
  Lt2.prototype.toArray = function() {
    return this._sorted || (this._array.sort(hi.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
  };
  mi.MappingList = Lt2;
});
var gi = Oe((di) => {
  var ot = oi(), j = Et(), Pt = pi().ArraySet, Fs = fi().MappingList;
  function oe(e) {
    e || (e = {}), this._file = j.getArg(e, "file", null), this._sourceRoot = j.getArg(e, "sourceRoot", null), this._skipValidation = j.getArg(e, "skipValidation", false), this._sources = new Pt(), this._names = new Pt(), this._mappings = new Fs(), this._sourcesContents = null;
  }
  oe.prototype._version = 3;
  oe.fromSourceMap = function(t) {
    var r = t.sourceRoot, n = new oe({ file: t.file, sourceRoot: r });
    return t.eachMapping(function(o) {
      var i = { generated: { line: o.generatedLine, column: o.generatedColumn } };
      o.source != null && (i.source = o.source, r != null && (i.source = j.relative(r, i.source)), i.original = { line: o.originalLine, column: o.originalColumn }, o.name != null && (i.name = o.name)), n.addMapping(i);
    }), t.sources.forEach(function(o) {
      var i = o;
      r !== null && (i = j.relative(r, o)), n._sources.has(i) || n._sources.add(i);
      var s = t.sourceContentFor(o);
      s != null && n.setSourceContent(o, s);
    }), n;
  };
  oe.prototype.addMapping = function(t) {
    var r = j.getArg(t, "generated"), n = j.getArg(t, "original", null), o = j.getArg(t, "source", null), i = j.getArg(t, "name", null);
    this._skipValidation || this._validateMapping(r, n, o, i), o != null && (o = String(o), this._sources.has(o) || this._sources.add(o)), i != null && (i = String(i), this._names.has(i) || this._names.add(i)), this._mappings.add({ generatedLine: r.line, generatedColumn: r.column, originalLine: n != null && n.line, originalColumn: n != null && n.column, source: o, name: i });
  };
  oe.prototype.setSourceContent = function(t, r) {
    var n = t;
    this._sourceRoot != null && (n = j.relative(this._sourceRoot, n)), r != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[j.toSetString(n)] = r) : this._sourcesContents && (delete this._sourcesContents[j.toSetString(n)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  };
  oe.prototype.applySourceMap = function(t, r, n) {
    var o = r;
    if (r == null) {
      if (t.file == null)
        throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      o = t.file;
    }
    var i = this._sourceRoot;
    i != null && (o = j.relative(i, o));
    var s = new Pt(), u2 = new Pt();
    this._mappings.unsortedForEach(function(c2) {
      if (c2.source === o && c2.originalLine != null) {
        var a = t.originalPositionFor({ line: c2.originalLine, column: c2.originalColumn });
        a.source != null && (c2.source = a.source, n != null && (c2.source = j.join(n, c2.source)), i != null && (c2.source = j.relative(i, c2.source)), c2.originalLine = a.line, c2.originalColumn = a.column, a.name != null && (c2.name = a.name));
      }
      var l2 = c2.source;
      l2 != null && !s.has(l2) && s.add(l2);
      var p2 = c2.name;
      p2 != null && !u2.has(p2) && u2.add(p2);
    }, this), this._sources = s, this._names = u2, t.sources.forEach(function(c2) {
      var a = t.sourceContentFor(c2);
      a != null && (n != null && (c2 = j.join(n, c2)), i != null && (c2 = j.relative(i, c2)), this.setSourceContent(c2, a));
    }, this);
  };
  oe.prototype._validateMapping = function(t, r, n, o) {
    if (r && typeof r.line != "number" && typeof r.column != "number")
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if (!(t && "line" in t && "column" in t && t.line > 0 && t.column >= 0 && !r && !n && !o)) {
      if (t && "line" in t && "column" in t && r && "line" in r && "column" in r && t.line > 0 && t.column >= 0 && r.line > 0 && r.column >= 0 && n)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({ generated: t, source: n, original: r, name: o }));
    }
  };
  oe.prototype._serializeMappings = function() {
    for (var t = 0, r = 1, n = 0, o = 0, i = 0, s = 0, u2 = "", c2, a, l2, p2, m = this._mappings.toArray(), f = 0, P = m.length; f < P; f++) {
      if (a = m[f], c2 = "", a.generatedLine !== r)
        for (t = 0; a.generatedLine !== r; )
          c2 += ";", r++;
      else if (f > 0) {
        if (!j.compareByGeneratedPositionsInflated(a, m[f - 1]))
          continue;
        c2 += ",";
      }
      c2 += ot.encode(a.generatedColumn - t), t = a.generatedColumn, a.source != null && (p2 = this._sources.indexOf(a.source), c2 += ot.encode(p2 - s), s = p2, c2 += ot.encode(a.originalLine - 1 - o), o = a.originalLine - 1, c2 += ot.encode(a.originalColumn - n), n = a.originalColumn, a.name != null && (l2 = this._names.indexOf(a.name), c2 += ot.encode(l2 - i), i = l2)), u2 += c2;
    }
    return u2;
  };
  oe.prototype._generateSourcesContent = function(t, r) {
    return t.map(function(n) {
      if (!this._sourcesContents)
        return null;
      r != null && (n = j.relative(r, n));
      var o = j.toSetString(n);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, o) ? this._sourcesContents[o] : null;
    }, this);
  };
  oe.prototype.toJSON = function() {
    var t = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
    return this._file != null && (t.file = this._file), this._sourceRoot != null && (t.sourceRoot = this._sourceRoot), this._sourcesContents && (t.sourcesContent = this._generateSourcesContent(t.sources, t.sourceRoot)), t;
  };
  oe.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  };
  di.SourceMapGenerator = oe;
});
var $e = {};
b$1($e, { AtKeyword: () => I, BadString: () => Ae, BadUrl: () => Y, CDC: () => U, CDO: () => ue, Colon: () => O, Comma: () => G, Comment: () => E, Delim: () => g, Dimension: () => y, EOF: () => Xe, Function: () => x$1, Hash: () => v, Ident: () => h, LeftCurlyBracket: () => M, LeftParenthesis: () => T, LeftSquareBracket: () => q, Number: () => d, Percentage: () => A, RightCurlyBracket: () => H, RightParenthesis: () => w, RightSquareBracket: () => V, Semicolon: () => _, String: () => W, Url: () => F, WhiteSpace: () => k });
var Xe = 0;
var h = 1;
var x$1 = 2;
var I = 3;
var v = 4;
var W = 5;
var Ae = 6;
var F = 7;
var Y = 8;
var g = 9;
var d = 10;
var A = 11;
var y = 12;
var k = 13;
var ue = 14;
var U = 15;
var O = 16;
var _ = 17;
var G = 18;
var q = 19;
var V = 20;
var T = 21;
var w = 22;
var M = 23;
var H = 24;
var E = 25;
function B(e) {
  return e >= 48 && e <= 57;
}
function ee(e) {
  return B(e) || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function yt(e) {
  return e >= 65 && e <= 90;
}
function cs(e) {
  return e >= 97 && e <= 122;
}
function us(e) {
  return yt(e) || cs(e);
}
function ps(e) {
  return e >= 128;
}
function xt(e) {
  return us(e) || ps(e) || e === 95;
}
function Ne(e) {
  return xt(e) || B(e) || e === 45;
}
function hs(e) {
  return e >= 0 && e <= 8 || e === 11 || e >= 14 && e <= 31 || e === 127;
}
function Ze(e) {
  return e === 10 || e === 13 || e === 12;
}
function pe(e) {
  return Ze(e) || e === 32 || e === 9;
}
function $(e, t) {
  return !(e !== 92 || Ze(t) || t === 0);
}
function ze(e, t, r) {
  return e === 45 ? xt(t) || t === 45 || $(t, r) : xt(e) ? true : e === 92 ? $(e, t) : false;
}
function kt(e, t, r) {
  return e === 43 || e === 45 ? B(t) ? 2 : t === 46 && B(r) ? 3 : 0 : e === 46 ? B(t) ? 2 : 0 : B(e) ? 1 : 0;
}
function wt(e) {
  return e === 65279 || e === 65534 ? 1 : 0;
}
var rr = new Array(128);
var ms = 128;
var Je = 130;
var nr = 131;
var vt = 132;
var or = 133;
for (let e = 0; e < rr.length; e++)
  rr[e] = pe(e) && Je || B(e) && nr || xt(e) && vt || hs(e) && or || e || ms;
function St(e) {
  return e < 128 ? rr[e] : vt;
}
function Me(e, t) {
  return t < e.length ? e.charCodeAt(t) : 0;
}
function Ct(e, t, r) {
  return r === 13 && Me(e, t + 1) === 10 ? 2 : 1;
}
function de(e, t, r) {
  let n = e.charCodeAt(t);
  return yt(n) && (n = n | 32), n === r;
}
function ge(e, t, r, n) {
  if (r - t !== n.length || t < 0 || r > e.length)
    return false;
  for (let o = t; o < r; o++) {
    let i = n.charCodeAt(o - t), s = e.charCodeAt(o);
    if (yt(s) && (s = s | 32), s !== i)
      return false;
  }
  return true;
}
function qo(e, t) {
  for (; t >= 0 && pe(e.charCodeAt(t)); t--)
    ;
  return t + 1;
}
function et(e, t) {
  for (; t < e.length && pe(e.charCodeAt(t)); t++)
    ;
  return t;
}
function ir(e, t) {
  for (; t < e.length && B(e.charCodeAt(t)); t++)
    ;
  return t;
}
function se(e, t) {
  if (t += 2, ee(Me(e, t - 1))) {
    for (let n = Math.min(e.length, t + 5); t < n && ee(Me(e, t)); t++)
      ;
    let r = Me(e, t);
    pe(r) && (t += Ct(e, t, r));
  }
  return t;
}
function tt(e, t) {
  for (; t < e.length; t++) {
    let r = e.charCodeAt(t);
    if (!Ne(r)) {
      if ($(r, Me(e, t + 1))) {
        t = se(e, t) - 1;
        continue;
      }
      break;
    }
  }
  return t;
}
function Te(e, t) {
  let r = e.charCodeAt(t);
  if ((r === 43 || r === 45) && (r = e.charCodeAt(t += 1)), B(r) && (t = ir(e, t + 1), r = e.charCodeAt(t)), r === 46 && B(e.charCodeAt(t + 1)) && (t += 2, t = ir(e, t)), de(e, t, 101)) {
    let n = 0;
    r = e.charCodeAt(t + 1), (r === 45 || r === 43) && (n = 1, r = e.charCodeAt(t + 2)), B(r) && (t = ir(e, t + 1 + n + 1));
  }
  return t;
}
function At(e, t) {
  for (; t < e.length; t++) {
    let r = e.charCodeAt(t);
    if (r === 41) {
      t++;
      break;
    }
    $(r, Me(e, t + 1)) && (t = se(e, t));
  }
  return t;
}
function Re(e) {
  if (e.length === 1 && !ee(e.charCodeAt(0)))
    return e[0];
  let t = parseInt(e, 16);
  return (t === 0 || t >= 55296 && t <= 57343 || t > 1114111) && (t = 65533), String.fromCodePoint(t);
}
var Fe = ["EOF-token", "ident-token", "function-token", "at-keyword-token", "hash-token", "string-token", "bad-string-token", "url-token", "bad-url-token", "delim-token", "number-token", "percentage-token", "dimension-token", "whitespace-token", "CDO-token", "CDC-token", "colon-token", "semicolon-token", "comma-token", "[-token", "]-token", "(-token", ")-token", "{-token", "}-token"];
function Be(e = null, t) {
  return e === null || e.length < t ? new Uint32Array(Math.max(t + 1024, 16384)) : e;
}
var Uo = 10;
var fs = 12;
var jo = 13;
function Wo(e) {
  let t = e.source, r = t.length, n = t.length > 0 ? wt(t.charCodeAt(0)) : 0, o = Be(e.lines, r), i = Be(e.columns, r), s = e.startLine, u2 = e.startColumn;
  for (let c2 = n; c2 < r; c2++) {
    let a = t.charCodeAt(c2);
    o[c2] = s, i[c2] = u2++, (a === Uo || a === jo || a === fs) && (a === jo && c2 + 1 < r && t.charCodeAt(c2 + 1) === Uo && (c2++, o[c2] = s, i[c2] = u2), s++, u2 = 1);
  }
  o[r] = s, i[r] = u2, e.lines = o, e.columns = i, e.computed = true;
}
var Tt = class {
  constructor() {
    this.lines = null, this.columns = null, this.computed = false;
  }
  setSource(t, r = 0, n = 1, o = 1) {
    this.source = t, this.startOffset = r, this.startLine = n, this.startColumn = o, this.computed = false;
  }
  getLocation(t, r) {
    return this.computed || Wo(this), { source: r, offset: this.startOffset + t, line: this.lines[t], column: this.columns[t] };
  }
  getLocationRange(t, r, n) {
    return this.computed || Wo(this), { source: n, start: { offset: this.startOffset + t, line: this.lines[t], column: this.columns[t] }, end: { offset: this.startOffset + r, line: this.lines[r], column: this.columns[r] } };
  }
};
var ne = 16777215;
var we = 24;
var ds = /* @__PURE__ */ new Map([[2, 22], [21, 22], [19, 20], [23, 24]]);
var rt = class {
  constructor(t, r) {
    this.setSource(t, r);
  }
  reset() {
    this.eof = false, this.tokenIndex = -1, this.tokenType = 0, this.tokenStart = this.firstCharOffset, this.tokenEnd = this.firstCharOffset;
  }
  setSource(t = "", r = () => {
  }) {
    t = String(t || "");
    let n = t.length, o = Be(this.offsetAndType, t.length + 1), i = Be(this.balance, t.length + 1), s = 0, u2 = 0, c2 = 0, a = -1;
    for (this.offsetAndType = null, this.balance = null, r(t, (l2, p2, m) => {
      switch (l2) {
        default:
          i[s] = n;
          break;
        case u2: {
          let f = c2 & ne;
          for (c2 = i[f], u2 = c2 >> we, i[s] = f, i[f++] = s; f < s; f++)
            i[f] === n && (i[f] = s);
          break;
        }
        case 21:
        case 2:
        case 19:
        case 23:
          i[s] = c2, u2 = ds.get(l2), c2 = u2 << we | s;
          break;
      }
      o[s++] = l2 << we | m, a === -1 && (a = p2);
    }), o[s] = 0 << we | n, i[s] = n, i[n] = n; c2 !== 0; ) {
      let l2 = c2 & ne;
      c2 = i[l2], i[l2] = n;
    }
    this.source = t, this.firstCharOffset = a === -1 ? 0 : a, this.tokenCount = s, this.offsetAndType = o, this.balance = i, this.reset(), this.next();
  }
  lookupType(t) {
    return t += this.tokenIndex, t < this.tokenCount ? this.offsetAndType[t] >> we : 0;
  }
  lookupOffset(t) {
    return t += this.tokenIndex, t < this.tokenCount ? this.offsetAndType[t - 1] & ne : this.source.length;
  }
  lookupValue(t, r) {
    return t += this.tokenIndex, t < this.tokenCount ? ge(this.source, this.offsetAndType[t - 1] & ne, this.offsetAndType[t] & ne, r) : false;
  }
  getTokenStart(t) {
    return t === this.tokenIndex ? this.tokenStart : t > 0 ? t < this.tokenCount ? this.offsetAndType[t - 1] & ne : this.offsetAndType[this.tokenCount] & ne : this.firstCharOffset;
  }
  substrToCursor(t) {
    return this.source.substring(t, this.tokenStart);
  }
  isBalanceEdge(t) {
    return this.balance[this.tokenIndex] < t;
  }
  isDelim(t, r) {
    return r ? this.lookupType(r) === 9 && this.source.charCodeAt(this.lookupOffset(r)) === t : this.tokenType === 9 && this.source.charCodeAt(this.tokenStart) === t;
  }
  skip(t) {
    let r = this.tokenIndex + t;
    r < this.tokenCount ? (this.tokenIndex = r, this.tokenStart = this.offsetAndType[r - 1] & ne, r = this.offsetAndType[r], this.tokenType = r >> we, this.tokenEnd = r & ne) : (this.tokenIndex = this.tokenCount, this.next());
  }
  next() {
    let t = this.tokenIndex + 1;
    t < this.tokenCount ? (this.tokenIndex = t, this.tokenStart = this.tokenEnd, t = this.offsetAndType[t], this.tokenType = t >> we, this.tokenEnd = t & ne) : (this.eof = true, this.tokenIndex = this.tokenCount, this.tokenType = 0, this.tokenStart = this.tokenEnd = this.source.length);
  }
  skipSC() {
    for (; this.tokenType === 13 || this.tokenType === 25; )
      this.next();
  }
  skipUntilBalanced(t, r) {
    let n = t, o, i;
    e:
      for (; n < this.tokenCount; n++) {
        if (o = this.balance[n], o < t)
          break e;
        switch (i = n > 0 ? this.offsetAndType[n - 1] & ne : this.firstCharOffset, r(this.source.charCodeAt(i))) {
          case 1:
            break e;
          case 2:
            n++;
            break e;
          default:
            this.balance[o] === n && (n = o);
        }
      }
    this.skip(n - this.tokenIndex);
  }
  forEachToken(t) {
    for (let r = 0, n = this.firstCharOffset; r < this.tokenCount; r++) {
      let o = n, i = this.offsetAndType[r], s = i & ne, u2 = i >> we;
      n = s, t(u2, o, s, r);
    }
  }
  dump() {
    let t = new Array(this.tokenCount);
    return this.forEachToken((r, n, o, i) => {
      t[i] = { idx: i, type: Fe[r], chunk: this.source.substring(n, o), balance: this.balance[i] };
    }), t;
  }
};
function ve(e, t) {
  function r(p2) {
    return p2 < u2 ? e.charCodeAt(p2) : 0;
  }
  function n() {
    if (a = Te(e, a), ze(r(a), r(a + 1), r(a + 2))) {
      l2 = 12, a = tt(e, a);
      return;
    }
    if (r(a) === 37) {
      l2 = 11, a++;
      return;
    }
    l2 = 10;
  }
  function o() {
    let p2 = a;
    if (a = tt(e, a), ge(e, p2, a, "url") && r(a) === 40) {
      if (a = et(e, a + 1), r(a) === 34 || r(a) === 39) {
        l2 = 2, a = p2 + 4;
        return;
      }
      s();
      return;
    }
    if (r(a) === 40) {
      l2 = 2, a++;
      return;
    }
    l2 = 1;
  }
  function i(p2) {
    for (p2 || (p2 = r(a++)), l2 = 5; a < e.length; a++) {
      let m = e.charCodeAt(a);
      switch (St(m)) {
        case p2:
          a++;
          return;
        case Je:
          if (Ze(m)) {
            a += Ct(e, a, m), l2 = 6;
            return;
          }
          break;
        case 92:
          if (a === e.length - 1)
            break;
          let f = r(a + 1);
          Ze(f) ? a += Ct(e, a + 1, f) : $(m, f) && (a = se(e, a) - 1);
          break;
      }
    }
  }
  function s() {
    for (l2 = 7, a = et(e, a); a < e.length; a++) {
      let p2 = e.charCodeAt(a);
      switch (St(p2)) {
        case 41:
          a++;
          return;
        case Je:
          if (a = et(e, a), r(a) === 41 || a >= e.length) {
            a < e.length && a++;
            return;
          }
          a = At(e, a), l2 = 8;
          return;
        case 34:
        case 39:
        case 40:
        case or:
          a = At(e, a), l2 = 8;
          return;
        case 92:
          if ($(p2, r(a + 1))) {
            a = se(e, a) - 1;
            break;
          }
          a = At(e, a), l2 = 8;
          return;
      }
    }
  }
  e = String(e || "");
  let u2 = e.length, c2 = wt(r(0)), a = c2, l2;
  for (; a < u2; ) {
    let p2 = e.charCodeAt(a);
    switch (St(p2)) {
      case Je:
        l2 = 13, a = et(e, a + 1);
        break;
      case 34:
        i();
        break;
      case 35:
        Ne(r(a + 1)) || $(r(a + 1), r(a + 2)) ? (l2 = 4, a = tt(e, a + 1)) : (l2 = 9, a++);
        break;
      case 39:
        i();
        break;
      case 40:
        l2 = 21, a++;
        break;
      case 41:
        l2 = 22, a++;
        break;
      case 43:
        kt(p2, r(a + 1), r(a + 2)) ? n() : (l2 = 9, a++);
        break;
      case 44:
        l2 = 18, a++;
        break;
      case 45:
        kt(p2, r(a + 1), r(a + 2)) ? n() : r(a + 1) === 45 && r(a + 2) === 62 ? (l2 = 15, a = a + 3) : ze(p2, r(a + 1), r(a + 2)) ? o() : (l2 = 9, a++);
        break;
      case 46:
        kt(p2, r(a + 1), r(a + 2)) ? n() : (l2 = 9, a++);
        break;
      case 47:
        r(a + 1) === 42 ? (l2 = 25, a = e.indexOf("*/", a + 2), a = a === -1 ? e.length : a + 2) : (l2 = 9, a++);
        break;
      case 58:
        l2 = 16, a++;
        break;
      case 59:
        l2 = 17, a++;
        break;
      case 60:
        r(a + 1) === 33 && r(a + 2) === 45 && r(a + 3) === 45 ? (l2 = 14, a = a + 4) : (l2 = 9, a++);
        break;
      case 64:
        ze(r(a + 1), r(a + 2), r(a + 3)) ? (l2 = 3, a = tt(e, a + 1)) : (l2 = 9, a++);
        break;
      case 91:
        l2 = 19, a++;
        break;
      case 92:
        $(p2, r(a + 1)) ? o() : (l2 = 9, a++);
        break;
      case 93:
        l2 = 20, a++;
        break;
      case 123:
        l2 = 23, a++;
        break;
      case 125:
        l2 = 24, a++;
        break;
      case nr:
        n();
        break;
      case vt:
        o();
        break;
      default:
        l2 = 9, a++;
    }
    t(l2, c2, c2 = a);
  }
}
var _e = null;
var D = class {
  static createItem(t) {
    return { prev: null, next: null, data: t };
  }
  constructor() {
    this.head = null, this.tail = null, this.cursor = null;
  }
  createItem(t) {
    return D.createItem(t);
  }
  allocateCursor(t, r) {
    let n;
    return _e !== null ? (n = _e, _e = _e.cursor, n.prev = t, n.next = r, n.cursor = this.cursor) : n = { prev: t, next: r, cursor: this.cursor }, this.cursor = n, n;
  }
  releaseCursor() {
    let { cursor: t } = this;
    this.cursor = t.cursor, t.prev = null, t.next = null, t.cursor = _e, _e = t;
  }
  updateCursors(t, r, n, o) {
    let { cursor: i } = this;
    for (; i !== null; )
      i.prev === t && (i.prev = r), i.next === n && (i.next = o), i = i.cursor;
  }
  *[Symbol.iterator]() {
    for (let t = this.head; t !== null; t = t.next)
      yield t.data;
  }
  get size() {
    let t = 0;
    for (let r = this.head; r !== null; r = r.next)
      t++;
    return t;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }
  fromArray(t) {
    let r = null;
    this.head = null;
    for (let n of t) {
      let o = D.createItem(n);
      r !== null ? r.next = o : this.head = o, o.prev = r, r = o;
    }
    return this.tail = r, this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }
  forEach(t, r = this) {
    let n = this.allocateCursor(null, this.head);
    for (; n.next !== null; ) {
      let o = n.next;
      n.next = o.next, t.call(r, o.data, o, this);
    }
    this.releaseCursor();
  }
  forEachRight(t, r = this) {
    let n = this.allocateCursor(this.tail, null);
    for (; n.prev !== null; ) {
      let o = n.prev;
      n.prev = o.prev, t.call(r, o.data, o, this);
    }
    this.releaseCursor();
  }
  reduce(t, r, n = this) {
    let o = this.allocateCursor(null, this.head), i = r, s;
    for (; o.next !== null; )
      s = o.next, o.next = s.next, i = t.call(n, i, s.data, s, this);
    return this.releaseCursor(), i;
  }
  reduceRight(t, r, n = this) {
    let o = this.allocateCursor(this.tail, null), i = r, s;
    for (; o.prev !== null; )
      s = o.prev, o.prev = s.prev, i = t.call(n, i, s.data, s, this);
    return this.releaseCursor(), i;
  }
  some(t, r = this) {
    for (let n = this.head; n !== null; n = n.next)
      if (t.call(r, n.data, n, this))
        return true;
    return false;
  }
  map(t, r = this) {
    let n = new D();
    for (let o = this.head; o !== null; o = o.next)
      n.appendData(t.call(r, o.data, o, this));
    return n;
  }
  filter(t, r = this) {
    let n = new D();
    for (let o = this.head; o !== null; o = o.next)
      t.call(r, o.data, o, this) && n.appendData(o.data);
    return n;
  }
  nextUntil(t, r, n = this) {
    if (t === null)
      return;
    let o = this.allocateCursor(null, t);
    for (; o.next !== null; ) {
      let i = o.next;
      if (o.next = i.next, r.call(n, i.data, i, this))
        break;
    }
    this.releaseCursor();
  }
  prevUntil(t, r, n = this) {
    if (t === null)
      return;
    let o = this.allocateCursor(t, null);
    for (; o.prev !== null; ) {
      let i = o.prev;
      if (o.prev = i.prev, r.call(n, i.data, i, this))
        break;
    }
    this.releaseCursor();
  }
  clear() {
    this.head = null, this.tail = null;
  }
  copy() {
    let t = new D();
    for (let r of this)
      t.appendData(r);
    return t;
  }
  prepend(t) {
    return this.updateCursors(null, t, this.head, t), this.head !== null ? (this.head.prev = t, t.next = this.head) : this.tail = t, this.head = t, this;
  }
  prependData(t) {
    return this.prepend(D.createItem(t));
  }
  append(t) {
    return this.insert(t);
  }
  appendData(t) {
    return this.insert(D.createItem(t));
  }
  insert(t, r = null) {
    if (r !== null)
      if (this.updateCursors(r.prev, t, r, t), r.prev === null) {
        if (this.head !== r)
          throw new Error("before doesn't belong to list");
        this.head = t, r.prev = t, t.next = r, this.updateCursors(null, t);
      } else
        r.prev.next = t, t.prev = r.prev, r.prev = t, t.next = r;
    else
      this.updateCursors(this.tail, t, null, t), this.tail !== null ? (this.tail.next = t, t.prev = this.tail) : this.head = t, this.tail = t;
    return this;
  }
  insertData(t, r) {
    return this.insert(D.createItem(t), r);
  }
  remove(t) {
    if (this.updateCursors(t, t.prev, t, t.next), t.prev !== null)
      t.prev.next = t.next;
    else {
      if (this.head !== t)
        throw new Error("item doesn't belong to list");
      this.head = t.next;
    }
    if (t.next !== null)
      t.next.prev = t.prev;
    else {
      if (this.tail !== t)
        throw new Error("item doesn't belong to list");
      this.tail = t.prev;
    }
    return t.prev = null, t.next = null, t;
  }
  push(t) {
    this.insert(D.createItem(t));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(t) {
    this.prepend(D.createItem(t));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(t) {
    return this.insertList(t, this.head);
  }
  appendList(t) {
    return this.insertList(t);
  }
  insertList(t, r) {
    return t.head === null ? this : (r != null ? (this.updateCursors(r.prev, t.tail, r, t.head), r.prev !== null ? (r.prev.next = t.head, t.head.prev = r.prev) : this.head = t.head, r.prev = t.tail, t.tail.next = r) : (this.updateCursors(this.tail, t.tail, null, t.head), this.tail !== null ? (this.tail.next = t.head, t.head.prev = this.tail) : this.head = t.head, this.tail = t.tail), t.head = null, t.tail = null, this);
  }
  replace(t, r) {
    "head" in r ? this.insertList(r, t) : this.insert(r, t), this.remove(t);
  }
};
function Ee(e, t) {
  let r = Object.create(SyntaxError.prototype), n = new Error();
  return Object.assign(r, { name: e, message: t, get stack() {
    return (n.stack || "").replace(/^(.+\n){1,3}/, `${e}: ${t}
`);
  } });
}
var ar = 100;
var Ho = 60;
var Yo = "    ";
function Go({ source: e, line: t, column: r }, n) {
  function o(l2, p2) {
    return i.slice(l2, p2).map((m, f) => String(l2 + f + 1).padStart(c2) + " |" + m).join(`
`);
  }
  let i = e.split(/\r\n?|\n|\f/), s = Math.max(1, t - n) - 1, u2 = Math.min(t + n, i.length + 1), c2 = Math.max(4, String(u2).length) + 1, a = 0;
  r += (Yo.length - 1) * (i[t - 1].substr(0, r - 1).match(/\t/g) || []).length, r > ar && (a = r - Ho + 3, r = Ho - 2);
  for (let l2 = s; l2 <= u2; l2++)
    l2 >= 0 && l2 < i.length && (i[l2] = i[l2].replace(/\t/g, Yo), i[l2] = (a > 0 && i[l2].length > a ? "…" : "") + i[l2].substr(a, ar - 2) + (i[l2].length > a + ar - 1 ? "…" : ""));
  return [o(s, t), new Array(r + c2 + 2).join("-") + "^", o(t, u2)].filter(Boolean).join(`
`);
}
function sr(e, t, r, n, o) {
  return Object.assign(Ee("SyntaxError", e), { source: t, offset: r, line: n, column: o, sourceFragment(s) {
    return Go({ source: t, line: n, column: o }, isNaN(s) ? 0 : s);
  }, get formattedMessage() {
    return `Parse error: ${e}
` + Go({ source: t, line: n, column: o }, 2);
  } });
}
function Vo(e) {
  let t = this.createList(), r = false, n = { recognizer: e };
  for (; !this.eof; ) {
    switch (this.tokenType) {
      case 25:
        this.next();
        continue;
      case 13:
        r = true, this.next();
        continue;
    }
    let o = e.getNode.call(this, n);
    if (o === void 0)
      break;
    r && (e.onWhiteSpace && e.onWhiteSpace.call(this, o, t, n), r = false), t.push(o);
  }
  return r && e.onWhiteSpace && e.onWhiteSpace.call(this, null, t, n), t;
}
var Ko = () => {
};
var gs = 33;
var bs = 35;
var lr = 59;
var Qo = 123;
var Xo = 0;
function xs(e) {
  return function() {
    return this[e]();
  };
}
function cr(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in e) {
    let n = e[r], o = n.parse || n;
    o && (t[r] = o);
  }
  return t;
}
function ys(e) {
  let t = { context: /* @__PURE__ */ Object.create(null), scope: Object.assign(/* @__PURE__ */ Object.create(null), e.scope), atrule: cr(e.atrule), pseudo: cr(e.pseudo), node: cr(e.node) };
  for (let r in e.parseContext)
    switch (typeof e.parseContext[r]) {
      case "function":
        t.context[r] = e.parseContext[r];
        break;
      case "string":
        t.context[r] = xs(e.parseContext[r]);
        break;
    }
  return { config: t, ...t, ...t.node };
}
function $o(e) {
  let t = "", r = "<unknown>", n = false, o = Ko, i = false, s = new Tt(), u2 = Object.assign(new rt(), ys(e || {}), { parseAtrulePrelude: true, parseRulePrelude: true, parseValue: true, parseCustomProperty: false, readSequence: Vo, consumeUntilBalanceEnd: () => 0, consumeUntilLeftCurlyBracket(a) {
    return a === Qo ? 1 : 0;
  }, consumeUntilLeftCurlyBracketOrSemicolon(a) {
    return a === Qo || a === lr ? 1 : 0;
  }, consumeUntilExclamationMarkOrSemicolon(a) {
    return a === gs || a === lr ? 1 : 0;
  }, consumeUntilSemicolonIncluded(a) {
    return a === lr ? 2 : 0;
  }, createList() {
    return new D();
  }, createSingleNodeList(a) {
    return new D().appendData(a);
  }, getFirstListNode(a) {
    return a && a.first;
  }, getLastListNode(a) {
    return a && a.last;
  }, parseWithFallback(a, l2) {
    let p2 = this.tokenIndex;
    try {
      return a.call(this);
    } catch (m) {
      if (i)
        throw m;
      let f = l2.call(this, p2);
      return i = true, o(m, f), i = false, f;
    }
  }, lookupNonWSType(a) {
    let l2;
    do
      if (l2 = this.lookupType(a++), l2 !== 13)
        return l2;
    while (l2 !== Xo);
    return Xo;
  }, charCodeAt(a) {
    return a >= 0 && a < t.length ? t.charCodeAt(a) : 0;
  }, substring(a, l2) {
    return t.substring(a, l2);
  }, substrToCursor(a) {
    return this.source.substring(a, this.tokenStart);
  }, cmpChar(a, l2) {
    return de(t, a, l2);
  }, cmpStr(a, l2, p2) {
    return ge(t, a, l2, p2);
  }, consume(a) {
    let l2 = this.tokenStart;
    return this.eat(a), this.substrToCursor(l2);
  }, consumeFunctionName() {
    let a = t.substring(this.tokenStart, this.tokenEnd - 1);
    return this.eat(2), a;
  }, consumeNumber(a) {
    let l2 = t.substring(this.tokenStart, Te(t, this.tokenStart));
    return this.eat(a), l2;
  }, eat(a) {
    if (this.tokenType !== a) {
      let l2 = Fe[a].slice(0, -6).replace(/-/g, " ").replace(/^./, (f) => f.toUpperCase()), p2 = `${/[[\](){}]/.test(l2) ? `"${l2}"` : l2} is expected`, m = this.tokenStart;
      switch (a) {
        case 1:
          this.tokenType === 2 || this.tokenType === 7 ? (m = this.tokenEnd - 1, p2 = "Identifier is expected but function found") : p2 = "Identifier is expected";
          break;
        case 4:
          this.isDelim(bs) && (this.next(), m++, p2 = "Name is expected");
          break;
        case 11:
          this.tokenType === 10 && (m = this.tokenEnd, p2 = "Percent sign is expected");
          break;
      }
      this.error(p2, m);
    }
    this.next();
  }, eatIdent(a) {
    (this.tokenType !== 1 || this.lookupValue(0, a) === false) && this.error(`Identifier "${a}" is expected`), this.next();
  }, eatDelim(a) {
    this.isDelim(a) || this.error(`Delim "${String.fromCharCode(a)}" is expected`), this.next();
  }, getLocation(a, l2) {
    return n ? s.getLocationRange(a, l2, r) : null;
  }, getLocationFromList(a) {
    if (n) {
      let l2 = this.getFirstListNode(a), p2 = this.getLastListNode(a);
      return s.getLocationRange(l2 !== null ? l2.loc.start.offset - s.startOffset : this.tokenStart, p2 !== null ? p2.loc.end.offset - s.startOffset : this.tokenStart, r);
    }
    return null;
  }, error(a, l2) {
    let p2 = typeof l2 < "u" && l2 < t.length ? s.getLocation(l2) : this.eof ? s.getLocation(qo(t, t.length - 1)) : s.getLocation(this.tokenStart);
    throw new sr(a || "Unexpected input", t, p2.offset, p2.line, p2.column);
  } });
  return Object.assign(function(a, l2) {
    t = a, l2 = l2 || {}, u2.setSource(t, ve), s.setSource(t, l2.offset, l2.line, l2.column), r = l2.filename || "<unknown>", n = Boolean(l2.positions), o = typeof l2.onParseError == "function" ? l2.onParseError : Ko, i = false, u2.parseAtrulePrelude = "parseAtrulePrelude" in l2 ? Boolean(l2.parseAtrulePrelude) : true, u2.parseRulePrelude = "parseRulePrelude" in l2 ? Boolean(l2.parseRulePrelude) : true, u2.parseValue = "parseValue" in l2 ? Boolean(l2.parseValue) : true, u2.parseCustomProperty = "parseCustomProperty" in l2 ? Boolean(l2.parseCustomProperty) : false;
    let { context: p2 = "default", onComment: m } = l2;
    if (!(p2 in u2.context))
      throw new Error("Unknown context `" + p2 + "`");
    typeof m == "function" && u2.forEachToken((P, te, X) => {
      if (P === 25) {
        let S = u2.getLocation(te, X), R = ge(t, X - 2, X, "*/") ? t.slice(te + 2, X - 2) : t.slice(te + 2, X);
        m(R, S);
      }
    });
    let f = u2.context[p2].call(u2, l2);
    return u2.eof || u2.error(), f;
  }, { SyntaxError: sr, config: u2.config });
}
var xi = ls(gi(), 1);
var bi = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
function yi(e) {
  let t = new xi.SourceMapGenerator(), r = { line: 1, column: 0 }, n = { line: 0, column: 0 }, o = { line: 1, column: 0 }, i = { generated: o }, s = 1, u2 = 0, c2 = false, a = e.node;
  e.node = function(m) {
    if (m.loc && m.loc.start && bi.has(m.type)) {
      let f = m.loc.start.line, P = m.loc.start.column - 1;
      (n.line !== f || n.column !== P) && (n.line = f, n.column = P, r.line = s, r.column = u2, c2 && (c2 = false, (r.line !== o.line || r.column !== o.column) && t.addMapping(i)), c2 = true, t.addMapping({ source: m.loc.source, original: n, generated: r }));
    }
    a.call(this, m), c2 && bi.has(m.type) && (o.line = s, o.column = u2);
  };
  let l2 = e.emit;
  e.emit = function(m, f, P) {
    for (let te = 0; te < m.length; te++)
      m.charCodeAt(te) === 10 ? (s++, u2 = 0) : u2++;
    l2(m, f, P);
  };
  let p2 = e.result;
  return e.result = function() {
    return c2 && t.addMapping(i), { css: p2(), map: t };
  }, e;
}
var It = {};
b$1(It, { safe: () => br, spec: () => Us });
var Bs = 43;
var _s = 45;
var gr = (e, t) => {
  if (e === 9 && (e = t), typeof e == "string") {
    let r = e.charCodeAt(0);
    return r > 127 ? 32768 : r << 8;
  }
  return e;
};
var ki = [[1, 1], [1, 2], [1, 7], [1, 8], [1, "-"], [1, 10], [1, 11], [1, 12], [1, 15], [1, 21], [3, 1], [3, 2], [3, 7], [3, 8], [3, "-"], [3, 10], [3, 11], [3, 12], [3, 15], [4, 1], [4, 2], [4, 7], [4, 8], [4, "-"], [4, 10], [4, 11], [4, 12], [4, 15], [12, 1], [12, 2], [12, 7], [12, 8], [12, "-"], [12, 10], [12, 11], [12, 12], [12, 15], ["#", 1], ["#", 2], ["#", 7], ["#", 8], ["#", "-"], ["#", 10], ["#", 11], ["#", 12], ["#", 15], ["-", 1], ["-", 2], ["-", 7], ["-", 8], ["-", "-"], ["-", 10], ["-", 11], ["-", 12], ["-", 15], [10, 1], [10, 2], [10, 7], [10, 8], [10, 10], [10, 11], [10, 12], [10, "%"], [10, 15], ["@", 1], ["@", 2], ["@", 7], ["@", 8], ["@", "-"], ["@", 15], [".", 10], [".", 11], [".", 12], ["+", 10], ["+", 11], ["+", 12], ["/", "*"]];
var qs = ki.concat([[1, 4], [12, 4], [4, 4], [3, 21], [3, 5], [3, 16], [11, 11], [11, 12], [11, 2], [11, "-"], [22, 1], [22, 2], [22, 11], [22, 12], [22, 4], [22, "-"]]);
function wi(e) {
  let t = new Set(e.map(([r, n]) => gr(r) << 16 | gr(n)));
  return function(r, n, o) {
    let i = gr(n, o), s = o.charCodeAt(0);
    return (s === _s && n !== 1 && n !== 2 && n !== 15 || s === Bs ? t.has(r << 16 | s << 8) : t.has(r << 16 | i)) && this.emit(" ", 13, true), i;
  };
}
var Us = wi(ki);
var br = wi(qs);
var js = 92;
function Ws(e, t) {
  if (typeof t == "function") {
    let r = null;
    e.children.forEach((n) => {
      r !== null && t.call(this, r), this.node(n), r = n;
    });
    return;
  }
  e.children.forEach(this.node, this);
}
function Hs(e) {
  ve(e, (t, r, n) => {
    this.token(t, e.slice(r, n));
  });
}
function vi(e) {
  let t = /* @__PURE__ */ new Map();
  for (let r in e.node) {
    let n = e.node[r];
    typeof (n.generate || n) == "function" && t.set(r, n.generate || n);
  }
  return function(r, n) {
    let o = "", i = 0, s = { node(c2) {
      if (t.has(c2.type))
        t.get(c2.type).call(u2, c2);
      else
        throw new Error("Unknown node type: " + c2.type);
    }, tokenBefore: br, token(c2, a) {
      i = this.tokenBefore(i, c2, a), this.emit(a, c2, false), c2 === 9 && a.charCodeAt(0) === js && this.emit(`
`, 13, true);
    }, emit(c2) {
      o += c2;
    }, result() {
      return o;
    } };
    n && (typeof n.decorator == "function" && (s = n.decorator(s)), n.sourceMap && (s = yi(s)), n.mode in It && (s.tokenBefore = It[n.mode]));
    let u2 = { node: (c2) => s.node(c2), children: Ws, token: (c2, a) => s.token(c2, a), tokenize: Hs };
    return s.node(r), s.result();
  };
}
function Si(e) {
  return { fromPlainObject(t) {
    return e(t, { enter(r) {
      r.children && !(r.children instanceof D) && (r.children = new D().fromArray(r.children));
    } }), t;
  }, toPlainObject(t) {
    return e(t, { leave(r) {
      r.children && r.children instanceof D && (r.children = r.children.toArray());
    } }), t;
  } };
}
var { hasOwnProperty: xr } = Object.prototype;
var it = function() {
};
function Ci(e) {
  return typeof e == "function" ? e : it;
}
function Ai(e, t) {
  return function(r, n, o) {
    r.type === t && e.call(this, r, n, o);
  };
}
function Ys(e, t) {
  let r = t.structure, n = [];
  for (let o in r) {
    if (xr.call(r, o) === false)
      continue;
    let i = r[o], s = { name: o, type: false, nullable: false };
    Array.isArray(i) || (i = [i]);
    for (let u2 of i)
      u2 === null ? s.nullable = true : typeof u2 == "string" ? s.type = "node" : Array.isArray(u2) && (s.type = "list");
    s.type && n.push(s);
  }
  return n.length ? { context: t.walkContext, fields: n } : null;
}
function Gs(e) {
  let t = {};
  for (let r in e.node)
    if (xr.call(e.node, r)) {
      let n = e.node[r];
      if (!n.structure)
        throw new Error("Missed `structure` field in `" + r + "` node type definition");
      t[r] = Ys(r, n);
    }
  return t;
}
function Ti(e, t) {
  let r = e.fields.slice(), n = e.context, o = typeof n == "string";
  return t && r.reverse(), function(i, s, u2, c2) {
    let a;
    o && (a = s[n], s[n] = i);
    for (let l2 of r) {
      let p2 = i[l2.name];
      if (!l2.nullable || p2) {
        if (l2.type === "list") {
          if (t ? p2.reduceRight(c2, false) : p2.reduce(c2, false))
            return true;
        } else if (u2(p2))
          return true;
      }
    }
    o && (s[n] = a);
  };
}
function Ei({ StyleSheet: e, Atrule: t, Rule: r, Block: n, DeclarationList: o }) {
  return { Atrule: { StyleSheet: e, Atrule: t, Rule: r, Block: n }, Rule: { StyleSheet: e, Atrule: t, Rule: r, Block: n }, Declaration: { StyleSheet: e, Atrule: t, Rule: r, Block: n, DeclarationList: o } };
}
function Li(e) {
  let t = Gs(e), r = {}, n = {}, o = Symbol("break-walk"), i = Symbol("skip-node");
  for (let a in t)
    xr.call(t, a) && t[a] !== null && (r[a] = Ti(t[a], false), n[a] = Ti(t[a], true));
  let s = Ei(r), u2 = Ei(n), c2 = function(a, l2) {
    function p2(S, R, ke) {
      let z = m.call(X, S, R, ke);
      return z === o ? true : z === i ? false : !!(P.hasOwnProperty(S.type) && P[S.type](S, X, p2, te) || f.call(X, S, R, ke) === o);
    }
    let m = it, f = it, P = r, te = (S, R, ke, z) => S || p2(R, ke, z), X = { break: o, skip: i, root: a, stylesheet: null, atrule: null, atrulePrelude: null, rule: null, selector: null, block: null, declaration: null, function: null };
    if (typeof l2 == "function")
      m = l2;
    else if (l2 && (m = Ci(l2.enter), f = Ci(l2.leave), l2.reverse && (P = n), l2.visit)) {
      if (s.hasOwnProperty(l2.visit))
        P = l2.reverse ? u2[l2.visit] : s[l2.visit];
      else if (!t.hasOwnProperty(l2.visit))
        throw new Error("Bad value `" + l2.visit + "` for `visit` option (should be: " + Object.keys(t).sort().join(", ") + ")");
      m = Ai(m, l2.visit), f = Ai(f, l2.visit);
    }
    if (m === it && f === it)
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    p2(a);
  };
  return c2.break = o, c2.skip = i, c2.find = function(a, l2) {
    let p2 = null;
    return c2(a, function(m, f, P) {
      if (l2.call(this, m, f, P))
        return p2 = m, o;
    }), p2;
  }, c2.findLast = function(a, l2) {
    let p2 = null;
    return c2(a, { reverse: true, enter(m, f, P) {
      if (l2.call(this, m, f, P))
        return p2 = m, o;
    } }), p2;
  }, c2.findAll = function(a, l2) {
    let p2 = [];
    return c2(a, function(m, f, P) {
      l2.call(this, m, f, P) && p2.push(m);
    }), p2;
  }, c2;
}
function Vs(e) {
  return e;
}
function Ks(e) {
  let { min: t, max: r, comma: n } = e;
  return t === 0 && r === 0 ? n ? "#?" : "*" : t === 0 && r === 1 ? "?" : t === 1 && r === 0 ? n ? "#" : "+" : t === 1 && r === 1 ? "" : (n ? "#" : "") + (t === r ? "{" + t + "}" : "{" + t + "," + (r !== 0 ? r : "") + "}");
}
function Qs(e) {
  switch (e.type) {
    case "Range":
      return " [" + (e.min === null ? "-∞" : e.min) + "," + (e.max === null ? "∞" : e.max) + "]";
    default:
      throw new Error("Unknown node type `" + e.type + "`");
  }
}
function Xs(e, t, r, n) {
  let o = e.combinator === " " || n ? e.combinator : " " + e.combinator + " ", i = e.terms.map((s) => yr(s, t, r, n)).join(o);
  return e.explicit || r ? (n || i[0] === "," ? "[" : "[ ") + i + (n ? "]" : " ]") : i;
}
function yr(e, t, r, n) {
  let o;
  switch (e.type) {
    case "Group":
      o = Xs(e, t, r, n) + (e.disallowEmpty ? "!" : "");
      break;
    case "Multiplier":
      return yr(e.term, t, r, n) + t(Ks(e), e);
    case "Type":
      o = "<" + e.name + (e.opts ? t(Qs(e.opts), e.opts) : "") + ">";
      break;
    case "Property":
      o = "<'" + e.name + "'>";
      break;
    case "Keyword":
      o = e.name;
      break;
    case "AtKeyword":
      o = "@" + e.name;
      break;
    case "Function":
      o = e.name + "(";
      break;
    case "String":
    case "Token":
      o = e.value;
      break;
    case "Comma":
      o = ",";
      break;
    default:
      throw new Error("Unknown node type `" + e.type + "`");
  }
  return t(o, e);
}
function Pe(e, t) {
  let r = Vs, n = false, o = false;
  return typeof t == "function" ? r = t : t && (n = Boolean(t.forceBraces), o = Boolean(t.compact), typeof t.decorate == "function" && (r = t.decorate)), yr(e, r, n, o);
}
var Pi = { offset: 0, line: 1, column: 1 };
function $s(e, t) {
  let r = e.tokens, n = e.longestMatch, o = n < r.length && r[n].node || null, i = o !== t ? o : null, s = 0, u2 = 0, c2 = 0, a = "", l2, p2;
  for (let m = 0; m < r.length; m++) {
    let f = r[m].value;
    m === n && (u2 = f.length, s = a.length), i !== null && r[m].node === i && (m <= n ? c2++ : c2 = 0), a += f;
  }
  return n === r.length || c2 > 1 ? (l2 = Dt(i || t, "end") || at2(Pi, a), p2 = at2(l2)) : (l2 = Dt(i, "start") || at2(Dt(t, "start") || Pi, a.slice(0, s)), p2 = Dt(i, "end") || at2(l2, a.substr(s, u2))), { css: a, mismatchOffset: s, mismatchLength: u2, start: l2, end: p2 };
}
function Dt(e, t) {
  let r = e && e.loc && e.loc[t];
  return r ? "line" in r ? at2(r) : r : null;
}
function at2({ offset: e, line: t, column: r }, n) {
  let o = { offset: e, line: t, column: r };
  if (n) {
    let i = n.split(/\n|\r\n?|\f/);
    o.offset += n.length, o.line += i.length - 1, o.column = i.length === 1 ? o.column + n.length : i.pop().length + 1;
  }
  return o;
}
var Ue = function(e, t) {
  let r = Ee("SyntaxReferenceError", e + (t ? " `" + t + "`" : ""));
  return r.reference = t, r;
};
var Ii = function(e, t, r, n) {
  let o = Ee("SyntaxMatchError", e), { css: i, mismatchOffset: s, mismatchLength: u2, start: c2, end: a } = $s(n, r);
  return o.rawMessage = e, o.syntax = t ? Pe(t) : "<generic>", o.css = i, o.mismatchOffset = s, o.mismatchLength = u2, o.message = e + `
  syntax: ` + o.syntax + `
   value: ` + (i || "<empty string>") + `
  --------` + new Array(o.mismatchOffset + 1).join("-") + "^", Object.assign(o, c2), o.loc = { source: r && r.loc && r.loc.source || "<unknown>", start: c2, end: a }, o;
};
var Ot = /* @__PURE__ */ new Map();
var je = /* @__PURE__ */ new Map();
var Nt = 45;
var zt = Zs;
var kr = Js;
function Mt(e, t) {
  return t = t || 0, e.length - t >= 2 && e.charCodeAt(t) === Nt && e.charCodeAt(t + 1) === Nt;
}
function wr(e, t) {
  if (t = t || 0, e.length - t >= 3 && e.charCodeAt(t) === Nt && e.charCodeAt(t + 1) !== Nt) {
    let r = e.indexOf("-", t + 2);
    if (r !== -1)
      return e.substring(t, r + 1);
  }
  return "";
}
function Zs(e) {
  if (Ot.has(e))
    return Ot.get(e);
  let t = e.toLowerCase(), r = Ot.get(t);
  if (r === void 0) {
    let n = Mt(t, 0), o = n ? "" : wr(t, 0);
    r = Object.freeze({ basename: t.substr(o.length), name: t, prefix: o, vendor: o, custom: n });
  }
  return Ot.set(e, r), r;
}
function Js(e) {
  if (je.has(e))
    return je.get(e);
  let t = e, r = e[0];
  r === "/" ? r = e[1] === "/" ? "//" : "/" : r !== "_" && r !== "*" && r !== "$" && r !== "#" && r !== "+" && r !== "&" && (r = "");
  let n = Mt(t, r.length);
  if (!n && (t = t.toLowerCase(), je.has(t))) {
    let u2 = je.get(t);
    return je.set(e, u2), u2;
  }
  let o = n ? "" : wr(t, r.length), i = t.substr(0, r.length + o.length), s = Object.freeze({ basename: t.substr(i.length), name: t.substr(r.length), hack: r, vendor: o, prefix: i, custom: n });
  return je.set(e, s), s;
}
var Rt = ["initial", "inherit", "unset", "revert", "revert-layer"];
var lt = 43;
var he = 45;
var vr = 110;
var We = true;
var tl = false;
function Cr(e, t) {
  return e !== null && e.type === 9 && e.value.charCodeAt(0) === t;
}
function st(e, t, r) {
  for (; e !== null && (e.type === 13 || e.type === 25); )
    e = r(++t);
  return t;
}
function Se(e, t, r, n) {
  if (!e)
    return 0;
  let o = e.value.charCodeAt(t);
  if (o === lt || o === he) {
    if (r)
      return 0;
    t++;
  }
  for (; t < e.value.length; t++)
    if (!B(e.value.charCodeAt(t)))
      return 0;
  return n + 1;
}
function Sr(e, t, r) {
  let n = false, o = st(e, t, r);
  if (e = r(o), e === null)
    return t;
  if (e.type !== 10)
    if (Cr(e, lt) || Cr(e, he)) {
      if (n = true, o = st(r(++o), o, r), e = r(o), e === null || e.type !== 10)
        return 0;
    } else
      return t;
  if (!n) {
    let i = e.value.charCodeAt(0);
    if (i !== lt && i !== he)
      return 0;
  }
  return Se(e, n ? 0 : 1, n, o);
}
function Ar(e, t) {
  let r = 0;
  if (!e)
    return 0;
  if (e.type === 10)
    return Se(e, 0, tl, r);
  if (e.type === 1 && e.value.charCodeAt(0) === he) {
    if (!de(e.value, 1, vr))
      return 0;
    switch (e.value.length) {
      case 2:
        return Sr(t(++r), r, t);
      case 3:
        return e.value.charCodeAt(2) !== he ? 0 : (r = st(t(++r), r, t), e = t(r), Se(e, 0, We, r));
      default:
        return e.value.charCodeAt(2) !== he ? 0 : Se(e, 3, We, r);
    }
  } else if (e.type === 1 || Cr(e, lt) && t(r + 1).type === 1) {
    if (e.type !== 1 && (e = t(++r)), e === null || !de(e.value, 0, vr))
      return 0;
    switch (e.value.length) {
      case 1:
        return Sr(t(++r), r, t);
      case 2:
        return e.value.charCodeAt(1) !== he ? 0 : (r = st(t(++r), r, t), e = t(r), Se(e, 0, We, r));
      default:
        return e.value.charCodeAt(1) !== he ? 0 : Se(e, 2, We, r);
    }
  } else if (e.type === 12) {
    let n = e.value.charCodeAt(0), o = n === lt || n === he ? 1 : 0, i = o;
    for (; i < e.value.length && B(e.value.charCodeAt(i)); i++)
      ;
    return i === o || !de(e.value, i, vr) ? 0 : i + 1 === e.value.length ? Sr(t(++r), r, t) : e.value.charCodeAt(i + 1) !== he ? 0 : i + 2 === e.value.length ? (r = st(t(++r), r, t), e = t(r), Se(e, 0, We, r)) : Se(e, i + 2, We, r);
  }
  return 0;
}
var rl = 43;
var Di = 45;
var Oi = 63;
var nl = 117;
function Tr(e, t) {
  return e !== null && e.type === 9 && e.value.charCodeAt(0) === t;
}
function ol(e, t) {
  return e.value.charCodeAt(0) === t;
}
function ct(e, t, r) {
  let n = 0;
  for (let o = t; o < e.value.length; o++) {
    let i = e.value.charCodeAt(o);
    if (i === Di && r && n !== 0)
      return ct(e, t + n + 1, false), 6;
    if (!ee(i) || ++n > 6)
      return 0;
  }
  return n;
}
function Ft(e, t, r) {
  if (!e)
    return 0;
  for (; Tr(r(t), Oi); ) {
    if (++e > 6)
      return 0;
    t++;
  }
  return t;
}
function Er(e, t) {
  let r = 0;
  if (e === null || e.type !== 1 || !de(e.value, 0, nl) || (e = t(++r), e === null))
    return 0;
  if (Tr(e, rl))
    return e = t(++r), e === null ? 0 : e.type === 1 ? Ft(ct(e, 0, true), ++r, t) : Tr(e, Oi) ? Ft(1, ++r, t) : 0;
  if (e.type === 10) {
    let n = ct(e, 1, true);
    return n === 0 ? 0 : (e = t(++r), e === null ? r : e.type === 12 || e.type === 10 ? !ol(e, Di) || !ct(e, 1, false) ? 0 : r + 1 : Ft(n, r, t));
  }
  return e.type === 12 ? Ft(ct(e, 1, true), ++r, t) : 0;
}
var il = ["calc(", "-moz-calc(", "-webkit-calc("];
var Lr = /* @__PURE__ */ new Map([[2, 22], [21, 22], [19, 20], [23, 24]]);
function le(e, t) {
  return t < e.length ? e.charCodeAt(t) : 0;
}
function Ni(e, t) {
  return ge(e, 0, e.length, t);
}
function zi(e, t) {
  for (let r = 0; r < t.length; r++)
    if (Ni(e, t[r]))
      return true;
  return false;
}
function Mi(e, t) {
  return t !== e.length - 2 ? false : le(e, t) === 92 && B(le(e, t + 1));
}
function Bt(e, t, r) {
  if (e && e.type === "Range") {
    let n = Number(r !== void 0 && r !== t.length ? t.substr(0, r) : t);
    if (isNaN(n) || e.min !== null && n < e.min && typeof e.min != "string" || e.max !== null && n > e.max && typeof e.max != "string")
      return true;
  }
  return false;
}
function al(e, t) {
  let r = 0, n = [], o = 0;
  e:
    do {
      switch (e.type) {
        case 24:
        case 22:
        case 20:
          if (e.type !== r)
            break e;
          if (r = n.pop(), n.length === 0) {
            o++;
            break e;
          }
          break;
        case 2:
        case 21:
        case 19:
        case 23:
          n.push(r), r = Lr.get(e.type);
          break;
      }
      o++;
    } while (e = t(o));
  return o;
}
function ie(e) {
  return function(t, r, n) {
    return t === null ? 0 : t.type === 2 && zi(t.value, il) ? al(t, r) : e(t, r, n);
  };
}
function N(e) {
  return function(t) {
    return t === null || t.type !== e ? 0 : 1;
  };
}
function sl(e) {
  if (e === null || e.type !== 1)
    return 0;
  let t = e.value.toLowerCase();
  return zi(t, Rt) || Ni(t, "default") ? 0 : 1;
}
function ll(e) {
  return e === null || e.type !== 1 || le(e.value, 0) !== 45 || le(e.value, 1) !== 45 ? 0 : 1;
}
function cl(e) {
  if (e === null || e.type !== 4)
    return 0;
  let t = e.value.length;
  if (t !== 4 && t !== 5 && t !== 7 && t !== 9)
    return 0;
  for (let r = 1; r < t; r++)
    if (!ee(le(e.value, r)))
      return 0;
  return 1;
}
function ul(e) {
  return e === null || e.type !== 4 || !ze(le(e.value, 1), le(e.value, 2), le(e.value, 3)) ? 0 : 1;
}
function pl(e, t) {
  if (!e)
    return 0;
  let r = 0, n = [], o = 0;
  e:
    do {
      switch (e.type) {
        case 6:
        case 8:
          break e;
        case 24:
        case 22:
        case 20:
          if (e.type !== r)
            break e;
          r = n.pop();
          break;
        case 17:
          if (r === 0)
            break e;
          break;
        case 9:
          if (r === 0 && e.value === "!")
            break e;
          break;
        case 2:
        case 21:
        case 19:
        case 23:
          n.push(r), r = Lr.get(e.type);
          break;
      }
      o++;
    } while (e = t(o));
  return o;
}
function hl(e, t) {
  if (!e)
    return 0;
  let r = 0, n = [], o = 0;
  e:
    do {
      switch (e.type) {
        case 6:
        case 8:
          break e;
        case 24:
        case 22:
        case 20:
          if (e.type !== r)
            break e;
          r = n.pop();
          break;
        case 2:
        case 21:
        case 19:
        case 23:
          n.push(r), r = Lr.get(e.type);
          break;
      }
      o++;
    } while (e = t(o));
  return o;
}
function ye(e) {
  return e && (e = new Set(e)), function(t, r, n) {
    if (t === null || t.type !== 12)
      return 0;
    let o = Te(t.value, 0);
    if (e !== null) {
      let i = t.value.indexOf("\\", o), s = i === -1 || !Mi(t.value, i) ? t.value.substr(o) : t.value.substring(o, i);
      if (e.has(s.toLowerCase()) === false)
        return 0;
    }
    return Bt(n, t.value, o) ? 0 : 1;
  };
}
function ml(e, t, r) {
  return e === null || e.type !== 11 || Bt(r, e.value, e.value.length - 1) ? 0 : 1;
}
function Ri(e) {
  return typeof e != "function" && (e = function() {
    return 0;
  }), function(t, r, n) {
    return t !== null && t.type === 10 && Number(t.value) === 0 ? 1 : e(t, r, n);
  };
}
function fl(e, t, r) {
  if (e === null)
    return 0;
  let n = Te(e.value, 0);
  return !(n === e.value.length) && !Mi(e.value, n) || Bt(r, e.value, n) ? 0 : 1;
}
function dl(e, t, r) {
  if (e === null || e.type !== 10)
    return 0;
  let n = le(e.value, 0) === 43 || le(e.value, 0) === 45 ? 1 : 0;
  for (; n < e.value.length; n++)
    if (!B(le(e.value, n)))
      return 0;
  return Bt(r, e.value, n) ? 0 : 1;
}
var gl = { "ident-token": N(1), "function-token": N(2), "at-keyword-token": N(3), "hash-token": N(4), "string-token": N(5), "bad-string-token": N(6), "url-token": N(7), "bad-url-token": N(8), "delim-token": N(9), "number-token": N(10), "percentage-token": N(11), "dimension-token": N(12), "whitespace-token": N(13), "CDO-token": N(14), "CDC-token": N(15), "colon-token": N(16), "semicolon-token": N(17), "comma-token": N(18), "[-token": N(19), "]-token": N(20), "(-token": N(21), ")-token": N(22), "{-token": N(23), "}-token": N(24) };
var bl = { string: N(5), ident: N(1), percentage: ie(ml), zero: Ri(), number: ie(fl), integer: ie(dl), "custom-ident": sl, "custom-property-name": ll, "hex-color": cl, "id-selector": ul, "an-plus-b": Ar, urange: Er, "declaration-value": pl, "any-value": hl };
function xl(e) {
  let { angle: t, decibel: r, frequency: n, flex: o, length: i, resolution: s, semitones: u2, time: c2 } = e || {};
  return { dimension: ie(ye(null)), angle: ie(ye(t)), decibel: ie(ye(r)), frequency: ie(ye(n)), flex: ie(ye(o)), length: ie(Ri(ye(i))), resolution: ie(ye(s)), semitones: ie(ye(u2)), time: ie(ye(c2)) };
}
function Fi(e) {
  return { ...gl, ...bl, ...xl(e) };
}
var _t = {};
b$1(_t, { angle: () => kl, decibel: () => Al, flex: () => Cl, frequency: () => vl, length: () => yl, resolution: () => Sl, semitones: () => Tl, time: () => wl });
var yl = ["cm", "mm", "q", "in", "pt", "pc", "px", "em", "rem", "ex", "rex", "cap", "rcap", "ch", "rch", "ic", "ric", "lh", "rlh", "vw", "svw", "lvw", "dvw", "vh", "svh", "lvh", "dvh", "vi", "svi", "lvi", "dvi", "vb", "svb", "lvb", "dvb", "vmin", "svmin", "lvmin", "dvmin", "vmax", "svmax", "lvmax", "dvmax", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"];
var kl = ["deg", "grad", "rad", "turn"];
var wl = ["s", "ms"];
var vl = ["hz", "khz"];
var Sl = ["dpi", "dpcm", "dppx", "x"];
var Cl = ["fr"];
var Al = ["db"];
var Tl = ["st"];
var $i = {};
b$1($i, { SyntaxError: () => qt, generate: () => Pe, parse: () => Ge, walk: () => Vt });
function qt(e, t, r) {
  return Object.assign(Ee("SyntaxError", e), { input: t, offset: r, rawMessage: e, message: e + `
  ` + t + `
--` + new Array((r || t.length) + 1).join("-") + "^" });
}
var El = 9;
var Ll = 10;
var Pl = 12;
var Il = 13;
var Dl = 32;
var Ut = class {
  constructor(t) {
    this.str = t, this.pos = 0;
  }
  charCodeAt(t) {
    return t < this.str.length ? this.str.charCodeAt(t) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(t) {
    return this.charCodeAt(this.findWsEnd(t));
  }
  findWsEnd(t) {
    for (; t < this.str.length; t++) {
      let r = this.str.charCodeAt(t);
      if (r !== Il && r !== Ll && r !== Pl && r !== Dl && r !== El)
        break;
    }
    return t;
  }
  substringToPos(t) {
    return this.str.substring(this.pos, this.pos = t);
  }
  eat(t) {
    this.charCode() !== t && this.error("Expect `" + String.fromCharCode(t) + "`"), this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(t) {
    throw new qt(t, this.str, this.pos);
  }
};
var Ol = 9;
var Nl = 10;
var zl = 12;
var Ml = 13;
var Rl = 32;
var Yi = 33;
var Dr = 35;
var Bi = 38;
var jt = 39;
var Gi = 40;
var Fl = 41;
var Vi = 42;
var Or = 43;
var Nr = 44;
var _i = 45;
var zr = 60;
var Ki = 62;
var Ir = 63;
var Bl = 64;
var Gt = 91;
var Mr = 93;
var Wt = 123;
var qi = 124;
var Ui = 125;
var ji = 8734;
var ut = new Uint8Array(128).map((e, t) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(t)) ? 1 : 0);
var Wi = { " ": 1, "&&": 2, "||": 3, "|": 4 };
function Ht(e) {
  return e.substringToPos(e.findWsEnd(e.pos));
}
function He(e) {
  let t = e.pos;
  for (; t < e.str.length; t++) {
    let r = e.str.charCodeAt(t);
    if (r >= 128 || ut[r] === 0)
      break;
  }
  return e.pos === t && e.error("Expect a keyword"), e.substringToPos(t);
}
function Yt(e) {
  let t = e.pos;
  for (; t < e.str.length; t++) {
    let r = e.str.charCodeAt(t);
    if (r < 48 || r > 57)
      break;
  }
  return e.pos === t && e.error("Expect a number"), e.substringToPos(t);
}
function _l(e) {
  let t = e.str.indexOf("'", e.pos + 1);
  return t === -1 && (e.pos = e.str.length, e.error("Expect an apostrophe")), e.substringToPos(t + 1);
}
function Hi(e) {
  let t = null, r = null;
  return e.eat(Wt), t = Yt(e), e.charCode() === Nr ? (e.pos++, e.charCode() !== Ui && (r = Yt(e))) : r = t, e.eat(Ui), { min: Number(t), max: r ? Number(r) : 0 };
}
function ql(e) {
  let t = null, r = false;
  switch (e.charCode()) {
    case Vi:
      e.pos++, t = { min: 0, max: 0 };
      break;
    case Or:
      e.pos++, t = { min: 1, max: 0 };
      break;
    case Ir:
      e.pos++, t = { min: 0, max: 1 };
      break;
    case Dr:
      e.pos++, r = true, e.charCode() === Wt ? t = Hi(e) : e.charCode() === Ir ? (e.pos++, t = { min: 0, max: 0 }) : t = { min: 1, max: 0 };
      break;
    case Wt:
      t = Hi(e);
      break;
    default:
      return null;
  }
  return { type: "Multiplier", comma: r, min: t.min, max: t.max, term: null };
}
function Ye(e, t) {
  let r = ql(e);
  return r !== null ? (r.term = t, e.charCode() === Dr && e.charCodeAt(e.pos - 1) === Or ? Ye(e, r) : r) : t;
}
function Pr(e) {
  let t = e.peek();
  return t === "" ? null : { type: "Token", value: t };
}
function Ul(e) {
  let t;
  return e.eat(zr), e.eat(jt), t = He(e), e.eat(jt), e.eat(Ki), Ye(e, { type: "Property", name: t });
}
function jl(e) {
  let t = null, r = null, n = 1;
  return e.eat(Gt), e.charCode() === _i && (e.peek(), n = -1), n == -1 && e.charCode() === ji ? e.peek() : (t = n * Number(Yt(e)), ut[e.charCode()] !== 0 && (t += He(e))), Ht(e), e.eat(Nr), Ht(e), e.charCode() === ji ? e.peek() : (n = 1, e.charCode() === _i && (e.peek(), n = -1), r = n * Number(Yt(e)), ut[e.charCode()] !== 0 && (r += He(e))), e.eat(Mr), { type: "Range", min: t, max: r };
}
function Wl(e) {
  let t, r = null;
  return e.eat(zr), t = He(e), e.charCode() === Gi && e.nextCharCode() === Fl && (e.pos += 2, t += "()"), e.charCodeAt(e.findWsEnd(e.pos)) === Gt && (Ht(e), r = jl(e)), e.eat(Ki), Ye(e, { type: "Type", name: t, opts: r });
}
function Hl(e) {
  let t = He(e);
  return e.charCode() === Gi ? (e.pos++, { type: "Function", name: t }) : Ye(e, { type: "Keyword", name: t });
}
function Yl(e, t) {
  function r(o, i) {
    return { type: "Group", terms: o, combinator: i, disallowEmpty: false, explicit: false };
  }
  let n;
  for (t = Object.keys(t).sort((o, i) => Wi[o] - Wi[i]); t.length > 0; ) {
    n = t.shift();
    let o = 0, i = 0;
    for (; o < e.length; o++) {
      let s = e[o];
      s.type === "Combinator" && (s.value === n ? (i === -1 && (i = o - 1), e.splice(o, 1), o--) : (i !== -1 && o - i > 1 && (e.splice(i, o - i, r(e.slice(i, o), n)), o = i + 1), i = -1));
    }
    i !== -1 && t.length && e.splice(i, o - i, r(e.slice(i, o), n));
  }
  return n;
}
function Qi(e) {
  let t = [], r = {}, n, o = null, i = e.pos;
  for (; n = Vl(e); )
    n.type !== "Spaces" && (n.type === "Combinator" ? ((o === null || o.type === "Combinator") && (e.pos = i, e.error("Unexpected combinator")), r[n.value] = true) : o !== null && o.type !== "Combinator" && (r[" "] = true, t.push({ type: "Combinator", value: " " })), t.push(n), o = n, i = e.pos);
  return o !== null && o.type === "Combinator" && (e.pos -= i, e.error("Unexpected combinator")), { type: "Group", terms: t, combinator: Yl(t, r) || " ", disallowEmpty: false, explicit: false };
}
function Gl(e) {
  let t;
  return e.eat(Gt), t = Qi(e), e.eat(Mr), t.explicit = true, e.charCode() === Yi && (e.pos++, t.disallowEmpty = true), t;
}
function Vl(e) {
  let t = e.charCode();
  if (t < 128 && ut[t] === 1)
    return Hl(e);
  switch (t) {
    case Mr:
      break;
    case Gt:
      return Ye(e, Gl(e));
    case zr:
      return e.nextCharCode() === jt ? Ul(e) : Wl(e);
    case qi:
      return { type: "Combinator", value: e.substringToPos(e.pos + (e.nextCharCode() === qi ? 2 : 1)) };
    case Bi:
      return e.pos++, e.eat(Bi), { type: "Combinator", value: "&&" };
    case Nr:
      return e.pos++, { type: "Comma" };
    case jt:
      return Ye(e, { type: "String", value: _l(e) });
    case Rl:
    case Ol:
    case Nl:
    case Ml:
    case zl:
      return { type: "Spaces", value: Ht(e) };
    case Bl:
      return t = e.nextCharCode(), t < 128 && ut[t] === 1 ? (e.pos++, { type: "AtKeyword", name: He(e) }) : Pr(e);
    case Vi:
    case Or:
    case Ir:
    case Dr:
    case Yi:
      break;
    case Wt:
      if (t = e.nextCharCode(), t < 48 || t > 57)
        return Pr(e);
      break;
    default:
      return Pr(e);
  }
}
function Ge(e) {
  let t = new Ut(e), r = Qi(t);
  return t.pos !== e.length && t.error("Unexpected input"), r.terms.length === 1 && r.terms[0].type === "Group" ? r.terms[0] : r;
}
var pt = function() {
};
function Xi(e) {
  return typeof e == "function" ? e : pt;
}
function Vt(e, t, r) {
  function n(s) {
    switch (o.call(r, s), s.type) {
      case "Group":
        s.terms.forEach(n);
        break;
      case "Multiplier":
        n(s.term);
        break;
      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;
      default:
        throw new Error("Unknown type: " + s.type);
    }
    i.call(r, s);
  }
  let o = pt, i = pt;
  if (typeof t == "function" ? o = t : t && (o = Xi(t.enter), i = Xi(t.leave)), o === pt && i === pt)
    throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
  n(e);
}
var Kl = { decorator(e) {
  let t = [], r = null;
  return { ...e, node(n) {
    let o = r;
    r = n, e.node.call(this, n), r = o;
  }, emit(n, o, i) {
    t.push({ type: o, value: n, node: i ? null : r });
  }, result() {
    return t;
  } };
} };
function Ql(e) {
  let t = [];
  return ve(e, (r, n, o) => t.push({ type: r, value: e.slice(n, o), node: null })), t;
}
function Zi(e, t) {
  return typeof e == "string" ? Ql(e) : t.generate(e, Kl);
}
var C = { type: "Match" };
var L = { type: "Mismatch" };
var Kt = { type: "DisallowEmpty" };
var Xl = 40;
var $l = 41;
function Z(e, t, r) {
  return t === C && r === L || e === C && t === C && r === C ? e : (e.type === "If" && e.else === L && t === C && (t = e.then, e = e.match), { type: "If", match: e, then: t, else: r });
}
function ea(e) {
  return e.length > 2 && e.charCodeAt(e.length - 2) === Xl && e.charCodeAt(e.length - 1) === $l;
}
function Ji(e) {
  return e.type === "Keyword" || e.type === "AtKeyword" || e.type === "Function" || e.type === "Type" && ea(e.name);
}
function Rr(e, t, r) {
  switch (e) {
    case " ": {
      let n = C;
      for (let o = t.length - 1; o >= 0; o--) {
        let i = t[o];
        n = Z(i, n, L);
      }
      return n;
    }
    case "|": {
      let n = L, o = null;
      for (let i = t.length - 1; i >= 0; i--) {
        let s = t[i];
        if (Ji(s) && (o === null && i > 0 && Ji(t[i - 1]) && (o = /* @__PURE__ */ Object.create(null), n = Z({ type: "Enum", map: o }, C, n)), o !== null)) {
          let u2 = (ea(s.name) ? s.name.slice(0, -1) : s.name).toLowerCase();
          if (!(u2 in o)) {
            o[u2] = s;
            continue;
          }
        }
        o = null, n = Z(s, C, n);
      }
      return n;
    }
    case "&&": {
      if (t.length > 5)
        return { type: "MatchOnce", terms: t, all: true };
      let n = L;
      for (let o = t.length - 1; o >= 0; o--) {
        let i = t[o], s;
        t.length > 1 ? s = Rr(e, t.filter(function(u2) {
          return u2 !== i;
        }), false) : s = C, n = Z(i, s, n);
      }
      return n;
    }
    case "||": {
      if (t.length > 5)
        return { type: "MatchOnce", terms: t, all: false };
      let n = r ? C : L;
      for (let o = t.length - 1; o >= 0; o--) {
        let i = t[o], s;
        t.length > 1 ? s = Rr(e, t.filter(function(u2) {
          return u2 !== i;
        }), true) : s = C, n = Z(i, s, n);
      }
      return n;
    }
  }
}
function Zl(e) {
  let t = C, r = Fr(e.term);
  if (e.max === 0)
    r = Z(r, Kt, L), t = Z(r, null, L), t.then = Z(C, C, t), e.comma && (t.then.else = Z({ type: "Comma", syntax: e }, t, L));
  else
    for (let n = e.min || 1; n <= e.max; n++)
      e.comma && t !== C && (t = Z({ type: "Comma", syntax: e }, t, L)), t = Z(r, Z(C, C, t), L);
  if (e.min === 0)
    t = Z(C, C, t);
  else
    for (let n = 0; n < e.min - 1; n++)
      e.comma && t !== C && (t = Z({ type: "Comma", syntax: e }, t, L)), t = Z(r, t, L);
  return t;
}
function Fr(e) {
  if (typeof e == "function")
    return { type: "Generic", fn: e };
  switch (e.type) {
    case "Group": {
      let t = Rr(e.combinator, e.terms.map(Fr), false);
      return e.disallowEmpty && (t = Z(t, Kt, L)), t;
    }
    case "Multiplier":
      return Zl(e);
    case "Type":
    case "Property":
      return { type: e.type, name: e.name, syntax: e };
    case "Keyword":
      return { type: e.type, name: e.name.toLowerCase(), syntax: e };
    case "AtKeyword":
      return { type: e.type, name: "@" + e.name.toLowerCase(), syntax: e };
    case "Function":
      return { type: e.type, name: e.name.toLowerCase() + "(", syntax: e };
    case "String":
      return e.value.length === 3 ? { type: "Token", value: e.value.charAt(1), syntax: e } : { type: e.type, value: e.value.substr(1, e.value.length - 2).replace(/\\'/g, "'"), syntax: e };
    case "Token":
      return { type: e.type, value: e.value, syntax: e };
    case "Comma":
      return { type: e.type, syntax: e };
    default:
      throw new Error("Unknown node type:", e.type);
  }
}
function Qt(e, t) {
  return typeof e == "string" && (e = Ge(e)), { type: "MatchGraph", match: Fr(e), syntax: t || null, source: e };
}
var { hasOwnProperty: ta } = Object.prototype;
var Jl = 0;
var ec = 1;
var _r = 2;
var aa = 3;
var ra = "Match";
var tc = "Mismatch";
var rc = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
var na = 15e3;
function oc(e) {
  let t = null, r = null, n = e;
  for (; n !== null; )
    r = n.prev, n.prev = t, t = n, n = r;
  return t;
}
function Br(e, t) {
  if (e.length !== t.length)
    return false;
  for (let r = 0; r < e.length; r++) {
    let n = t.charCodeAt(r), o = e.charCodeAt(r);
    if (o >= 65 && o <= 90 && (o = o | 32), o !== n)
      return false;
  }
  return true;
}
function ic(e) {
  return e.type !== 9 ? false : e.value !== "?";
}
function oa(e) {
  return e === null ? true : e.type === 18 || e.type === 2 || e.type === 21 || e.type === 19 || e.type === 23 || ic(e);
}
function ia(e) {
  return e === null ? true : e.type === 22 || e.type === 20 || e.type === 24 || e.type === 9 && e.value === "/";
}
function ac(e, t, r) {
  function n() {
    do
      R++, S = R < e.length ? e[R] : null;
    while (S !== null && (S.type === 13 || S.type === 25));
  }
  function o(ae) {
    let fe = R + ae;
    return fe < e.length ? e[fe] : null;
  }
  function i(ae, fe) {
    return { nextState: ae, matchStack: z, syntaxStack: p2, thenStack: m, tokenIndex: R, prev: fe };
  }
  function s(ae) {
    m = { nextState: ae, matchStack: z, syntaxStack: p2, prev: m };
  }
  function u2(ae) {
    f = i(ae, f);
  }
  function c2() {
    z = { type: ec, syntax: t.syntax, token: S, prev: z }, n(), P = null, R > ke && (ke = R);
  }
  function a() {
    p2 = { syntax: t.syntax, opts: t.syntax.opts || p2 !== null && p2.opts || null, prev: p2 }, z = { type: _r, syntax: t.syntax, token: z.token, prev: z };
  }
  function l2() {
    z.type === _r ? z = z.prev : z = { type: aa, syntax: p2.syntax, token: z.token, prev: z }, p2 = p2.prev;
  }
  let p2 = null, m = null, f = null, P = null, te = 0, X = null, S = null, R = -1, ke = 0, z = { type: Jl, syntax: null, token: null, prev: null };
  for (n(); X === null && ++te < na; )
    switch (t.type) {
      case "Match":
        if (m === null) {
          if (S !== null && (R !== e.length - 1 || S.value !== "\\0" && S.value !== "\\9")) {
            t = L;
            break;
          }
          X = ra;
          break;
        }
        if (t = m.nextState, t === Kt)
          if (m.matchStack === z) {
            t = L;
            break;
          } else
            t = C;
        for (; m.syntaxStack !== p2; )
          l2();
        m = m.prev;
        break;
      case "Mismatch":
        if (P !== null && P !== false)
          (f === null || R > f.tokenIndex) && (f = P, P = false);
        else if (f === null) {
          X = tc;
          break;
        }
        t = f.nextState, m = f.thenStack, p2 = f.syntaxStack, z = f.matchStack, R = f.tokenIndex, S = R < e.length ? e[R] : null, f = f.prev;
        break;
      case "MatchGraph":
        t = t.match;
        break;
      case "If":
        t.else !== L && u2(t.else), t.then !== C && s(t.then), t = t.match;
        break;
      case "MatchOnce":
        t = { type: "MatchOnceBuffer", syntax: t, index: 0, mask: 0 };
        break;
      case "MatchOnceBuffer": {
        let Q = t.syntax.terms;
        if (t.index === Q.length) {
          if (t.mask === 0 || t.syntax.all) {
            t = L;
            break;
          }
          t = C;
          break;
        }
        if (t.mask === (1 << Q.length) - 1) {
          t = C;
          break;
        }
        for (; t.index < Q.length; t.index++) {
          let J = 1 << t.index;
          if ((t.mask & J) === 0) {
            u2(t), s({ type: "AddMatchOnce", syntax: t.syntax, mask: t.mask | J }), t = Q[t.index++];
            break;
          }
        }
        break;
      }
      case "AddMatchOnce":
        t = { type: "MatchOnceBuffer", syntax: t.syntax, index: 0, mask: t.mask };
        break;
      case "Enum":
        if (S !== null) {
          let Q = S.value.toLowerCase();
          if (Q.indexOf("\\") !== -1 && (Q = Q.replace(/\\[09].*$/, "")), ta.call(t.map, Q)) {
            t = t.map[Q];
            break;
          }
        }
        t = L;
        break;
      case "Generic": {
        let Q = p2 !== null ? p2.opts : null, J = R + Math.floor(t.fn(S, o, Q));
        if (!isNaN(J) && J > R) {
          for (; R < J; )
            c2();
          t = C;
        } else
          t = L;
        break;
      }
      case "Type":
      case "Property": {
        let Q = t.type === "Type" ? "types" : "properties", J = ta.call(r, Q) ? r[Q][t.name] : null;
        if (!J || !J.match)
          throw new Error("Bad syntax reference: " + (t.type === "Type" ? "<" + t.name + ">" : "<'" + t.name + "'>"));
        if (P !== false && S !== null && t.type === "Type" && (t.name === "custom-ident" && S.type === 1 || t.name === "length" && S.value === "0")) {
          P === null && (P = i(t, f)), t = L;
          break;
        }
        a(), t = J.match;
        break;
      }
      case "Keyword": {
        let Q = t.name;
        if (S !== null) {
          let J = S.value;
          if (J.indexOf("\\") !== -1 && (J = J.replace(/\\[09].*$/, "")), Br(J, Q)) {
            c2(), t = C;
            break;
          }
        }
        t = L;
        break;
      }
      case "AtKeyword":
      case "Function":
        if (S !== null && Br(S.value, t.name)) {
          c2(), t = C;
          break;
        }
        t = L;
        break;
      case "Token":
        if (S !== null && S.value === t.value) {
          c2(), t = C;
          break;
        }
        t = L;
        break;
      case "Comma":
        S !== null && S.type === 18 ? oa(z.token) ? t = L : (c2(), t = ia(S) ? L : C) : t = oa(z.token) || ia(S) ? C : L;
        break;
      case "String":
        let ae = "", fe = R;
        for (; fe < e.length && ae.length < t.value.length; fe++)
          ae += e[fe].value;
        if (Br(ae, t.value)) {
          for (; R < fe; )
            c2();
          t = C;
        } else
          t = L;
        break;
      default:
        throw new Error("Unknown node type: " + t.type);
    }
  switch (X) {
    case null:
      console.warn("[csstree-match] BREAK after " + na + " iterations"), X = rc, z = null;
      break;
    case ra:
      for (; p2 !== null; )
        l2();
      break;
    default:
      z = null;
  }
  return { tokens: e, reason: X, iterations: te, match: z, longestMatch: ke };
}
function qr(e, t, r) {
  let n = ac(e, t, r || {});
  if (n.match === null)
    return n;
  let o = n.match, i = n.match = { syntax: t.syntax || null, match: [] }, s = [i];
  for (o = oc(o).prev; o !== null; ) {
    switch (o.type) {
      case _r:
        i.match.push(i = { syntax: o.syntax, match: [] }), s.push(i);
        break;
      case aa:
        s.pop(), i = s[s.length - 1];
        break;
      default:
        i.match.push({ syntax: o.syntax || null, token: o.token.value, node: o.token.node });
    }
    o = o.prev;
  }
  return n;
}
var jr = {};
b$1(jr, { getTrace: () => sa, isKeyword: () => cc, isProperty: () => lc, isType: () => sc });
function sa(e) {
  function t(o) {
    return o === null ? false : o.type === "Type" || o.type === "Property" || o.type === "Keyword";
  }
  function r(o) {
    if (Array.isArray(o.match)) {
      for (let i = 0; i < o.match.length; i++)
        if (r(o.match[i]))
          return t(o.syntax) && n.unshift(o.syntax), true;
    } else if (o.node === e)
      return n = t(o.syntax) ? [o.syntax] : [], true;
    return false;
  }
  let n = null;
  return this.matched !== null && r(this.matched), n;
}
function sc(e, t) {
  return Ur(this, e, (r) => r.type === "Type" && r.name === t);
}
function lc(e, t) {
  return Ur(this, e, (r) => r.type === "Property" && r.name === t);
}
function cc(e) {
  return Ur(this, e, (t) => t.type === "Keyword");
}
function Ur(e, t, r) {
  let n = sa.call(e, t);
  return n === null ? false : n.some(r);
}
function la(e) {
  return "node" in e ? e.node : la(e.match[0]);
}
function ca(e) {
  return "node" in e ? e.node : ca(e.match[e.match.length - 1]);
}
function Wr(e, t, r, n, o) {
  function i(u2) {
    if (u2.syntax !== null && u2.syntax.type === n && u2.syntax.name === o) {
      let c2 = la(u2), a = ca(u2);
      e.syntax.walk(t, function(l2, p2, m) {
        if (l2 === c2) {
          let f = new D();
          do {
            if (f.appendData(p2.data), p2.data === a)
              break;
            p2 = p2.next;
          } while (p2 !== null);
          s.push({ parent: m, nodes: f });
        }
      });
    }
    Array.isArray(u2.match) && u2.match.forEach(i);
  }
  let s = [];
  return r.matched !== null && i(r.matched), s;
}
var { hasOwnProperty: ht } = Object.prototype;
function Hr(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e && e >= 0;
}
function ua(e) {
  return Boolean(e) && Hr(e.offset) && Hr(e.line) && Hr(e.column);
}
function uc(e, t) {
  return function(n, o) {
    if (!n || n.constructor !== Object)
      return o(n, "Type of node should be an Object");
    for (let i in n) {
      let s = true;
      if (ht.call(n, i) !== false) {
        if (i === "type")
          n.type !== e && o(n, "Wrong node type `" + n.type + "`, expected `" + e + "`");
        else if (i === "loc") {
          if (n.loc === null)
            continue;
          if (n.loc && n.loc.constructor === Object)
            if (typeof n.loc.source != "string")
              i += ".source";
            else if (!ua(n.loc.start))
              i += ".start";
            else if (!ua(n.loc.end))
              i += ".end";
            else
              continue;
          s = false;
        } else if (t.hasOwnProperty(i)) {
          s = false;
          for (let u2 = 0; !s && u2 < t[i].length; u2++) {
            let c2 = t[i][u2];
            switch (c2) {
              case String:
                s = typeof n[i] == "string";
                break;
              case Boolean:
                s = typeof n[i] == "boolean";
                break;
              case null:
                s = n[i] === null;
                break;
              default:
                typeof c2 == "string" ? s = n[i] && n[i].type === c2 : Array.isArray(c2) && (s = n[i] instanceof D);
            }
          }
        } else
          o(n, "Unknown field `" + i + "` for " + e + " node type");
        s || o(n, "Bad value for `" + e + "." + i + "`");
      }
    }
    for (let i in t)
      ht.call(t, i) && ht.call(n, i) === false && o(n, "Field `" + e + "." + i + "` is missed");
  };
}
function pc(e, t) {
  let r = t.structure, n = { type: String, loc: true }, o = { type: '"' + e + '"' };
  for (let i in r) {
    if (ht.call(r, i) === false)
      continue;
    let s = [], u2 = n[i] = Array.isArray(r[i]) ? r[i].slice() : [r[i]];
    for (let c2 = 0; c2 < u2.length; c2++) {
      let a = u2[c2];
      if (a === String || a === Boolean)
        s.push(a.name);
      else if (a === null)
        s.push("null");
      else if (typeof a == "string")
        s.push("<" + a + ">");
      else if (Array.isArray(a))
        s.push("List");
      else
        throw new Error("Wrong value `" + a + "` in `" + e + "." + i + "` structure definition");
    }
    o[i] = s.join(" | ");
  }
  return { docs: o, check: uc(e, n) };
}
function pa(e) {
  let t = {};
  if (e.node) {
    for (let r in e.node)
      if (ht.call(e.node, r)) {
        let n = e.node[r];
        if (n.structure)
          t[r] = pc(r, n);
        else
          throw new Error("Missed `structure` field in `" + r + "` node type definition");
      }
  }
  return t;
}
var hc = Qt(Rt.join(" | "));
function Yr(e, t, r) {
  let n = {};
  for (let o in e)
    e[o].syntax && (n[o] = r ? e[o].syntax : Pe(e[o].syntax, { compact: t }));
  return n;
}
function mc(e, t, r) {
  let n = {};
  for (let [o, i] of Object.entries(e))
    n[o] = { prelude: i.prelude && (r ? i.prelude.syntax : Pe(i.prelude.syntax, { compact: t })), descriptors: i.descriptors && Yr(i.descriptors, t, r) };
  return n;
}
function fc(e) {
  for (let t = 0; t < e.length; t++)
    if (e[t].value.toLowerCase() === "var(")
      return true;
  return false;
}
function ce(e, t, r) {
  return { matched: e, iterations: r, error: t, ...jr };
}
function Ve(e, t, r, n) {
  let o = Zi(r, e.syntax), i;
  return fc(o) ? ce(null, new Error("Matching for a tree with var() is not supported")) : (n && (i = qr(o, e.cssWideKeywordsSyntax, e)), (!n || !i.match) && (i = qr(o, t.match, e), !i.match) ? ce(null, new Ii(i.reason, t.syntax, r, i), i.iterations) : ce(i.match, null, i.iterations));
}
var Ke = class {
  constructor(t, r, n) {
    if (this.cssWideKeywordsSyntax = hc, this.syntax = r, this.generic = false, this.units = { ..._t }, this.atrules = /* @__PURE__ */ Object.create(null), this.properties = /* @__PURE__ */ Object.create(null), this.types = /* @__PURE__ */ Object.create(null), this.structure = n || pa(t), t) {
      if (t.units)
        for (let o of Object.keys(_t))
          Array.isArray(t.units[o]) && (this.units[o] = t.units[o]);
      if (t.types)
        for (let o in t.types)
          this.addType_(o, t.types[o]);
      if (t.generic) {
        this.generic = true;
        for (let [o, i] of Object.entries(Fi(this.units)))
          this.addType_(o, i);
      }
      if (t.atrules)
        for (let o in t.atrules)
          this.addAtrule_(o, t.atrules[o]);
      if (t.properties)
        for (let o in t.properties)
          this.addProperty_(o, t.properties[o]);
    }
  }
  checkStructure(t) {
    function r(i, s) {
      o.push({ node: i, message: s });
    }
    let n = this.structure, o = [];
    return this.syntax.walk(t, function(i) {
      n.hasOwnProperty(i.type) ? n[i.type].check(i, r) : r(i, "Unknown node type `" + i.type + "`");
    }), o.length ? o : false;
  }
  createDescriptor(t, r, n, o = null) {
    let i = { type: r, name: n }, s = { type: r, name: n, parent: o, serializable: typeof t == "string" || t && typeof t.type == "string", syntax: null, match: null };
    return typeof t == "function" ? s.match = Qt(t, i) : (typeof t == "string" ? Object.defineProperty(s, "syntax", { get() {
      return Object.defineProperty(s, "syntax", { value: Ge(t) }), s.syntax;
    } }) : s.syntax = t, Object.defineProperty(s, "match", { get() {
      return Object.defineProperty(s, "match", { value: Qt(s.syntax, i) }), s.match;
    } })), s;
  }
  addAtrule_(t, r) {
    !r || (this.atrules[t] = { type: "Atrule", name: t, prelude: r.prelude ? this.createDescriptor(r.prelude, "AtrulePrelude", t) : null, descriptors: r.descriptors ? Object.keys(r.descriptors).reduce((n, o) => (n[o] = this.createDescriptor(r.descriptors[o], "AtruleDescriptor", o, t), n), /* @__PURE__ */ Object.create(null)) : null });
  }
  addProperty_(t, r) {
    !r || (this.properties[t] = this.createDescriptor(r, "Property", t));
  }
  addType_(t, r) {
    !r || (this.types[t] = this.createDescriptor(r, "Type", t));
  }
  checkAtruleName(t) {
    if (!this.getAtrule(t))
      return new Ue("Unknown at-rule", "@" + t);
  }
  checkAtrulePrelude(t, r) {
    let n = this.checkAtruleName(t);
    if (n)
      return n;
    let o = this.getAtrule(t);
    if (!o.prelude && r)
      return new SyntaxError("At-rule `@" + t + "` should not contain a prelude");
    if (o.prelude && !r && !Ve(this, o.prelude, "", false).matched)
      return new SyntaxError("At-rule `@" + t + "` should contain a prelude");
  }
  checkAtruleDescriptorName(t, r) {
    let n = this.checkAtruleName(t);
    if (n)
      return n;
    let o = this.getAtrule(t), i = zt(r);
    if (!o.descriptors)
      return new SyntaxError("At-rule `@" + t + "` has no known descriptors");
    if (!o.descriptors[i.name] && !o.descriptors[i.basename])
      return new Ue("Unknown at-rule descriptor", r);
  }
  checkPropertyName(t) {
    if (!this.getProperty(t))
      return new Ue("Unknown property", t);
  }
  matchAtrulePrelude(t, r) {
    let n = this.checkAtrulePrelude(t, r);
    if (n)
      return ce(null, n);
    let o = this.getAtrule(t);
    return o.prelude ? Ve(this, o.prelude, r || "", false) : ce(null, null);
  }
  matchAtruleDescriptor(t, r, n) {
    let o = this.checkAtruleDescriptorName(t, r);
    if (o)
      return ce(null, o);
    let i = this.getAtrule(t), s = zt(r);
    return Ve(this, i.descriptors[s.name] || i.descriptors[s.basename], n, false);
  }
  matchDeclaration(t) {
    return t.type !== "Declaration" ? ce(null, new Error("Not a Declaration node")) : this.matchProperty(t.property, t.value);
  }
  matchProperty(t, r) {
    if (kr(t).custom)
      return ce(null, new Error("Lexer matching doesn't applicable for custom properties"));
    let n = this.checkPropertyName(t);
    return n ? ce(null, n) : Ve(this, this.getProperty(t), r, true);
  }
  matchType(t, r) {
    let n = this.getType(t);
    return n ? Ve(this, n, r, false) : ce(null, new Ue("Unknown type", t));
  }
  match(t, r) {
    return typeof t != "string" && (!t || !t.type) ? ce(null, new Ue("Bad syntax")) : ((typeof t == "string" || !t.match) && (t = this.createDescriptor(t, "Type", "anonymous")), Ve(this, t, r, false));
  }
  findValueFragments(t, r, n, o) {
    return Wr(this, r, this.matchProperty(t, r), n, o);
  }
  findDeclarationValueFragments(t, r, n) {
    return Wr(this, t.value, this.matchDeclaration(t), r, n);
  }
  findAllFragments(t, r, n) {
    let o = [];
    return this.syntax.walk(t, { visit: "Declaration", enter: (i) => {
      o.push.apply(o, this.findDeclarationValueFragments(i, r, n));
    } }), o;
  }
  getAtrule(t, r = true) {
    let n = zt(t);
    return (n.vendor && r ? this.atrules[n.name] || this.atrules[n.basename] : this.atrules[n.name]) || null;
  }
  getAtrulePrelude(t, r = true) {
    let n = this.getAtrule(t, r);
    return n && n.prelude || null;
  }
  getAtruleDescriptor(t, r) {
    return this.atrules.hasOwnProperty(t) && this.atrules.declarators && this.atrules[t].declarators[r] || null;
  }
  getProperty(t, r = true) {
    let n = kr(t);
    return (n.vendor && r ? this.properties[n.name] || this.properties[n.basename] : this.properties[n.name]) || null;
  }
  getType(t) {
    return hasOwnProperty.call(this.types, t) ? this.types[t] : null;
  }
  validate() {
    function t(o, i, s, u2) {
      if (s.has(i))
        return s.get(i);
      s.set(i, false), u2.syntax !== null && Vt(u2.syntax, function(c2) {
        if (c2.type !== "Type" && c2.type !== "Property")
          return;
        let a = c2.type === "Type" ? o.types : o.properties, l2 = c2.type === "Type" ? r : n;
        (!hasOwnProperty.call(a, c2.name) || t(o, c2.name, l2, a[c2.name])) && s.set(i, true);
      }, this);
    }
    let r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    for (let o in this.types)
      t(this, o, r, this.types[o]);
    for (let o in this.properties)
      t(this, o, n, this.properties[o]);
    return r = [...r.keys()].filter((o) => r.get(o)), n = [...n.keys()].filter((o) => n.get(o)), r.length || n.length ? { types: r, properties: n } : null;
  }
  dump(t, r) {
    return { generic: this.generic, units: this.units, types: Yr(this.types, !r, t), properties: Yr(this.properties, !r, t), atrules: mc(this.atrules, !r, t) };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
};
function Gr(e, t) {
  return typeof t == "string" && /^\s*\|/.test(t) ? typeof e == "string" ? e + t : t.replace(/^\s*\|\s*/, "") : t || null;
}
function ha(e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let [n, o] of Object.entries(e))
    if (o) {
      r[n] = {};
      for (let i of Object.keys(o))
        t.includes(i) && (r[n][i] = o[i]);
    }
  return r;
}
function mt(e, t) {
  let r = { ...e };
  for (let [n, o] of Object.entries(t))
    switch (n) {
      case "generic":
        r[n] = Boolean(o);
        break;
      case "units":
        r[n] = { ...e[n] };
        for (let [i, s] of Object.entries(o))
          r[n][i] = Array.isArray(s) ? s : [];
        break;
      case "atrules":
        r[n] = { ...e[n] };
        for (let [i, s] of Object.entries(o)) {
          let u2 = r[n][i] || {}, c2 = r[n][i] = { prelude: u2.prelude || null, descriptors: { ...u2.descriptors } };
          if (!!s) {
            c2.prelude = s.prelude ? Gr(c2.prelude, s.prelude) : c2.prelude || null;
            for (let [a, l2] of Object.entries(s.descriptors || {}))
              c2.descriptors[a] = l2 ? Gr(c2.descriptors[a], l2) : null;
            Object.keys(c2.descriptors).length || (c2.descriptors = null);
          }
        }
        break;
      case "types":
      case "properties":
        r[n] = { ...e[n] };
        for (let [i, s] of Object.entries(o))
          r[n][i] = Gr(r[n][i], s);
        break;
      case "scope":
        r[n] = { ...e[n] };
        for (let [i, s] of Object.entries(o))
          r[n][i] = { ...r[n][i], ...s };
        break;
      case "parseContext":
        r[n] = { ...e[n], ...o };
        break;
      case "atrule":
      case "pseudo":
        r[n] = { ...e[n], ...ha(o, ["parse"]) };
        break;
      case "node":
        r[n] = { ...e[n], ...ha(o, ["name", "structure", "parse", "generate", "walkContext"]) };
        break;
    }
  return r;
}
function ma(e) {
  let t = $o(e), r = Li(e), n = vi(e), { fromPlainObject: o, toPlainObject: i } = Si(r), s = { lexer: null, createLexer: (u2) => new Ke(u2, s, s.lexer.structure), tokenize: ve, parse: t, generate: n, walk: r, find: r.find, findLast: r.findLast, findAll: r.findAll, fromPlainObject: o, toPlainObject: i, fork(u2) {
    let c2 = mt({}, e);
    return ma(typeof u2 == "function" ? u2(c2, Object.assign) : mt(c2, u2));
  } };
  return s.lexer = new Ke({ generic: true, units: e.units, types: e.types, atrules: e.atrules, properties: e.properties, node: e.node }, s), s;
}
var Vr = (e) => ma(mt({}, e));
var fa = { generic: true, units: { angle: ["deg", "grad", "rad", "turn"], decibel: ["db"], flex: ["fr"], frequency: ["hz", "khz"], length: ["cm", "mm", "q", "in", "pt", "pc", "px", "em", "rem", "ex", "rex", "cap", "rcap", "ch", "rch", "ic", "ric", "lh", "rlh", "vw", "svw", "lvw", "dvw", "vh", "svh", "lvh", "dvh", "vi", "svi", "lvi", "dvi", "vb", "svb", "lvb", "dvb", "vmin", "svmin", "lvmin", "dvmin", "vmax", "svmax", "lvmax", "dvmax", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"], resolution: ["dpi", "dpcm", "dppx", "x"], semitones: ["st"], time: ["s", "ms"] }, types: { "abs()": "abs( <calc-sum> )", "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large", "acos()": "acos( <calc-sum> )", "alpha-value": "<number>|<percentage>", "angle-percentage": "<angle>|<percentage>", "angular-color-hint": "<angle-percentage>", "angular-color-stop": "<color>&&<color-stop-angle>?", "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>", "animateable-feature": "scroll-position|contents|<custom-ident>", "asin()": "asin( <calc-sum> )", "atan()": "atan( <calc-sum> )", "atan2()": "atan2( <calc-sum> , <calc-sum> )", attachment: "scroll|fixed|local", "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )", "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='", "attr-modifier": "i|s", "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'", "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )", "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?", axis: "block|inline|vertical|horizontal", "baseline-position": "[first|last]? baseline", "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>|<path()>", "bg-image": "none|<image>", "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>", "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]", "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain", "blur()": "blur( <length> )", "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity", box: "border-box|padding-box|content-box", "brightness()": "brightness( <number-percentage> )", "calc()": "calc( <calc-sum> )", "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*", "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*", "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )", "calc-constant": "e|pi|infinity|-infinity|NaN", "cf-final-image": "<image>|<color>", "cf-mixing-image": "<percentage>?&&<image>", "circle()": "circle( [<shape-radius>]? [at <position>]? )", "clamp()": "clamp( <calc-sum>#{3} )", "class-selector": "'.' <ident-token>", "clip-source": "<url>", color: "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>", "color-stop": "<color-stop-length>|<color-stop-angle>", "color-stop-angle": "<angle-percentage>{1,2}", "color-stop-length": "<length-percentage>{1,2}", "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>", combinator: "'>'|'+'|'~'|['||']", "common-lig-values": "[common-ligatures|no-common-ligatures]", "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button", "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor", "compositing-operator": "add|subtract|intersect|exclude", "compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!", "compound-selector-list": "<compound-selector>#", "complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*", "complex-selector-list": "<complex-selector>#", "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )", "contextual-alt-values": "[contextual|no-contextual]", "content-distribution": "space-between|space-around|space-evenly|stretch", "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+", "content-position": "center|start|end|flex-start|flex-end", "content-replacement": "<image>", "contrast()": "contrast( [<number-percentage>] )", "cos()": "cos( <calc-sum> )", counter: "<counter()>|<counters()>", "counter()": "counter( <counter-name> , <counter-style>? )", "counter-name": "<custom-ident>", "counter-style": "<counter-style-name>|symbols( )", "counter-style-name": "<custom-ident>", "counters()": "counters( <counter-name> , <string> , <counter-style>? )", "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )", "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )", "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText", "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]", "display-box": "contents|none", "display-inside": "flow|flow-root|table|flex|grid|ruby", "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container", "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid", "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item", "display-outside": "block|inline|run-in", "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )", "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]", "east-asian-width-values": "[full-width|proportional-width]", "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )", "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )", "ending-shape": "circle|ellipse", "env()": "env( <custom-ident> , <declaration-value>? )", "exp()": "exp( <calc-sum> )", "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?", "family-name": "<string>|<custom-ident>+", "feature-tag-value": "<string> [<integer>|on|off]?", "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation", "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'", "feature-value-block-list": "<feature-value-block>+", "feature-value-declaration": "<custom-ident> : <integer>+ ;", "feature-value-declaration-list": "<feature-value-declaration>", "feature-value-name": "<custom-ident>", "fill-rule": "nonzero|evenodd", "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>", "filter-function-list": "[<filter-function>|<url>]+", "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>", "fixed-breadth": "<length-percentage>", "fixed-repeat": "repeat( [<integer [1,∞]>] , [<line-names>? <fixed-size>]+ <line-names>? )", "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )", "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>", "font-variant-css21": "[normal|small-caps]", "font-weight-absolute": "normal|bold|<number [1,1000]>", "frequency-percentage": "<frequency>|<percentage>", "general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )", "generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system", "generic-name": "serif|sans-serif|cursive|fantasy|monospace", "geometry-box": "<shape-box>|fill-box|stroke-box|view-box", gradient: "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>", "grayscale()": "grayscale( <number-percentage> )", "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]", "historical-lig-values": "[historical-ligatures|no-historical-ligatures]", "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )", "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )", hue: "<number>|<angle>", "hue-rotate()": "hue-rotate( <angle> )", "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )", "hypot()": "hypot( <calc-sum># )", image: "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>", "image()": "image( <image-tags>? [<image-src>? , <color>?]! )", "image-set()": "image-set( <image-set-option># )", "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]", "image-src": "<url>|<string>", "image-tags": "ltr|rtl", "inflexible-breadth": "<length-percentage>|min-content|max-content|auto", "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )", "invert()": "invert( <number-percentage> )", "keyframes-name": "<custom-ident>|<string>", "keyframe-block": "<keyframe-selector># { <declaration-list> }", "keyframe-block-list": "<keyframe-block>+", "keyframe-selector": "from|to|<percentage>", "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )", "layer()": "layer( <layer-name> )", "layer-name": "<ident> ['.' <ident>]*", "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )", "leader()": "leader( <leader-type> )", "leader-type": "dotted|solid|space|<string>", "length-percentage": "<length>|<percentage>", "line-names": "'[' <custom-ident>* ']'", "line-name-list": "[<line-names>|<name-repeat>]+", "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset", "line-width": "<length>|thin|medium|thick", "linear-color-hint": "<length-percentage>", "linear-color-stop": "<color> <color-stop-length>?", "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )", "log()": "log( <calc-sum> , <calc-sum>? )", "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>", "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?", "mask-reference": "none|<image>|<mask-source>", "mask-source": "<url>", "masking-mode": "alpha|luminance|match-source", "matrix()": "matrix( <number>#{6} )", "matrix3d()": "matrix3d( <number>#{16} )", "max()": "max( <calc-sum># )", "media-and": "<media-in-parens> [and <media-in-parens>]+", "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>", "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>", "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )", "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>", "media-not": "not <media-in-parens>", "media-or": "<media-in-parens> [or <media-in-parens>]+", "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?", "media-query-list": "<media-query>#", "media-type": "<ident>", "mf-boolean": "<mf-name>", "mf-name": "<ident>", "mf-plain": "<mf-name> : <mf-value>", "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>", "mf-value": "<number>|<dimension>|<ident>|<ratio>", "min()": "min( <calc-sum># )", "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )", "mod()": "mod( <calc-sum> , <calc-sum> )", "name-repeat": "repeat( [<integer [1,∞]>|auto-fill] , <line-names>+ )", "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>", "namespace-prefix": "<ident>", "ns-prefix": "[<ident-token>|'*']? '|'", "number-percentage": "<number>|<percentage>", "numeric-figure-values": "[lining-nums|oldstyle-nums]", "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]", "numeric-spacing-values": "[proportional-nums|tabular-nums]", nth: "<an-plus-b>|even|odd", "opacity()": "opacity( [<number-percentage>] )", "overflow-position": "unsafe|safe", "outline-radius": "<length>|<percentage>", "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>", "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'", "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom", "page-selector-list": "[<page-selector>#]?", "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*", "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger", "path()": "path( [<fill-rule> ,]? <string> )", "paint()": "paint( <ident> , <declaration-value>? )", "perspective()": "perspective( [<length [0,∞]>|none] )", "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )", position: "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]", "pow()": "pow( <calc-sum> , <calc-sum> )", "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'", "pseudo-element-selector": "':' <pseudo-class-selector>", "pseudo-page": ": [left|right|first|blank]", quote: "open-quote|close-quote|no-open-quote|no-close-quote", "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )", ratio: "<number [0,∞]> [/ <number [0,∞]>]?", "relative-selector": "<combinator>? <complex-selector>", "relative-selector-list": "<relative-selector>#", "relative-size": "larger|smaller", "rem()": "rem( <calc-sum> , <calc-sum> )", "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}", "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )", "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )", "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )", "reversed-counter-name": "reversed( <counter-name> )", "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )", "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )", "rotate()": "rotate( [<angle>|<zero>] )", "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )", "rotateX()": "rotateX( [<angle>|<zero>] )", "rotateY()": "rotateY( [<angle>|<zero>] )", "rotateZ()": "rotateZ( [<angle>|<zero>] )", "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )", "rounding-strategy": "nearest|up|down|to-zero", "saturate()": "saturate( <number-percentage> )", "scale()": "scale( [<number>|<percentage>]#{1,2} )", "scale3d()": "scale3d( [<number>|<percentage>]#{3} )", "scaleX()": "scaleX( [<number>|<percentage>] )", "scaleY()": "scaleY( [<number>|<percentage>] )", "scaleZ()": "scaleZ( [<number>|<percentage>] )", scroller: "root|nearest", "self-position": "center|start|end|self-start|self-end|flex-start|flex-end", "shape-radius": "<length-percentage>|closest-side|farthest-side", "sign()": "sign( <calc-sum> )", "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )", "skewX()": "skewX( [<angle>|<zero>] )", "skewY()": "skewY( [<angle>|<zero>] )", "sepia()": "sepia( <number-percentage> )", shadow: "inset?&&<length>{2,4}&&<color>?", "shadow-t": "[<length>{2,3}&&<color>?]", shape: "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )", "shape-box": "<box>|margin-box", "side-or-corner": "[left|right]||[top|bottom]", "sin()": "sin( <calc-sum> )", "single-animation": "<time>||<easing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]", "single-animation-direction": "normal|reverse|alternate|alternate-reverse", "single-animation-fill-mode": "none|forwards|backwards|both", "single-animation-iteration-count": "infinite|<number>", "single-animation-play-state": "running|paused", "single-animation-timeline": "auto|none|<timeline-name>|scroll( <axis>? <scroller>? )", "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>", "single-transition-property": "all|<custom-ident>", size: "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}", "sqrt()": "sqrt( <calc-sum> )", "step-position": "jump-start|jump-end|jump-none|jump-both|start|end", "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )", "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>", "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*", "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>", "supports-feature": "<supports-decl>|<supports-selector-fn>", "supports-decl": "( <declaration> )", "supports-selector-fn": "selector( <complex-selector> )", symbol: "<string>|<image>|<custom-ident>", "tan()": "tan( <calc-sum> )", target: "<target-counter()>|<target-counters()>|<target-text()>", "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )", "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )", "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )", "time-percentage": "<time>|<percentage>", "timeline-name": "<custom-ident>|<string>", "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>", "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto", "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?", "track-repeat": "repeat( [<integer [1,∞]>] , [<line-names>? <track-size>]+ <line-names>? )", "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )", "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>", "transform-list": "<transform-function>+", "translate()": "translate( <length-percentage> , <length-percentage>? )", "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )", "translateX()": "translateX( <length-percentage> )", "translateY()": "translateY( <length-percentage> )", "translateZ()": "translateZ( <length> )", "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%", "type-selector": "<wq-name>|<ns-prefix>? '*'", "var()": "var( <custom-property-name> , <declaration-value>? )", "viewport-length": "auto|<length-percentage>", "visual-box": "content-box|padding-box|border-box", "wq-name": "<ns-prefix>? <ident-token>", "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>", "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )", "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )", "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>", "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )", "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )", "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>", "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover", "-legacy-radial-gradient-shape": "circle|ellipse", "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body", "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text", "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast", "-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable", "-non-standard-width": "fill-available|min-intrinsic|intrinsic|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content", "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )", "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )", "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]", "-webkit-gradient-radius": "<length>|<percentage>", "-webkit-gradient-type": "linear|radial", "-webkit-mask-box-repeat": "repeat|stretch|round", "-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text", "-ms-filter-function-list": "<-ms-filter-function>+", "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>", "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]", "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )", "-ms-filter": "<string>", age: "child|young|old", "attr-name": "<wq-name>", "attr-fallback": "<any-value>", "bg-clip": "<box>|border|text", bottom: "<length>|auto", "container-name": "<custom-ident>", "container-condition": "not <query-in-parens>|<query-in-parens> [[and <query-in-parens>]*|[or <query-in-parens>]*]", "generic-voice": "[<age>? <gender> <integer>?]", gender: "male|female|neutral", left: "<length>|auto", "mask-image": "<mask-reference>#", paint: "none|<color>|<url> [none|<color>]?|context-fill|context-stroke", right: "<length>|auto", "scroll-timeline-axis": "block|inline|vertical|horizontal", "scroll-timeline-name": "none|<custom-ident>", "single-animation-composition": "replace|add|accumulate", "svg-length": "<percentage>|<length>|<number>", "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb", top: "<length>|auto", x: "<number>", y: "<number>", declaration: "<ident-token> : <declaration-value>? ['!' important]?", "declaration-list": "[<declaration>? ';']* <declaration>?", url: "url( <string> <url-modifier>* )|<url-token>", "url-modifier": "<ident>|<function-token> <any-value> )", "number-zero-one": "<number [0,1]>", "number-one-or-greater": "<number [1,∞]>", "query-in-parens": "( <container-condition> )|( <size-feature> )|style( <style-query> )|<general-enclosed>", "size-feature": "<mf-plain>|<mf-boolean>|<mf-range>", "style-feature": "<declaration>", "style-query": "<style-condition>|<style-feature>", "style-condition": "not <style-in-parens>|<style-in-parens> [[and <style-in-parens>]*|[or <style-in-parens>]*]", "style-in-parens": "( <style-condition> )|( <style-feature> )|<general-enclosed>", "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box" }, properties: { "--*": "<declaration-value>", "-ms-accelerator": "false|true", "-ms-block-progression": "tb|rl|bt|lr", "-ms-content-zoom-chaining": "none|chained", "-ms-content-zooming": "none|zoom", "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>", "-ms-content-zoom-limit-max": "<percentage>", "-ms-content-zoom-limit-min": "<percentage>", "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>", "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )", "-ms-content-zoom-snap-type": "none|proximity|mandatory", "-ms-filter": "<string>", "-ms-flow-from": "[none|<custom-ident>]#", "-ms-flow-into": "[none|<custom-ident>]#", "-ms-grid-columns": "none|<track-list>|<auto-track-list>", "-ms-grid-rows": "none|<track-list>|<auto-track-list>", "-ms-high-contrast-adjust": "auto|none", "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}", "-ms-hyphenate-limit-lines": "no-limit|<integer>", "-ms-hyphenate-limit-zone": "<percentage>|<length>", "-ms-ime-align": "auto|after", "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar", "-ms-scrollbar-3dlight-color": "<color>", "-ms-scrollbar-arrow-color": "<color>", "-ms-scrollbar-base-color": "<color>", "-ms-scrollbar-darkshadow-color": "<color>", "-ms-scrollbar-face-color": "<color>", "-ms-scrollbar-highlight-color": "<color>", "-ms-scrollbar-shadow-color": "<color>", "-ms-scrollbar-track-color": "<color>", "-ms-scroll-chaining": "chained|none", "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>", "-ms-scroll-limit-x-max": "auto|<length>", "-ms-scroll-limit-x-min": "<length>", "-ms-scroll-limit-y-max": "auto|<length>", "-ms-scroll-limit-y-min": "<length>", "-ms-scroll-rails": "none|railed", "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )", "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )", "-ms-scroll-snap-type": "none|proximity|mandatory", "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>", "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>", "-ms-scroll-translation": "none|vertical-to-horizontal", "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space", "-ms-touch-select": "grippers|none", "-ms-user-select": "none|element|text", "-ms-wrap-flow": "auto|both|start|end|maximum|clear", "-ms-wrap-margin": "<length>", "-ms-wrap-through": "wrap|none", "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized", "-moz-binding": "<url>|none", "-moz-border-bottom-colors": "<color>+|none", "-moz-border-left-colors": "<color>+|none", "-moz-border-right-colors": "<color>+|none", "-moz-border-top-colors": "<color>+|none", "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#", "-moz-float-edge": "border-box|content-box|margin-box|padding-box", "-moz-force-broken-image-icon": "0|1", "-moz-image-region": "<shape>|auto", "-moz-orient": "inline|block|horizontal|vertical", "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?", "-moz-outline-radius-bottomleft": "<outline-radius>", "-moz-outline-radius-bottomright": "<outline-radius>", "-moz-outline-radius-topleft": "<outline-radius>", "-moz-outline-radius-topright": "<outline-radius>", "-moz-stack-sizing": "ignore|stretch-to-fit", "-moz-text-blink": "none|blink", "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none", "-moz-user-input": "auto|none|enabled|disabled", "-moz-user-modify": "read-only|read-write|write-only", "-moz-window-dragging": "drag|no-drag", "-moz-window-shadow": "default|menu|tooltip|sheet|none", "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button", "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>", "-webkit-border-before-color": "<color>", "-webkit-border-before-style": "<'border-style'>", "-webkit-border-before-width": "<'border-width'>", "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?", "-webkit-line-clamp": "none|<integer>", "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#", "-webkit-mask-attachment": "<attachment>#", "-webkit-mask-clip": "[<box>|border|padding|content|text]#", "-webkit-mask-composite": "<composite-style>#", "-webkit-mask-image": "<mask-reference>#", "-webkit-mask-origin": "[<box>|border|padding|content]#", "-webkit-mask-position": "<position>#", "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#", "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#", "-webkit-mask-repeat": "<repeat-style>#", "-webkit-mask-repeat-x": "repeat|no-repeat|space|round", "-webkit-mask-repeat-y": "repeat|no-repeat|space|round", "-webkit-mask-size": "<bg-size>#", "-webkit-overflow-scrolling": "auto|touch", "-webkit-tap-highlight-color": "<color>", "-webkit-text-fill-color": "<color>", "-webkit-text-stroke": "<length>||<color>", "-webkit-text-stroke-color": "<color>", "-webkit-text-stroke-width": "<length>", "-webkit-touch-callout": "default|none", "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only", "accent-color": "auto|<color>", "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>", "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]", "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>", "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#", all: "initial|inherit|unset|revert|revert-layer", animation: "<single-animation>#", "animation-composition": "<single-animation-composition>#", "animation-delay": "<time>#", "animation-direction": "<single-animation-direction>#", "animation-duration": "<time>#", "animation-fill-mode": "<single-animation-fill-mode>#", "animation-iteration-count": "<single-animation-iteration-count>#", "animation-name": "[none|<keyframes-name>]#", "animation-play-state": "<single-animation-play-state>#", "animation-timing-function": "<easing-function>#", "animation-timeline": "<single-animation-timeline>#", appearance: "none|auto|textfield|menulist-button|<compat-auto>", "aspect-ratio": "auto|<ratio>", azimuth: "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards", "backdrop-filter": "none|<filter-function-list>", "backface-visibility": "visible|hidden", background: "[<bg-layer> ,]* <final-bg-layer>", "background-attachment": "<attachment>#", "background-blend-mode": "<blend-mode>#", "background-clip": "<bg-clip>#", "background-color": "<color>", "background-image": "<bg-image>#", "background-origin": "<box>#", "background-position": "<bg-position>#", "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#", "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#", "background-repeat": "<repeat-style>#", "background-size": "<bg-size>#", "block-overflow": "clip|ellipsis|<string>", "block-size": "<'width'>", border: "<line-width>||<line-style>||<color>", "border-block": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-color": "<'border-top-color'>{1,2}", "border-block-style": "<'border-top-style'>", "border-block-width": "<'border-top-width'>", "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-end-color": "<'border-top-color'>", "border-block-end-style": "<'border-top-style'>", "border-block-end-width": "<'border-top-width'>", "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-start-color": "<'border-top-color'>", "border-block-start-style": "<'border-top-style'>", "border-block-start-width": "<'border-top-width'>", "border-bottom": "<line-width>||<line-style>||<color>", "border-bottom-color": "<'border-top-color'>", "border-bottom-left-radius": "<length-percentage>{1,2}", "border-bottom-right-radius": "<length-percentage>{1,2}", "border-bottom-style": "<line-style>", "border-bottom-width": "<line-width>", "border-collapse": "collapse|separate", "border-color": "<color>{1,4}", "border-end-end-radius": "<length-percentage>{1,2}", "border-end-start-radius": "<length-percentage>{1,2}", "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>", "border-image-outset": "[<length>|<number>]{1,4}", "border-image-repeat": "[stretch|repeat|round|space]{1,2}", "border-image-slice": "<number-percentage>{1,4}&&fill?", "border-image-source": "none|<image>", "border-image-width": "[<length-percentage>|<number>|auto]{1,4}", "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-color": "<'border-top-color'>{1,2}", "border-inline-style": "<'border-top-style'>", "border-inline-width": "<'border-top-width'>", "border-inline-end-color": "<'border-top-color'>", "border-inline-end-style": "<'border-top-style'>", "border-inline-end-width": "<'border-top-width'>", "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-start-color": "<'border-top-color'>", "border-inline-start-style": "<'border-top-style'>", "border-inline-start-width": "<'border-top-width'>", "border-left": "<line-width>||<line-style>||<color>", "border-left-color": "<color>", "border-left-style": "<line-style>", "border-left-width": "<line-width>", "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?", "border-right": "<line-width>||<line-style>||<color>", "border-right-color": "<color>", "border-right-style": "<line-style>", "border-right-width": "<line-width>", "border-spacing": "<length> <length>?", "border-start-end-radius": "<length-percentage>{1,2}", "border-start-start-radius": "<length-percentage>{1,2}", "border-style": "<line-style>{1,4}", "border-top": "<line-width>||<line-style>||<color>", "border-top-color": "<color>", "border-top-left-radius": "<length-percentage>{1,2}", "border-top-right-radius": "<length-percentage>{1,2}", "border-top-style": "<line-style>", "border-top-width": "<line-width>", "border-width": "<line-width>{1,4}", bottom: "<length>|<percentage>|auto", "box-align": "start|center|end|baseline|stretch", "box-decoration-break": "slice|clone", "box-direction": "normal|reverse|inherit", "box-flex": "<number>", "box-flex-group": "<integer>", "box-lines": "single|multiple", "box-ordinal-group": "<integer>", "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit", "box-pack": "start|center|end|justify", "box-shadow": "none|<shadow>#", "box-sizing": "content-box|border-box", "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region", "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region", "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region", "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end", caret: "<'caret-color'>||<'caret-shape'>", "caret-color": "auto|<color>", "caret-shape": "auto|bar|block|underscore", clear: "none|left|right|both|inline-start|inline-end", clip: "<shape>|auto", "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none", color: "<color>", "print-color-adjust": "economy|exact", "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?", "column-count": "<integer>|auto", "column-fill": "auto|balance|balance-all", "column-gap": "normal|<length-percentage>", "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>", "column-rule-color": "<color>", "column-rule-style": "<'border-style'>", "column-rule-width": "<'border-width'>", "column-span": "none|all", "column-width": "<length>|auto", columns: "<'column-width'>||<'column-count'>", contain: "none|strict|content|[[size||inline-size]||layout||style||paint]", "contain-intrinsic-size": "[none|<length>|auto <length>]{1,2}", "contain-intrinsic-block-size": "none|<length>|auto <length>", "contain-intrinsic-height": "none|<length>|auto <length>", "contain-intrinsic-inline-size": "none|<length>|auto <length>", "contain-intrinsic-width": "none|<length>|auto <length>", content: "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?", "content-visibility": "visible|auto|hidden", "counter-increment": "[<counter-name> <integer>?]+|none", "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none", "counter-set": "[<counter-name> <integer>?]+|none", cursor: "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]", direction: "ltr|rtl", display: "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>", "empty-cells": "show|hide", filter: "none|<filter-function-list>|<-ms-filter-function-list>", flex: "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]", "flex-basis": "content|<'width'>", "flex-direction": "row|row-reverse|column|column-reverse", "flex-flow": "<'flex-direction'>||<'flex-wrap'>", "flex-grow": "<number>", "flex-shrink": "<number>", "flex-wrap": "nowrap|wrap|wrap-reverse", float: "left|right|none|inline-start|inline-end", font: "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar", "font-family": "[<family-name>|<generic-family>]#", "font-feature-settings": "normal|<feature-tag-value>#", "font-kerning": "auto|normal|none", "font-language-override": "normal|<string>", "font-optical-sizing": "auto|none", "font-variation-settings": "normal|[<string> <number>]#", "font-size": "<absolute-size>|<relative-size>|<length-percentage>", "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]", "font-smooth": "auto|never|always|<absolute-size>|<length>", "font-stretch": "<font-stretch-absolute>", "font-style": "normal|italic|oblique <angle>?", "font-synthesis": "none|[weight||style||small-caps]", "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]", "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]", "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps", "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]", "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]", "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]", "font-variant-position": "normal|sub|super", "font-weight": "<font-weight-absolute>|bolder|lighter", "forced-color-adjust": "auto|none", gap: "<'row-gap'> <'column-gap'>?", grid: "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>", "grid-area": "<grid-line> [/ <grid-line>]{0,3}", "grid-auto-columns": "<track-size>+", "grid-auto-flow": "[row|column]||dense", "grid-auto-rows": "<track-size>+", "grid-column": "<grid-line> [/ <grid-line>]?", "grid-column-end": "<grid-line>", "grid-column-gap": "<length-percentage>", "grid-column-start": "<grid-line>", "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?", "grid-row": "<grid-line> [/ <grid-line>]?", "grid-row-end": "<grid-line>", "grid-row-gap": "<length-percentage>", "grid-row-start": "<grid-line>", "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?", "grid-template-areas": "none|<string>+", "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?", "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?", "hanging-punctuation": "none|[first||[force-end|allow-end]||last]", height: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )", "hyphenate-character": "auto|<string>", hyphens: "none|manual|auto", "image-orientation": "from-image|<angle>|[<angle>? flip]", "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>", "image-resolution": "[from-image||<resolution>]&&snap?", "ime-mode": "auto|normal|active|inactive|disabled", "initial-letter": "normal|[<number> <integer>?]", "initial-letter-align": "[auto|alphabetic|hanging|ideographic]", "inline-size": "<'width'>", "input-security": "auto|none", inset: "<'top'>{1,4}", "inset-block": "<'top'>{1,2}", "inset-block-end": "<'top'>", "inset-block-start": "<'top'>", "inset-inline": "<'top'>{1,2}", "inset-inline-end": "<'top'>", "inset-inline-start": "<'top'>", isolation: "auto|isolate", "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]", "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]", "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]", "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#", left: "<length>|<percentage>|auto", "letter-spacing": "normal|<length-percentage>", "line-break": "auto|loose|normal|strict|anywhere", "line-clamp": "none|<integer>", "line-height": "normal|<number>|<length>|<percentage>", "line-height-step": "<length>", "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>", "list-style-image": "<image>|none", "list-style-position": "inside|outside", "list-style-type": "<counter-style>|<string>|none", margin: "[<length>|<percentage>|auto]{1,4}", "margin-block": "<'margin-left'>{1,2}", "margin-block-end": "<'margin-left'>", "margin-block-start": "<'margin-left'>", "margin-bottom": "<length>|<percentage>|auto", "margin-inline": "<'margin-left'>{1,2}", "margin-inline-end": "<'margin-left'>", "margin-inline-start": "<'margin-left'>", "margin-left": "<length>|<percentage>|auto", "margin-right": "<length>|<percentage>|auto", "margin-top": "<length>|<percentage>|auto", "margin-trim": "none|in-flow|all", mask: "<mask-layer>#", "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>", "mask-border-mode": "luminance|alpha", "mask-border-outset": "[<length>|<number>]{1,4}", "mask-border-repeat": "[stretch|repeat|round|space]{1,2}", "mask-border-slice": "<number-percentage>{1,4} fill?", "mask-border-source": "none|<image>", "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}", "mask-clip": "[<geometry-box>|no-clip]#", "mask-composite": "<compositing-operator>#", "mask-image": "<mask-reference>#", "mask-mode": "<masking-mode>#", "mask-origin": "<geometry-box>#", "mask-position": "<position>#", "mask-repeat": "<repeat-style>#", "mask-size": "<bg-size>#", "mask-type": "luminance|alpha", "masonry-auto-flow": "[pack|next]||[definite-first|ordered]", "math-depth": "auto-add|add( <integer> )|<integer>", "math-shift": "normal|compact", "math-style": "normal|compact", "max-block-size": "<'max-width'>", "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )", "max-inline-size": "<'max-width'>", "max-lines": "none|<integer>", "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>", "min-block-size": "<'min-width'>", "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )", "min-inline-size": "<'min-width'>", "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>", "mix-blend-mode": "<blend-mode>|plus-lighter", "object-fit": "fill|contain|cover|none|scale-down", "object-position": "<position>", offset: "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?", "offset-anchor": "auto|<position>", "offset-distance": "<length-percentage>", "offset-path": "none|ray( [<angle>&&<size>&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]", "offset-position": "auto|<position>", "offset-rotate": "[auto|reverse]||<angle>", opacity: "<alpha-value>", order: "<integer>", orphans: "<integer>", outline: "[<'outline-color'>||<'outline-style'>||<'outline-width'>]", "outline-color": "<color>|invert", "outline-offset": "<length>", "outline-style": "auto|<'border-style'>", "outline-width": "<line-width>", overflow: "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>", "overflow-anchor": "auto|none", "overflow-block": "visible|hidden|clip|scroll|auto", "overflow-clip-box": "padding-box|content-box", "overflow-clip-margin": "<visual-box>||<length [0,∞]>", "overflow-inline": "visible|hidden|clip|scroll|auto", "overflow-wrap": "normal|break-word|anywhere", "overflow-x": "visible|hidden|clip|scroll|auto", "overflow-y": "visible|hidden|clip|scroll|auto", "overscroll-behavior": "[contain|none|auto]{1,2}", "overscroll-behavior-block": "contain|none|auto", "overscroll-behavior-inline": "contain|none|auto", "overscroll-behavior-x": "contain|none|auto", "overscroll-behavior-y": "contain|none|auto", padding: "[<length>|<percentage>]{1,4}", "padding-block": "<'padding-left'>{1,2}", "padding-block-end": "<'padding-left'>", "padding-block-start": "<'padding-left'>", "padding-bottom": "<length>|<percentage>", "padding-inline": "<'padding-left'>{1,2}", "padding-inline-end": "<'padding-left'>", "padding-inline-start": "<'padding-left'>", "padding-left": "<length>|<percentage>", "padding-right": "<length>|<percentage>", "padding-top": "<length>|<percentage>", "page-break-after": "auto|always|avoid|left|right|recto|verso", "page-break-before": "auto|always|avoid|left|right|recto|verso", "page-break-inside": "auto|avoid", "paint-order": "normal|[fill||stroke||markers]", perspective: "none|<length>", "perspective-origin": "<position>", "place-content": "<'align-content'> <'justify-content'>?", "place-items": "<'align-items'> <'justify-items'>?", "place-self": "<'align-self'> <'justify-self'>?", "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit", position: "static|relative|absolute|sticky|fixed|-webkit-sticky", quotes: "none|auto|[<string> <string>]+", resize: "none|both|horizontal|vertical|block|inline", right: "<length>|<percentage>|auto", rotate: "none|<angle>|[x|y|z|<number>{3}]&&<angle>", "row-gap": "normal|<length-percentage>", "ruby-align": "start|center|space-between|space-around", "ruby-merge": "separate|collapse|auto", "ruby-position": "[alternate||[over|under]]|inter-character", scale: "none|<number>{1,3}", "scrollbar-color": "auto|<color>{2}", "scrollbar-gutter": "auto|stable&&both-edges?", "scrollbar-width": "auto|thin|none", "scroll-behavior": "auto|smooth", "scroll-margin": "<length>{1,4}", "scroll-margin-block": "<length>{1,2}", "scroll-margin-block-start": "<length>", "scroll-margin-block-end": "<length>", "scroll-margin-bottom": "<length>", "scroll-margin-inline": "<length>{1,2}", "scroll-margin-inline-start": "<length>", "scroll-margin-inline-end": "<length>", "scroll-margin-left": "<length>", "scroll-margin-right": "<length>", "scroll-margin-top": "<length>", "scroll-padding": "[auto|<length-percentage>]{1,4}", "scroll-padding-block": "[auto|<length-percentage>]{1,2}", "scroll-padding-block-start": "auto|<length-percentage>", "scroll-padding-block-end": "auto|<length-percentage>", "scroll-padding-bottom": "auto|<length-percentage>", "scroll-padding-inline": "[auto|<length-percentage>]{1,2}", "scroll-padding-inline-start": "auto|<length-percentage>", "scroll-padding-inline-end": "auto|<length-percentage>", "scroll-padding-left": "auto|<length-percentage>", "scroll-padding-right": "auto|<length-percentage>", "scroll-padding-top": "auto|<length-percentage>", "scroll-snap-align": "[none|start|end|center]{1,2}", "scroll-snap-coordinate": "none|<position>#", "scroll-snap-destination": "<position>", "scroll-snap-points-x": "none|repeat( <length-percentage> )", "scroll-snap-points-y": "none|repeat( <length-percentage> )", "scroll-snap-stop": "normal|always", "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?", "scroll-snap-type-x": "none|mandatory|proximity", "scroll-snap-type-y": "none|mandatory|proximity", "scroll-timeline": "<scroll-timeline-name>||<scroll-timeline-axis>", "scroll-timeline-axis": "block|inline|vertical|horizontal", "scroll-timeline-name": "none|<custom-ident>", "shape-image-threshold": "<alpha-value>", "shape-margin": "<length-percentage>", "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>", "tab-size": "<integer>|<length>", "table-layout": "auto|fixed", "text-align": "start|end|left|right|center|justify|match-parent", "text-align-last": "auto|start|end|left|right|center|justify", "text-combine-upright": "none|all|[digits <integer>?]", "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>", "text-decoration-color": "<color>", "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error", "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]", "text-decoration-skip-ink": "auto|all|none", "text-decoration-style": "solid|double|dotted|dashed|wavy", "text-decoration-thickness": "auto|from-font|<length>|<percentage>", "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>", "text-emphasis-color": "<color>", "text-emphasis-position": "[over|under]&&[right|left]", "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>", "text-indent": "<length-percentage>&&hanging?&&each-line?", "text-justify": "auto|inter-character|inter-word|none", "text-orientation": "mixed|upright|sideways", "text-overflow": "[clip|ellipsis|<string>]{1,2}", "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision", "text-shadow": "none|<shadow-t>#", "text-size-adjust": "none|auto|<percentage>", "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana", "text-underline-offset": "auto|<length>|<percentage>", "text-underline-position": "auto|from-font|[under||[left|right]]", top: "<length>|<percentage>|auto", "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation", transform: "none|<transform-list>", "transform-box": "content-box|border-box|fill-box|stroke-box|view-box", "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?", "transform-style": "flat|preserve-3d", transition: "<single-transition>#", "transition-delay": "<time>#", "transition-duration": "<time>#", "transition-property": "none|<single-transition-property>#", "transition-timing-function": "<easing-function>#", translate: "none|<length-percentage> [<length-percentage> <length>?]?", "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext", "user-select": "auto|text|none|contain|all", "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>", visibility: "visible|hidden|collapse", "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces", widows: "<integer>", width: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|fill|stretch|intrinsic|-moz-max-content|-webkit-max-content|-moz-fit-content|-webkit-fit-content", "will-change": "auto|<animateable-feature>#", "word-break": "normal|break-all|keep-all|break-word", "word-spacing": "normal|<length>", "word-wrap": "normal|break-word", "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>", "z-index": "auto|<integer>", zoom: "normal|reset|<number>|<percentage>", "-moz-background-clip": "padding|border", "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>", "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>", "-moz-border-radius-topleft": "<'border-top-left-radius'>", "-moz-border-radius-topright": "<'border-bottom-right-radius'>", "-moz-control-character-visibility": "visible|hidden", "-moz-osx-font-smoothing": "auto|grayscale", "-moz-user-select": "none|text|all|-moz-none", "-ms-flex-align": "start|end|center|baseline|stretch", "-ms-flex-item-align": "auto|start|end|center|baseline|stretch", "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch", "-ms-flex-negative": "<'flex-shrink'>", "-ms-flex-pack": "start|end|center|justify|distribute", "-ms-flex-order": "<integer>", "-ms-flex-positive": "<'flex-grow'>", "-ms-flex-preferred-size": "<'flex-basis'>", "-ms-interpolation-mode": "nearest-neighbor|bicubic", "-ms-grid-column-align": "start|end|center|stretch", "-ms-grid-row-align": "start|end|center|stretch", "-ms-hyphenate-limit-last": "none|always|column|page|spread", "-webkit-background-clip": "[<box>|border|padding|content|text]#", "-webkit-column-break-after": "always|auto|avoid", "-webkit-column-break-before": "always|auto|avoid", "-webkit-column-break-inside": "always|auto|avoid", "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased", "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?", "-webkit-print-color-adjust": "economy|exact", "-webkit-text-security": "none|circle|disc|square", "-webkit-user-drag": "none|element|auto", "-webkit-user-select": "auto|none|text|all", "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical", "baseline-shift": "baseline|sub|super|<svg-length>", behavior: "<url>+", "clip-rule": "nonzero|evenodd", container: "<'container-name'> [/ <'container-type'>]?", "container-name": "none|<custom-ident>+", "container-type": "normal||[size|inline-size]", cue: "<'cue-before'> <'cue-after'>?", "cue-after": "<url> <decibel>?|none", "cue-before": "<url> <decibel>?|none", "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge", fill: "<paint>", "fill-opacity": "<number-zero-one>", "fill-rule": "nonzero|evenodd", "glyph-orientation-horizontal": "<angle>", "glyph-orientation-vertical": "<angle>", kerning: "auto|<svg-length>", marker: "none|<url>", "marker-end": "none|<url>", "marker-mid": "none|<url>", "marker-start": "none|<url>", pause: "<'pause-before'> <'pause-after'>?", "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong", "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong", rest: "<'rest-before'> <'rest-after'>?", "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong", "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong", "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision", src: "[<url> [format( <string># )]?|local( <family-name> )]#", speak: "auto|none|normal", "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]", stroke: "<paint>", "stroke-dasharray": "none|[<svg-length>+]#", "stroke-dashoffset": "<svg-length>", "stroke-linecap": "butt|round|square", "stroke-linejoin": "miter|round|bevel", "stroke-miterlimit": "<number-one-or-greater>", "stroke-opacity": "<number-zero-one>", "stroke-width": "<svg-length>", "text-anchor": "start|middle|end", "unicode-range": "<urange>#", "voice-balance": "<number>|left|center|right|leftwards|rightwards", "voice-duration": "auto|<time>", "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve", "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]", "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]", "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>", "voice-stress": "normal|strong|moderate|none|reduced", "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]" }, atrules: { charset: { prelude: "<string>", descriptors: null }, "counter-style": { prelude: "<counter-style-name>", descriptors: { "additive-symbols": "[<integer>&&<symbol>]#", fallback: "<counter-style-name>", negative: "<symbol> <symbol>?", pad: "<integer>&&<symbol>", prefix: "<symbol>", range: "[[<integer>|infinite]{2}]#|auto", "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>", suffix: "<symbol>", symbols: "<symbol>+", system: "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]" } }, document: { prelude: "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#", descriptors: null }, "font-face": { prelude: null, descriptors: { "ascent-override": "normal|<percentage>", "descent-override": "normal|<percentage>", "font-display": "[auto|block|swap|fallback|optional]", "font-family": "<family-name>", "font-feature-settings": "normal|<feature-tag-value>#", "font-variation-settings": "normal|[<string> <number>]#", "font-stretch": "<font-stretch-absolute>{1,2}", "font-style": "normal|italic|oblique <angle>{0,2}", "font-weight": "<font-weight-absolute>{1,2}", "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]", "line-gap-override": "normal|<percentage>", "size-adjust": "<percentage>", src: "[<url> [format( <string># )]?|local( <family-name> )]#", "unicode-range": "<urange>#" } }, "font-feature-values": { prelude: "<family-name>#", descriptors: null }, import: { prelude: "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?", descriptors: null }, keyframes: { prelude: "<keyframes-name>", descriptors: null }, layer: { prelude: "[<layer-name>#|<layer-name>?]", descriptors: null }, media: { prelude: "<media-query-list>", descriptors: null }, namespace: { prelude: "<namespace-prefix>? [<string>|<url>]", descriptors: null }, page: { prelude: "<page-selector-list>", descriptors: { bleed: "auto|<length>", marks: "none|[crop||cross]", size: "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]" } }, property: { prelude: "<custom-property-name>", descriptors: { syntax: "<string>", inherits: "true|false", "initial-value": "<string>" } }, "scroll-timeline": { prelude: "<timeline-name>", descriptors: null }, supports: { prelude: "<supports-condition>", descriptors: null }, viewport: { prelude: null, descriptors: { height: "<viewport-length>{1,2}", "max-height": "<viewport-length>", "max-width": "<viewport-length>", "max-zoom": "auto|<number>|<percentage>", "min-height": "<viewport-length>", "min-width": "<viewport-length>", "min-zoom": "auto|<number>|<percentage>", orientation: "auto|portrait|landscape", "user-zoom": "zoom|fixed", "viewport-fit": "auto|contain|cover", width: "<viewport-length>{1,2}", zoom: "auto|<number>|<percentage>" } }, container: { prelude: "[<container-name>]? <container-condition>", descriptors: null }, nest: { prelude: "<complex-selector-list>", descriptors: null } } };
var gt = {};
b$1(gt, { AnPlusB: () => Xr, Atrule: () => Zr, AtrulePrelude: () => en, AttributeSelector: () => nn, Block: () => an, Brackets: () => ln, CDC: () => un, CDO: () => hn, ClassSelector: () => fn, Combinator: () => gn, Comment: () => xn, Declaration: () => kn, DeclarationList: () => Sn, Dimension: () => An, Function: () => En, Hash: () => Pn, IdSelector: () => Nn, Identifier: () => Dn, MediaFeature: () => Mn, MediaQuery: () => Fn, MediaQueryList: () => _n, NestingSelector: () => Un, Nth: () => Wn, Number: () => Yn, Operator: () => Vn, Parentheses: () => Qn, Percentage: () => $n, PseudoClassSelector: () => Jn, PseudoElementSelector: () => to, Ratio: () => no, Raw: () => io, Rule: () => so, Selector: () => co, SelectorList: () => po, String: () => bo, StyleSheet: () => yo, TypeSelector: () => vo, UnicodeRange: () => Ao, Url: () => Do, Value: () => No, WhiteSpace: () => Mo });
var Xr = {};
b$1(Xr, { generate: () => xc, name: () => gc, parse: () => Qr, structure: () => bc });
var me = 43;
var re$1 = 45;
var Xt = 110;
var Ie = true;
var dc = false;
function $t(e, t) {
  let r = this.tokenStart + e, n = this.charCodeAt(r);
  for ((n === me || n === re$1) && (t && this.error("Number sign is not allowed"), r++); r < this.tokenEnd; r++)
    B(this.charCodeAt(r)) || this.error("Integer is expected", r);
}
function Qe(e) {
  return $t.call(this, 0, e);
}
function Ce(e, t) {
  if (!this.cmpChar(this.tokenStart + e, t)) {
    let r = "";
    switch (t) {
      case Xt:
        r = "N is expected";
        break;
      case re$1:
        r = "HyphenMinus is expected";
        break;
    }
    this.error(r, this.tokenStart + e);
  }
}
function Kr() {
  let e = 0, t = 0, r = this.tokenType;
  for (; r === 13 || r === 25; )
    r = this.lookupType(++e);
  if (r !== 10)
    if (this.isDelim(me, e) || this.isDelim(re$1, e)) {
      t = this.isDelim(me, e) ? me : re$1;
      do
        r = this.lookupType(++e);
      while (r === 13 || r === 25);
      r !== 10 && (this.skip(e), Qe.call(this, Ie));
    } else
      return null;
  return e > 0 && this.skip(e), t === 0 && (r = this.charCodeAt(this.tokenStart), r !== me && r !== re$1 && this.error("Number sign is expected")), Qe.call(this, t !== 0), t === re$1 ? "-" + this.consume(10) : this.consume(10);
}
var gc = "AnPlusB";
var bc = { a: [String, null], b: [String, null] };
function Qr() {
  let e = this.tokenStart, t = null, r = null;
  if (this.tokenType === 10)
    Qe.call(this, dc), r = this.consume(10);
  else if (this.tokenType === 1 && this.cmpChar(this.tokenStart, re$1))
    switch (t = "-1", Ce.call(this, 1, Xt), this.tokenEnd - this.tokenStart) {
      case 2:
        this.next(), r = Kr.call(this);
        break;
      case 3:
        Ce.call(this, 2, re$1), this.next(), this.skipSC(), Qe.call(this, Ie), r = "-" + this.consume(10);
        break;
      default:
        Ce.call(this, 2, re$1), $t.call(this, 3, Ie), this.next(), r = this.substrToCursor(e + 2);
    }
  else if (this.tokenType === 1 || this.isDelim(me) && this.lookupType(1) === 1) {
    let n = 0;
    switch (t = "1", this.isDelim(me) && (n = 1, this.next()), Ce.call(this, 0, Xt), this.tokenEnd - this.tokenStart) {
      case 1:
        this.next(), r = Kr.call(this);
        break;
      case 2:
        Ce.call(this, 1, re$1), this.next(), this.skipSC(), Qe.call(this, Ie), r = "-" + this.consume(10);
        break;
      default:
        Ce.call(this, 1, re$1), $t.call(this, 2, Ie), this.next(), r = this.substrToCursor(e + n + 1);
    }
  } else if (this.tokenType === 12) {
    let n = this.charCodeAt(this.tokenStart), o = n === me || n === re$1, i = this.tokenStart + o;
    for (; i < this.tokenEnd && B(this.charCodeAt(i)); i++)
      ;
    i === this.tokenStart + o && this.error("Integer is expected", this.tokenStart + o), Ce.call(this, i - this.tokenStart, Xt), t = this.substring(e, i), i + 1 === this.tokenEnd ? (this.next(), r = Kr.call(this)) : (Ce.call(this, i - this.tokenStart + 1, re$1), i + 2 === this.tokenEnd ? (this.next(), this.skipSC(), Qe.call(this, Ie), r = "-" + this.consume(10)) : ($t.call(this, i - this.tokenStart + 2, Ie), this.next(), r = this.substrToCursor(i + 1)));
  } else
    this.error();
  return t !== null && t.charCodeAt(0) === me && (t = t.substr(1)), r !== null && r.charCodeAt(0) === me && (r = r.substr(1)), { type: "AnPlusB", loc: this.getLocation(e, this.tokenStart), a: t, b: r };
}
function xc(e) {
  if (e.a) {
    let t = e.a === "+1" && "n" || e.a === "1" && "n" || e.a === "-1" && "-n" || e.a + "n";
    if (e.b) {
      let r = e.b[0] === "-" || e.b[0] === "+" ? e.b : "+" + e.b;
      this.tokenize(t + r);
    } else
      this.tokenize(t);
  } else
    this.tokenize(e.b);
}
var Zr = {};
b$1(Zr, { generate: () => Sc, name: () => kc, parse: () => $r, structure: () => vc, walkContext: () => wc });
function da(e) {
  return this.Raw(e, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}
function yc() {
  for (let e = 1, t; t = this.lookupType(e); e++) {
    if (t === 24)
      return true;
    if (t === 23 || t === 3)
      return false;
  }
  return false;
}
var kc = "Atrule";
var wc = "atrule";
var vc = { name: String, prelude: ["AtrulePrelude", "Raw", null], block: ["Block", null] };
function $r(e = false) {
  let t = this.tokenStart, r, n, o = null, i = null;
  switch (this.eat(3), r = this.substrToCursor(t + 1), n = r.toLowerCase(), this.skipSC(), this.eof === false && this.tokenType !== 23 && this.tokenType !== 17 && (this.parseAtrulePrelude ? o = this.parseWithFallback(this.AtrulePrelude.bind(this, r, e), da) : o = da.call(this, this.tokenIndex), this.skipSC()), this.tokenType) {
    case 17:
      this.next();
      break;
    case 23:
      hasOwnProperty.call(this.atrule, n) && typeof this.atrule[n].block == "function" ? i = this.atrule[n].block.call(this, e) : i = this.Block(yc.call(this));
      break;
  }
  return { type: "Atrule", loc: this.getLocation(t, this.tokenStart), name: r, prelude: o, block: i };
}
function Sc(e) {
  this.token(3, "@" + e.name), e.prelude !== null && this.node(e.prelude), e.block ? this.node(e.block) : this.token(17, ";");
}
var en = {};
b$1(en, { generate: () => Ec, name: () => Cc, parse: () => Jr, structure: () => Tc, walkContext: () => Ac });
var Cc = "AtrulePrelude";
var Ac = "atrulePrelude";
var Tc = { children: [[]] };
function Jr(e) {
  let t = null;
  return e !== null && (e = e.toLowerCase()), this.skipSC(), hasOwnProperty.call(this.atrule, e) && typeof this.atrule[e].prelude == "function" ? t = this.atrule[e].prelude.call(this) : t = this.readSequence(this.scope.AtrulePrelude), this.skipSC(), this.eof !== true && this.tokenType !== 23 && this.tokenType !== 17 && this.error("Semicolon or block is expected"), { type: "AtrulePrelude", loc: this.getLocationFromList(t), children: t };
}
function Ec(e) {
  this.children(e);
}
var nn = {};
b$1(nn, { generate: () => Mc, name: () => Nc, parse: () => rn, structure: () => zc });
var Lc = 36;
var ga = 42;
var Zt = 61;
var Pc = 94;
var tn = 124;
var Ic = 126;
function Dc() {
  this.eof && this.error("Unexpected end of input");
  let e = this.tokenStart, t = false;
  return this.isDelim(ga) ? (t = true, this.next()) : this.isDelim(tn) || this.eat(1), this.isDelim(tn) ? this.charCodeAt(this.tokenStart + 1) !== Zt ? (this.next(), this.eat(1)) : t && this.error("Identifier is expected", this.tokenEnd) : t && this.error("Vertical line is expected"), { type: "Identifier", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e) };
}
function Oc() {
  let e = this.tokenStart, t = this.charCodeAt(e);
  return t !== Zt && t !== Ic && t !== Pc && t !== Lc && t !== ga && t !== tn && this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected"), this.next(), t !== Zt && (this.isDelim(Zt) || this.error("Equal sign is expected"), this.next()), this.substrToCursor(e);
}
var Nc = "AttributeSelector";
var zc = { name: "Identifier", matcher: [String, null], value: ["String", "Identifier", null], flags: [String, null] };
function rn() {
  let e = this.tokenStart, t, r = null, n = null, o = null;
  return this.eat(19), this.skipSC(), t = Dc.call(this), this.skipSC(), this.tokenType !== 20 && (this.tokenType !== 1 && (r = Oc.call(this), this.skipSC(), n = this.tokenType === 5 ? this.String() : this.Identifier(), this.skipSC()), this.tokenType === 1 && (o = this.consume(1), this.skipSC())), this.eat(20), { type: "AttributeSelector", loc: this.getLocation(e, this.tokenStart), name: t, matcher: r, value: n, flags: o };
}
function Mc(e) {
  this.token(9, "["), this.node(e.name), e.matcher !== null && (this.tokenize(e.matcher), this.node(e.value)), e.flags !== null && this.token(1, e.flags), this.token(9, "]");
}
var an = {};
b$1(an, { generate: () => Uc, name: () => Bc, parse: () => on, structure: () => qc, walkContext: () => _c });
var Rc = 38;
function ya(e) {
  return this.Raw(e, null, true);
}
function ba() {
  return this.parseWithFallback(this.Rule, ya);
}
function xa(e) {
  return this.Raw(e, this.consumeUntilSemicolonIncluded, true);
}
function Fc() {
  if (this.tokenType === 17)
    return xa.call(this, this.tokenIndex);
  let e = this.parseWithFallback(this.Declaration, xa);
  return this.tokenType === 17 && this.next(), e;
}
var Bc = "Block";
var _c = "block";
var qc = { children: [["Atrule", "Rule", "Declaration"]] };
function on(e) {
  let t = e ? Fc : ba, r = this.tokenStart, n = this.createList();
  this.eat(23);
  e:
    for (; !this.eof; )
      switch (this.tokenType) {
        case 24:
          break e;
        case 13:
        case 25:
          this.next();
          break;
        case 3:
          n.push(this.parseWithFallback(this.Atrule.bind(this, e), ya));
          break;
        default:
          e && this.isDelim(Rc) ? n.push(ba.call(this)) : n.push(t.call(this));
      }
  return this.eof || this.eat(24), { type: "Block", loc: this.getLocation(r, this.tokenStart), children: n };
}
function Uc(e) {
  this.token(23, "{"), this.children(e, (t) => {
    t.type === "Declaration" && this.token(17, ";");
  }), this.token(24, "}");
}
var ln = {};
b$1(ln, { generate: () => Hc, name: () => jc, parse: () => sn, structure: () => Wc });
var jc = "Brackets";
var Wc = { children: [[]] };
function sn(e, t) {
  let r = this.tokenStart, n = null;
  return this.eat(19), n = e.call(this, t), this.eof || this.eat(20), { type: "Brackets", loc: this.getLocation(r, this.tokenStart), children: n };
}
function Hc(e) {
  this.token(9, "["), this.children(e), this.token(9, "]");
}
var un = {};
b$1(un, { generate: () => Vc, name: () => Yc, parse: () => cn, structure: () => Gc });
var Yc = "CDC";
var Gc = [];
function cn() {
  let e = this.tokenStart;
  return this.eat(15), { type: "CDC", loc: this.getLocation(e, this.tokenStart) };
}
function Vc() {
  this.token(15, "-->");
}
var hn = {};
b$1(hn, { generate: () => Xc, name: () => Kc, parse: () => pn, structure: () => Qc });
var Kc = "CDO";
var Qc = [];
function pn() {
  let e = this.tokenStart;
  return this.eat(14), { type: "CDO", loc: this.getLocation(e, this.tokenStart) };
}
function Xc() {
  this.token(14, "<!--");
}
var fn = {};
b$1(fn, { generate: () => eu, name: () => Zc, parse: () => mn, structure: () => Jc });
var $c = 46;
var Zc = "ClassSelector";
var Jc = { name: String };
function mn() {
  return this.eatDelim($c), { type: "ClassSelector", loc: this.getLocation(this.tokenStart - 1, this.tokenEnd), name: this.consume(1) };
}
function eu(e) {
  this.token(9, "."), this.token(1, e.name);
}
var gn = {};
b$1(gn, { generate: () => au, name: () => ou, parse: () => dn, structure: () => iu });
var tu = 43;
var ka = 47;
var ru = 62;
var nu = 126;
var ou = "Combinator";
var iu = { name: String };
function dn() {
  let e = this.tokenStart, t;
  switch (this.tokenType) {
    case 13:
      t = " ";
      break;
    case 9:
      switch (this.charCodeAt(this.tokenStart)) {
        case ru:
        case tu:
        case nu:
          this.next();
          break;
        case ka:
          this.next(), this.eatIdent("deep"), this.eatDelim(ka);
          break;
        default:
          this.error("Combinator is expected");
      }
      t = this.substrToCursor(e);
      break;
  }
  return { type: "Combinator", loc: this.getLocation(e, this.tokenStart), name: t };
}
function au(e) {
  this.tokenize(e.name);
}
var xn = {};
b$1(xn, { generate: () => pu, name: () => cu, parse: () => bn, structure: () => uu });
var su = 42;
var lu = 47;
var cu = "Comment";
var uu = { value: String };
function bn() {
  let e = this.tokenStart, t = this.tokenEnd;
  return this.eat(25), t - e + 2 >= 2 && this.charCodeAt(t - 2) === su && this.charCodeAt(t - 1) === lu && (t -= 2), { type: "Comment", loc: this.getLocation(e, this.tokenStart), value: this.substring(e + 2, t) };
}
function pu(e) {
  this.token(25, "/*" + e.value + "*/");
}
var kn = {};
b$1(kn, { generate: () => Su, name: () => ku, parse: () => yn, structure: () => vu, walkContext: () => wu });
var va = 33;
var hu = 35;
var mu = 36;
var fu = 38;
var du = 42;
var gu = 43;
var wa = 47;
function bu(e) {
  return this.Raw(e, this.consumeUntilExclamationMarkOrSemicolon, true);
}
function xu(e) {
  return this.Raw(e, this.consumeUntilExclamationMarkOrSemicolon, false);
}
function yu() {
  let e = this.tokenIndex, t = this.Value();
  return t.type !== "Raw" && this.eof === false && this.tokenType !== 17 && this.isDelim(va) === false && this.isBalanceEdge(e) === false && this.error(), t;
}
var ku = "Declaration";
var wu = "declaration";
var vu = { important: [Boolean, String], property: String, value: ["Value", "Raw"] };
function yn() {
  let e = this.tokenStart, t = this.tokenIndex, r = Cu.call(this), n = Mt(r), o = n ? this.parseCustomProperty : this.parseValue, i = n ? xu : bu, s = false, u2;
  this.skipSC(), this.eat(16);
  let c2 = this.tokenIndex;
  if (n || this.skipSC(), o ? u2 = this.parseWithFallback(yu, i) : u2 = i.call(this, this.tokenIndex), n && u2.type === "Value" && u2.children.isEmpty) {
    for (let a = c2 - this.tokenIndex; a <= 0; a++)
      if (this.lookupType(a) === 13) {
        u2.children.appendData({ type: "WhiteSpace", loc: null, value: " " });
        break;
      }
  }
  return this.isDelim(va) && (s = Au.call(this), this.skipSC()), this.eof === false && this.tokenType !== 17 && this.isBalanceEdge(t) === false && this.error(), { type: "Declaration", loc: this.getLocation(e, this.tokenStart), important: s, property: r, value: u2 };
}
function Su(e) {
  this.token(1, e.property), this.token(16, ":"), this.node(e.value), e.important && (this.token(9, "!"), this.token(1, e.important === true ? "important" : e.important));
}
function Cu() {
  let e = this.tokenStart;
  if (this.tokenType === 9)
    switch (this.charCodeAt(this.tokenStart)) {
      case du:
      case mu:
      case gu:
      case hu:
      case fu:
        this.next();
        break;
      case wa:
        this.next(), this.isDelim(wa) && this.next();
        break;
    }
  return this.tokenType === 4 ? this.eat(4) : this.eat(1), this.substrToCursor(e);
}
function Au() {
  this.eat(9), this.skipSC();
  let e = this.consume(1);
  return e === "important" ? true : e;
}
var Sn = {};
b$1(Sn, { generate: () => Pu, name: () => Eu, parse: () => vn, structure: () => Lu });
var Tu = 38;
function wn(e) {
  return this.Raw(e, this.consumeUntilSemicolonIncluded, true);
}
var Eu = "DeclarationList";
var Lu = { children: [["Declaration", "Atrule", "Rule"]] };
function vn() {
  let e = this.createList();
  for (; !this.eof; )
    switch (this.tokenType) {
      case 13:
      case 25:
      case 17:
        this.next();
        break;
      case 3:
        e.push(this.parseWithFallback(this.Atrule.bind(this, true), wn));
        break;
      default:
        this.isDelim(Tu) ? e.push(this.parseWithFallback(this.Rule, wn)) : e.push(this.parseWithFallback(this.Declaration, wn));
    }
  return { type: "DeclarationList", loc: this.getLocationFromList(e), children: e };
}
function Pu(e) {
  this.children(e, (t) => {
    t.type === "Declaration" && this.token(17, ";");
  });
}
var An = {};
b$1(An, { generate: () => Ou, name: () => Iu, parse: () => Cn, structure: () => Du });
var Iu = "Dimension";
var Du = { value: String, unit: String };
function Cn() {
  let e = this.tokenStart, t = this.consumeNumber(12);
  return { type: "Dimension", loc: this.getLocation(e, this.tokenStart), value: t, unit: this.substring(e + t.length, this.tokenStart) };
}
function Ou(e) {
  this.token(12, e.value + e.unit);
}
var En = {};
b$1(En, { generate: () => Ru, name: () => Nu, parse: () => Tn, structure: () => Mu, walkContext: () => zu });
var Nu = "Function";
var zu = "function";
var Mu = { name: String, children: [[]] };
function Tn(e, t) {
  let r = this.tokenStart, n = this.consumeFunctionName(), o = n.toLowerCase(), i;
  return i = t.hasOwnProperty(o) ? t[o].call(this, t) : e.call(this, t), this.eof || this.eat(22), { type: "Function", loc: this.getLocation(r, this.tokenStart), name: n, children: i };
}
function Ru(e) {
  this.token(2, e.name + "("), this.children(e), this.token(22, ")");
}
var Pn = {};
b$1(Pn, { generate: () => qu, name: () => Bu, parse: () => Ln, structure: () => _u, xxx: () => Fu });
var Fu = "XXX";
var Bu = "Hash";
var _u = { value: String };
function Ln() {
  let e = this.tokenStart;
  return this.eat(4), { type: "Hash", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e + 1) };
}
function qu(e) {
  this.token(4, "#" + e.value);
}
var Dn = {};
b$1(Dn, { generate: () => Wu, name: () => Uu, parse: () => In, structure: () => ju });
var Uu = "Identifier";
var ju = { name: String };
function In() {
  return { type: "Identifier", loc: this.getLocation(this.tokenStart, this.tokenEnd), name: this.consume(1) };
}
function Wu(e) {
  this.token(1, e.name);
}
var Nn = {};
b$1(Nn, { generate: () => Gu, name: () => Hu, parse: () => On, structure: () => Yu });
var Hu = "IdSelector";
var Yu = { name: String };
function On() {
  let e = this.tokenStart;
  return this.eat(4), { type: "IdSelector", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e + 1) };
}
function Gu(e) {
  this.token(9, "#" + e.name);
}
var Mn = {};
b$1(Mn, { generate: () => Qu, name: () => Vu, parse: () => zn, structure: () => Ku });
var Vu = "MediaFeature";
var Ku = { name: String, value: ["Identifier", "Number", "Dimension", "Ratio", null] };
function zn() {
  let e = this.tokenStart, t, r = null;
  if (this.eat(21), this.skipSC(), t = this.consume(1), this.skipSC(), this.tokenType !== 22) {
    switch (this.eat(16), this.skipSC(), this.tokenType) {
      case 10:
        this.lookupNonWSType(1) === 9 ? r = this.Ratio() : r = this.Number();
        break;
      case 12:
        r = this.Dimension();
        break;
      case 1:
        r = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
    this.skipSC();
  }
  return this.eat(22), { type: "MediaFeature", loc: this.getLocation(e, this.tokenStart), name: t, value: r };
}
function Qu(e) {
  this.token(21, "("), this.token(1, e.name), e.value !== null && (this.token(16, ":"), this.node(e.value)), this.token(22, ")");
}
var Fn = {};
b$1(Fn, { generate: () => Zu, name: () => Xu, parse: () => Rn, structure: () => $u });
var Xu = "MediaQuery";
var $u = { children: [["Identifier", "MediaFeature", "WhiteSpace"]] };
function Rn() {
  let e = this.createList(), t = null;
  this.skipSC();
  e:
    for (; !this.eof; ) {
      switch (this.tokenType) {
        case 25:
        case 13:
          this.next();
          continue;
        case 1:
          t = this.Identifier();
          break;
        case 21:
          t = this.MediaFeature();
          break;
        default:
          break e;
      }
      e.push(t);
    }
  return t === null && this.error("Identifier or parenthesis is expected"), { type: "MediaQuery", loc: this.getLocationFromList(e), children: e };
}
function Zu(e) {
  this.children(e);
}
var _n = {};
b$1(_n, { generate: () => tp, name: () => Ju, parse: () => Bn, structure: () => ep });
var Ju = "MediaQueryList";
var ep = { children: [["MediaQuery"]] };
function Bn() {
  let e = this.createList();
  for (this.skipSC(); !this.eof && (e.push(this.MediaQuery()), this.tokenType === 18); )
    this.next();
  return { type: "MediaQueryList", loc: this.getLocationFromList(e), children: e };
}
function tp(e) {
  this.children(e, () => this.token(18, ","));
}
var Un = {};
b$1(Un, { generate: () => ip, name: () => np, parse: () => qn, structure: () => op });
var rp = 38;
var np = "NestingSelector";
var op = {};
function qn() {
  let e = this.tokenStart;
  return this.eatDelim(rp), { type: "NestingSelector", loc: this.getLocation(e, this.tokenStart) };
}
function ip() {
  this.token(9, "&");
}
var Wn = {};
b$1(Wn, { generate: () => lp, name: () => ap, parse: () => jn, structure: () => sp });
var ap = "Nth";
var sp = { nth: ["AnPlusB", "Identifier"], selector: ["SelectorList", null] };
function jn() {
  this.skipSC();
  let e = this.tokenStart, t = e, r = null, n;
  return this.lookupValue(0, "odd") || this.lookupValue(0, "even") ? n = this.Identifier() : n = this.AnPlusB(), t = this.tokenStart, this.skipSC(), this.lookupValue(0, "of") && (this.next(), r = this.SelectorList(), t = this.tokenStart), { type: "Nth", loc: this.getLocation(e, t), nth: n, selector: r };
}
function lp(e) {
  this.node(e.nth), e.selector !== null && (this.token(1, "of"), this.node(e.selector));
}
var Yn = {};
b$1(Yn, { generate: () => pp$a, name: () => cp, parse: () => Hn, structure: () => up });
var cp = "Number";
var up = { value: String };
function Hn() {
  return { type: "Number", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: this.consume(10) };
}
function pp$a(e) {
  this.token(10, e.value);
}
var Vn = {};
b$1(Vn, { generate: () => fp, name: () => hp, parse: () => Gn, structure: () => mp });
var hp = "Operator";
var mp = { value: String };
function Gn() {
  let e = this.tokenStart;
  return this.next(), { type: "Operator", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e) };
}
function fp(e) {
  this.tokenize(e.value);
}
var Qn = {};
b$1(Qn, { generate: () => bp, name: () => dp, parse: () => Kn, structure: () => gp });
var dp = "Parentheses";
var gp = { children: [[]] };
function Kn(e, t) {
  let r = this.tokenStart, n = null;
  return this.eat(21), n = e.call(this, t), this.eof || this.eat(22), { type: "Parentheses", loc: this.getLocation(r, this.tokenStart), children: n };
}
function bp(e) {
  this.token(21, "("), this.children(e), this.token(22, ")");
}
var $n = {};
b$1($n, { generate: () => kp, name: () => xp, parse: () => Xn, structure: () => yp });
var xp = "Percentage";
var yp = { value: String };
function Xn() {
  return { type: "Percentage", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: this.consumeNumber(11) };
}
function kp(e) {
  this.token(11, e.value + "%");
}
var Jn = {};
b$1(Jn, { generate: () => Cp, name: () => wp, parse: () => Zn, structure: () => Sp, walkContext: () => vp });
var wp = "PseudoClassSelector";
var vp = "function";
var Sp = { name: String, children: [["Raw"], null] };
function Zn() {
  let e = this.tokenStart, t = null, r, n;
  return this.eat(16), this.tokenType === 2 ? (r = this.consumeFunctionName(), n = r.toLowerCase(), hasOwnProperty.call(this.pseudo, n) ? (this.skipSC(), t = this.pseudo[n].call(this), this.skipSC()) : (t = this.createList(), t.push(this.Raw(this.tokenIndex, null, false))), this.eat(22)) : r = this.consume(1), { type: "PseudoClassSelector", loc: this.getLocation(e, this.tokenStart), name: r, children: t };
}
function Cp(e) {
  this.token(16, ":"), e.children === null ? this.token(1, e.name) : (this.token(2, e.name + "("), this.children(e), this.token(22, ")"));
}
var to = {};
b$1(to, { generate: () => Lp, name: () => Ap, parse: () => eo, structure: () => Ep, walkContext: () => Tp });
var Ap = "PseudoElementSelector";
var Tp = "function";
var Ep = { name: String, children: [["Raw"], null] };
function eo() {
  let e = this.tokenStart, t = null, r, n;
  return this.eat(16), this.eat(16), this.tokenType === 2 ? (r = this.consumeFunctionName(), n = r.toLowerCase(), hasOwnProperty.call(this.pseudo, n) ? (this.skipSC(), t = this.pseudo[n].call(this), this.skipSC()) : (t = this.createList(), t.push(this.Raw(this.tokenIndex, null, false))), this.eat(22)) : r = this.consume(1), { type: "PseudoElementSelector", loc: this.getLocation(e, this.tokenStart), name: r, children: t };
}
function Lp(e) {
  this.token(16, ":"), this.token(16, ":"), e.children === null ? this.token(1, e.name) : (this.token(2, e.name + "("), this.children(e), this.token(22, ")"));
}
var no = {};
b$1(no, { generate: () => Np, name: () => Dp, parse: () => ro, structure: () => Op });
var Pp = 47;
var Ip = 46;
function Sa() {
  this.skipSC();
  let e = this.consume(10);
  for (let t = 0; t < e.length; t++) {
    let r = e.charCodeAt(t);
    !B(r) && r !== Ip && this.error("Unsigned number is expected", this.tokenStart - e.length + t);
  }
  return Number(e) === 0 && this.error("Zero number is not allowed", this.tokenStart - e.length), e;
}
var Dp = "Ratio";
var Op = { left: String, right: String };
function ro() {
  let e = this.tokenStart, t = Sa.call(this), r;
  return this.skipSC(), this.eatDelim(Pp), r = Sa.call(this), { type: "Ratio", loc: this.getLocation(e, this.tokenStart), left: t, right: r };
}
function Np(e) {
  this.token(10, e.left), this.token(9, "/"), this.token(10, e.right);
}
var io = {};
b$1(io, { generate: () => Fp, name: () => Mp, parse: () => oo, structure: () => Rp });
function zp() {
  return this.tokenIndex > 0 && this.lookupType(-1) === 13 ? this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset : this.tokenStart;
}
var Mp = "Raw";
var Rp = { value: String };
function oo(e, t, r) {
  let n = this.getTokenStart(e), o;
  return this.skipUntilBalanced(e, t || this.consumeUntilBalanceEnd), r && this.tokenStart > n ? o = zp.call(this) : o = this.tokenStart, { type: "Raw", loc: this.getLocation(n, o), value: this.substring(n, o) };
}
function Fp(e) {
  this.tokenize(e.value);
}
var so = {};
b$1(so, { generate: () => jp, name: () => _p, parse: () => ao, structure: () => Up, walkContext: () => qp });
function Ca(e) {
  return this.Raw(e, this.consumeUntilLeftCurlyBracket, true);
}
function Bp() {
  let e = this.SelectorList();
  return e.type !== "Raw" && this.eof === false && this.tokenType !== 23 && this.error(), e;
}
var _p = "Rule";
var qp = "rule";
var Up = { prelude: ["SelectorList", "Raw"], block: ["Block"] };
function ao() {
  let e = this.tokenIndex, t = this.tokenStart, r, n;
  return this.parseRulePrelude ? r = this.parseWithFallback(Bp, Ca) : r = Ca.call(this, e), n = this.Block(true), { type: "Rule", loc: this.getLocation(t, this.tokenStart), prelude: r, block: n };
}
function jp(e) {
  this.node(e.prelude), this.node(e.block);
}
var co = {};
b$1(co, { generate: () => Yp, name: () => Wp, parse: () => lo, structure: () => Hp });
var Wp = "Selector";
var Hp = { children: [["TypeSelector", "IdSelector", "ClassSelector", "AttributeSelector", "PseudoClassSelector", "PseudoElementSelector", "Combinator", "WhiteSpace"]] };
function lo() {
  let e = this.readSequence(this.scope.Selector);
  return this.getFirstListNode(e) === null && this.error("Selector is expected"), { type: "Selector", loc: this.getLocationFromList(e), children: e };
}
function Yp(e) {
  this.children(e);
}
var po = {};
b$1(po, { generate: () => Qp, name: () => Gp, parse: () => uo, structure: () => Kp, walkContext: () => Vp });
var Gp = "SelectorList";
var Vp = "selector";
var Kp = { children: [["Selector", "Raw"]] };
function uo() {
  let e = this.createList();
  for (; !this.eof; ) {
    if (e.push(this.Selector()), this.tokenType === 18) {
      this.next();
      continue;
    }
    break;
  }
  return { type: "SelectorList", loc: this.getLocationFromList(e), children: e };
}
function Qp(e) {
  this.children(e, () => this.token(18, ","));
}
var bo = {};
b$1(bo, { generate: () => Zp, name: () => Xp, parse: () => go, structure: () => $p });
var fo = {};
b$1(fo, { decode: () => ft, encode: () => mo });
var ho = 92;
var Aa = 34;
var Ta = 39;
function ft(e) {
  let t = e.length, r = e.charCodeAt(0), n = r === Aa || r === Ta ? 1 : 0, o = n === 1 && t > 1 && e.charCodeAt(t - 1) === r ? t - 2 : t - 1, i = "";
  for (let s = n; s <= o; s++) {
    let u2 = e.charCodeAt(s);
    if (u2 === ho) {
      if (s === o) {
        s !== t - 1 && (i = e.substr(s + 1));
        break;
      }
      if (u2 = e.charCodeAt(++s), $(ho, u2)) {
        let c2 = s - 1, a = se(e, c2);
        s = a - 1, i += Re(e.substring(c2 + 1, a));
      } else
        u2 === 13 && e.charCodeAt(s + 1) === 10 && s++;
    } else
      i += e[s];
  }
  return i;
}
function mo(e, t) {
  let r = t ? "'" : '"', n = t ? Ta : Aa, o = "", i = false;
  for (let s = 0; s < e.length; s++) {
    let u2 = e.charCodeAt(s);
    if (u2 === 0) {
      o += "�";
      continue;
    }
    if (u2 <= 31 || u2 === 127) {
      o += "\\" + u2.toString(16), i = true;
      continue;
    }
    u2 === n || u2 === ho ? (o += "\\" + e.charAt(s), i = false) : (i && (ee(u2) || pe(u2)) && (o += " "), o += e.charAt(s), i = false);
  }
  return r + o + r;
}
var Xp = "String";
var $p = { value: String };
function go() {
  return { type: "String", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: ft(this.consume(5)) };
}
function Zp(e) {
  this.token(5, mo(e.value));
}
var yo = {};
b$1(yo, { generate: () => nh, name: () => eh, parse: () => xo, structure: () => rh, walkContext: () => th });
var Jp = 33;
function Ea(e) {
  return this.Raw(e, null, false);
}
var eh = "StyleSheet";
var th = "stylesheet";
var rh = { children: [["Comment", "CDO", "CDC", "Atrule", "Rule", "Raw"]] };
function xo() {
  let e = this.tokenStart, t = this.createList(), r;
  for (; !this.eof; ) {
    switch (this.tokenType) {
      case 13:
        this.next();
        continue;
      case 25:
        if (this.charCodeAt(this.tokenStart + 2) !== Jp) {
          this.next();
          continue;
        }
        r = this.Comment();
        break;
      case 14:
        r = this.CDO();
        break;
      case 15:
        r = this.CDC();
        break;
      case 3:
        r = this.parseWithFallback(this.Atrule, Ea);
        break;
      default:
        r = this.parseWithFallback(this.Rule, Ea);
    }
    t.push(r);
  }
  return { type: "StyleSheet", loc: this.getLocation(e, this.tokenStart), children: t };
}
function nh(e) {
  this.children(e);
}
var vo = {};
b$1(vo, { generate: () => sh, name: () => ih, parse: () => wo, structure: () => ah });
var oh = 42;
var La = 124;
function ko() {
  this.tokenType !== 1 && this.isDelim(oh) === false && this.error("Identifier or asterisk is expected"), this.next();
}
var ih = "TypeSelector";
var ah = { name: String };
function wo() {
  let e = this.tokenStart;
  return this.isDelim(La) ? (this.next(), ko.call(this)) : (ko.call(this), this.isDelim(La) && (this.next(), ko.call(this))), { type: "TypeSelector", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e) };
}
function sh(e) {
  this.tokenize(e.name);
}
var Ao = {};
b$1(Ao, { generate: () => hh, name: () => uh, parse: () => Co, structure: () => ph });
var Pa = 43;
var Ia = 45;
var So = 63;
function dt(e, t) {
  let r = 0;
  for (let n = this.tokenStart + e; n < this.tokenEnd; n++) {
    let o = this.charCodeAt(n);
    if (o === Ia && t && r !== 0)
      return dt.call(this, e + r + 1, false), -1;
    ee(o) || this.error(t && r !== 0 ? "Hyphen minus" + (r < 6 ? " or hex digit" : "") + " is expected" : r < 6 ? "Hex digit is expected" : "Unexpected input", n), ++r > 6 && this.error("Too many hex digits", n);
  }
  return this.next(), r;
}
function Jt(e) {
  let t = 0;
  for (; this.isDelim(So); )
    ++t > e && this.error("Too many question marks"), this.next();
}
function lh(e) {
  this.charCodeAt(this.tokenStart) !== e && this.error((e === Pa ? "Plus sign" : "Hyphen minus") + " is expected");
}
function ch() {
  let e = 0;
  switch (this.tokenType) {
    case 10:
      if (e = dt.call(this, 1, true), this.isDelim(So)) {
        Jt.call(this, 6 - e);
        break;
      }
      if (this.tokenType === 12 || this.tokenType === 10) {
        lh.call(this, Ia), dt.call(this, 1, false);
        break;
      }
      break;
    case 12:
      e = dt.call(this, 1, true), e > 0 && Jt.call(this, 6 - e);
      break;
    default:
      if (this.eatDelim(Pa), this.tokenType === 1) {
        e = dt.call(this, 0, true), e > 0 && Jt.call(this, 6 - e);
        break;
      }
      if (this.isDelim(So)) {
        this.next(), Jt.call(this, 5);
        break;
      }
      this.error("Hex digit or question mark is expected");
  }
}
var uh = "UnicodeRange";
var ph = { value: String };
function Co() {
  let e = this.tokenStart;
  return this.eatIdent("u"), ch.call(this), { type: "UnicodeRange", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e) };
}
function hh(e) {
  this.tokenize(e.value);
}
var Do = {};
b$1(Do, { generate: () => yh, name: () => bh, parse: () => Io, structure: () => xh });
var Po = {};
b$1(Po, { decode: () => Eo, encode: () => Lo });
var mh = 32;
var To = 92;
var fh = 34;
var dh = 39;
var gh = 40;
var Da = 41;
function Eo(e) {
  let t = e.length, r = 4, n = e.charCodeAt(t - 1) === Da ? t - 2 : t - 1, o = "";
  for (; r < n && pe(e.charCodeAt(r)); )
    r++;
  for (; r < n && pe(e.charCodeAt(n)); )
    n--;
  for (let i = r; i <= n; i++) {
    let s = e.charCodeAt(i);
    if (s === To) {
      if (i === n) {
        i !== t - 1 && (o = e.substr(i + 1));
        break;
      }
      if (s = e.charCodeAt(++i), $(To, s)) {
        let u2 = i - 1, c2 = se(e, u2);
        i = c2 - 1, o += Re(e.substring(u2 + 1, c2));
      } else
        s === 13 && e.charCodeAt(i + 1) === 10 && i++;
    } else
      o += e[i];
  }
  return o;
}
function Lo(e) {
  let t = "", r = false;
  for (let n = 0; n < e.length; n++) {
    let o = e.charCodeAt(n);
    if (o === 0) {
      t += "�";
      continue;
    }
    if (o <= 31 || o === 127) {
      t += "\\" + o.toString(16), r = true;
      continue;
    }
    o === mh || o === To || o === fh || o === dh || o === gh || o === Da ? (t += "\\" + e.charAt(n), r = false) : (r && ee(o) && (t += " "), t += e.charAt(n), r = false);
  }
  return "url(" + t + ")";
}
var bh = "Url";
var xh = { value: String };
function Io() {
  let e = this.tokenStart, t;
  switch (this.tokenType) {
    case 7:
      t = Eo(this.consume(7));
      break;
    case 2:
      this.cmpStr(this.tokenStart, this.tokenEnd, "url(") || this.error("Function name must be `url`"), this.eat(2), this.skipSC(), t = ft(this.consume(5)), this.skipSC(), this.eof || this.eat(22);
      break;
    default:
      this.error("Url or Function is expected");
  }
  return { type: "Url", loc: this.getLocation(e, this.tokenStart), value: t };
}
function yh(e) {
  this.token(7, Lo(e.value));
}
var No = {};
b$1(No, { generate: () => vh, name: () => kh, parse: () => Oo, structure: () => wh });
var kh = "Value";
var wh = { children: [[]] };
function Oo() {
  let e = this.tokenStart, t = this.readSequence(this.scope.Value);
  return { type: "Value", loc: this.getLocation(e, this.tokenStart), children: t };
}
function vh(e) {
  this.children(e);
}
var Mo = {};
b$1(Mo, { generate: () => Th, name: () => Ch, parse: () => zo, structure: () => Ah });
var Sh = Object.freeze({ type: "WhiteSpace", loc: null, value: " " });
var Ch = "WhiteSpace";
var Ah = { value: String };
function zo() {
  return this.eat(13), Sh;
}
function Th(e) {
  this.token(13, e.value);
}
var Oa = { generic: true, ...fa, node: gt };
var Ro = {};
b$1(Ro, { AtrulePrelude: () => za, Selector: () => Ra, Value: () => qa });
var Eh = 35;
var Lh = 42;
var Na = 43;
var Ph = 45;
var Ih = 47;
var Dh = 117;
function bt(e) {
  switch (this.tokenType) {
    case 4:
      return this.Hash();
    case 18:
      return this.Operator();
    case 21:
      return this.Parentheses(this.readSequence, e.recognizer);
    case 19:
      return this.Brackets(this.readSequence, e.recognizer);
    case 5:
      return this.String();
    case 12:
      return this.Dimension();
    case 11:
      return this.Percentage();
    case 10:
      return this.Number();
    case 2:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, e.recognizer);
    case 7:
      return this.Url();
    case 1:
      return this.cmpChar(this.tokenStart, Dh) && this.cmpChar(this.tokenStart + 1, Na) ? this.UnicodeRange() : this.Identifier();
    case 9: {
      let t = this.charCodeAt(this.tokenStart);
      if (t === Ih || t === Lh || t === Na || t === Ph)
        return this.Operator();
      t === Eh && this.error("Hex or identifier is expected", this.tokenStart + 1);
      break;
    }
  }
}
var za = { getNode: bt };
var Oh = 35;
var Nh = 38;
var zh = 42;
var Mh = 43;
var Rh = 47;
var Ma = 46;
var Fh = 62;
var Bh = 124;
var _h = 126;
function qh(e, t) {
  t.last !== null && t.last.type !== "Combinator" && e !== null && e.type !== "Combinator" && t.push({ type: "Combinator", loc: null, name: " " });
}
function Uh() {
  switch (this.tokenType) {
    case 19:
      return this.AttributeSelector();
    case 4:
      return this.IdSelector();
    case 16:
      return this.lookupType(1) === 16 ? this.PseudoElementSelector() : this.PseudoClassSelector();
    case 1:
      return this.TypeSelector();
    case 10:
    case 11:
      return this.Percentage();
    case 12:
      this.charCodeAt(this.tokenStart) === Ma && this.error("Identifier is expected", this.tokenStart + 1);
      break;
    case 9: {
      switch (this.charCodeAt(this.tokenStart)) {
        case Mh:
        case Fh:
        case _h:
        case Rh:
          return this.Combinator();
        case Ma:
          return this.ClassSelector();
        case zh:
        case Bh:
          return this.TypeSelector();
        case Oh:
          return this.IdSelector();
        case Nh:
          return this.NestingSelector();
      }
      break;
    }
  }
}
var Ra = { onWhiteSpace: qh, getNode: Uh };
function Fa() {
  return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
}
function Ba() {
  let e = this.createList();
  if (this.skipSC(), e.push(this.Identifier()), this.skipSC(), this.tokenType === 18) {
    e.push(this.Operator());
    let t = this.tokenIndex, r = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
    if (r.type === "Value" && r.children.isEmpty) {
      for (let n = t - this.tokenIndex; n <= 0; n++)
        if (this.lookupType(n) === 13) {
          r.children.appendData({ type: "WhiteSpace", loc: null, value: " " });
          break;
        }
    }
    e.push(r);
  }
  return e;
}
function _a(e) {
  return e !== null && e.type === "Operator" && (e.value[e.value.length - 1] === "-" || e.value[e.value.length - 1] === "+");
}
var qa = { getNode: bt, onWhiteSpace(e, t) {
  _a(e) && (e.value = " " + e.value), _a(t.last) && (t.last.value += " ");
}, expression: Fa, var: Ba };
var Ua = { parse: { prelude: null, block() {
  return this.Block(true);
} } };
var ja = { parse: { prelude() {
  let e = this.createList();
  switch (this.skipSC(), this.tokenType) {
    case 5:
      e.push(this.String());
      break;
    case 7:
    case 2:
      e.push(this.Url());
      break;
    default:
      this.error("String or url() is expected");
  }
  return (this.lookupNonWSType(0) === 1 || this.lookupNonWSType(0) === 21) && e.push(this.MediaQueryList()), e;
}, block: null } };
var Wa = { parse: { prelude() {
  return this.createSingleNodeList(this.MediaQueryList());
}, block(e = false) {
  return this.Block(e);
} } };
var Ha = { parse: { prelude() {
  return this.createSingleNodeList(this.SelectorList());
}, block() {
  return this.Block(true);
} } };
var Ya = { parse: { prelude() {
  return this.createSingleNodeList(this.SelectorList());
}, block() {
  return this.Block(true);
} } };
function jh() {
  return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
}
function Wh() {
  return this.skipSC(), this.tokenType === 1 && this.lookupNonWSType(1) === 16 ? this.createSingleNodeList(this.Declaration()) : Ga.call(this);
}
function Ga() {
  let e = this.createList(), t;
  this.skipSC();
  e:
    for (; !this.eof; ) {
      switch (this.tokenType) {
        case 25:
        case 13:
          this.next();
          continue;
        case 2:
          t = this.Function(jh, this.scope.AtrulePrelude);
          break;
        case 1:
          t = this.Identifier();
          break;
        case 21:
          t = this.Parentheses(Wh, this.scope.AtrulePrelude);
          break;
        default:
          break e;
      }
      e.push(t);
    }
  return e;
}
var Va = { parse: { prelude() {
  let e = Ga.call(this);
  return this.getFirstListNode(e) === null && this.error("Condition is expected"), e;
}, block(e = false) {
  return this.Block(e);
} } };
var Ka = { "font-face": Ua, import: ja, media: Wa, nest: Ha, page: Ya, supports: Va };
var De = { parse() {
  return this.createSingleNodeList(this.SelectorList());
} };
var Fo = { parse() {
  return this.createSingleNodeList(this.Selector());
} };
var Qa = { parse() {
  return this.createSingleNodeList(this.Identifier());
} };
var er = { parse() {
  return this.createSingleNodeList(this.Nth());
} };
var Xa = { dir: Qa, has: De, lang: Qa, matches: De, is: De, "-moz-any": De, "-webkit-any": De, where: De, not: De, "nth-child": er, "nth-last-child": er, "nth-last-of-type": er, "nth-of-type": er, slotted: Fo, host: Fo, "host-context": Fo };
var Bo = {};
b$1(Bo, { AnPlusB: () => Qr, Atrule: () => $r, AtrulePrelude: () => Jr, AttributeSelector: () => rn, Block: () => on, Brackets: () => sn, CDC: () => cn, CDO: () => pn, ClassSelector: () => mn, Combinator: () => dn, Comment: () => bn, Declaration: () => yn, DeclarationList: () => vn, Dimension: () => Cn, Function: () => Tn, Hash: () => Ln, IdSelector: () => On, Identifier: () => In, MediaFeature: () => zn, MediaQuery: () => Rn, MediaQueryList: () => Bn, NestingSelector: () => qn, Nth: () => jn, Number: () => Hn, Operator: () => Gn, Parentheses: () => Kn, Percentage: () => Xn, PseudoClassSelector: () => Zn, PseudoElementSelector: () => eo, Ratio: () => ro, Raw: () => oo, Rule: () => ao, Selector: () => lo, SelectorList: () => uo, String: () => go, StyleSheet: () => xo, TypeSelector: () => wo, UnicodeRange: () => Co, Url: () => Io, Value: () => Oo, WhiteSpace: () => zo });
var $a = { parseContext: { default: "StyleSheet", stylesheet: "StyleSheet", atrule: "Atrule", atrulePrelude(e) {
  return this.AtrulePrelude(e.atrule ? String(e.atrule) : null);
}, mediaQueryList: "MediaQueryList", mediaQuery: "MediaQuery", rule: "Rule", selectorList: "SelectorList", selector: "Selector", block() {
  return this.Block(true);
}, declarationList: "DeclarationList", declaration: "Declaration", value: "Value" }, scope: Ro, atrule: Ka, pseudo: Xa, node: Bo };
var Za = { node: gt };
var Ja = Vr({ ...Oa, ...$a, ...Za });
var ts = {};
b$1(ts, { decode: () => Hh, encode: () => Yh });
var es = 92;
function Hh(e) {
  let t = e.length - 1, r = "";
  for (let n = 0; n < e.length; n++) {
    let o = e.charCodeAt(n);
    if (o === es) {
      if (n === t)
        break;
      if (o = e.charCodeAt(++n), $(es, o)) {
        let i = n - 1, s = se(e, i);
        n = s - 1, r += Re(e.substring(i + 1, s));
      } else
        o === 13 && e.charCodeAt(n + 1) === 10 && n++;
    } else
      r += e[n];
  }
  return r;
}
function Yh(e) {
  let t = "";
  if (e.length === 1 && e.charCodeAt(0) === 45)
    return "\\-";
  for (let r = 0; r < e.length; r++) {
    let n = e.charCodeAt(r);
    if (n === 0) {
      t += "�";
      continue;
    }
    if (n <= 31 || n === 127 || n >= 48 && n <= 57 && (r === 0 || r === 1 && e.charCodeAt(0) === 45)) {
      t += "\\" + n.toString(16) + " ";
      continue;
    }
    Ne(n) ? t += e.charAt(r) : t += "\\" + e.charAt(r);
  }
  return t;
}
var { tokenize: fb, parse: db, generate: gb, lexer: bb, createLexer: xb, walk: yb, find: kb, findLast: wb, findAll: vb, toPlainObject: Sb, fromPlainObject: Cb, fork: Ab } = Ja;
var EOF = 0;
var Ident = 1;
var Function$1 = 2;
var Delim = 9;
var Number$1 = 10;
var Dimension = 12;
var WhiteSpace = 13;
var Colon = 16;
var LeftParenthesis = 21;
var RightParenthesis = 22;
var LeftCurlyBracket = 23;
var Comment = 25;
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isUppercaseLetter(code2) {
  return code2 >= 65 && code2 <= 90;
}
function isLowercaseLetter(code2) {
  return code2 >= 97 && code2 <= 122;
}
function isLetter(code2) {
  return isUppercaseLetter(code2) || isLowercaseLetter(code2);
}
function isNonAscii(code2) {
  return code2 >= 128;
}
function isNameStart(code2) {
  return isLetter(code2) || isNonAscii(code2) || code2 === 95;
}
function isNonPrintable(code2) {
  return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
}
function isNewline(code2) {
  return code2 === 10 || code2 === 13 || code2 === 12;
}
function isWhiteSpace(code2) {
  return isNewline(code2) || code2 === 32 || code2 === 9;
}
var CATEGORY = new Array(128);
var EofCategory = 128;
var WhiteSpaceCategory = 130;
var DigitCategory = 131;
var NameStartCategory = 132;
var NonPrintableCategory = 133;
for (let i = 0; i < CATEGORY.length; i++) {
  CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
}
var name = "Comparison";
var structure = {
  value: String
};
function parse$3() {
  const start2 = this.tokenStart;
  const char1 = this.consume(Delim);
  if (char1 !== "<" && char1 !== ">" && char1 !== "=") {
    this.error("Malformed comparison operator");
  }
  let char2;
  if (this.tokenType === Delim) {
    char2 = this.consume(Delim);
    if (char2 !== "=") {
      this.error("Malformed comparison operator");
    }
  }
  if (this.tokenType === Delim) {
    this.error("Malformed comparison operator");
  }
  const value = char2 ? `${char1}${char2}` : char1;
  return {
    type: "Comparison",
    loc: this.getLocation(start2, this.tokenStart),
    value
  };
}
function generate(node2) {
  for (let index2 = 0; index2 < node2.value.length; index2++) {
    this.token(Delim, node2.value.charAt(index2));
  }
}
var comparison = Object.freeze({
  __proto__: null,
  name,
  structure,
  parse: parse$3,
  generate
});
var name$1 = "ContainerFeatureStyle";
var structure$1 = {
  name: String,
  value: ["Function", "Identifier", "Number", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function parse$4() {
  const start2 = this.tokenStart;
  let value = null;
  const function_name = this.consumeFunctionName();
  if (function_name !== "style") {
    this.error('Unknown container style query identifier; "style" is expected');
  }
  this.skipSC();
  const name3 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number$1:
        if (this.lookupNonWSType(1) === Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }
        break;
      case Dimension:
        value = this.Dimension();
        break;
      case Function$1:
        value = this.QueryCSSFunction();
        break;
      case Ident:
        value = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio, function or identifier is expected");
        break;
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "ContainerFeatureStyle",
    loc: this.getLocation(start2, this.tokenStart),
    name: name3,
    value
  };
}
function generate$1(node2) {
  this.token(Function$1, "style(");
  this.token(Ident, node2.name);
  if (node2.value !== null) {
    this.token(Colon, ":");
    this.node(node2.value);
  }
  this.token(RightParenthesis, ")");
}
var container_feature_style = Object.freeze({
  __proto__: null,
  name: name$1,
  structure: structure$1,
  parse: parse$4,
  generate: generate$1
});
function lookahead_is_range() {
  let type2;
  let offset2 = 0;
  let count = 0;
  let delim_found = false;
  let no_colon = true;
  do {
    type2 = this.lookupNonWSType(offset2++);
    if (type2 !== WhiteSpace) {
      count++;
    }
    if (type2 === Delim) {
      delim_found = true;
    }
    if (type2 === Colon) {
      no_colon = false;
    }
    if (type2 === LeftCurlyBracket || type2 === RightParenthesis) {
      break;
    }
  } while (type2 !== EOF && count <= 6);
  return delim_found && no_colon;
}
var CONTAINER_QUERY_KEYWORDS = /* @__PURE__ */ new Set(["none", "and", "not", "or"]);
var name$2 = "ContainerQuery";
var structure$2 = {
  name: "Identifier",
  children: [[
    "Identifier",
    "QueryFeature",
    "QueryFeatureRange",
    "ContainerFeatureStyle",
    "WhiteSpace"
  ]]
};
function parse$5() {
  const start2 = this.tokenStart;
  const children = this.createList();
  let child = null;
  let name3 = null;
  if (this.tokenType === Ident) {
    const container_name = this.substring(this.tokenStart, this.tokenEnd);
    if (!CONTAINER_QUERY_KEYWORDS.has(container_name.toLowerCase())) {
      name3 = container_name;
      this.eatIdent(container_name);
    }
  }
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case Function$1:
          child = this.ContainerFeatureStyle();
          break;
        case LeftParenthesis:
          child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "ContainerQuery",
    loc: this.getLocation(start2, this.tokenStart - 1),
    name: name3,
    children
  };
}
function generate$2(node2) {
  if (typeof node2.name === "string") {
    this.token(Ident, node2.name);
  }
  this.children(node2);
}
var container_query = Object.freeze({
  __proto__: null,
  name: name$2,
  structure: structure$2,
  parse: parse$5,
  generate: generate$2
});
var name$3 = "MediaQuery";
var structure$3 = {
  children: [[
    "Identifier",
    "QueryFeature",
    "QueryFeatureRange",
    "WhiteSpace"
  ]]
};
function parse$6() {
  const children = this.createList();
  let child = null;
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case LeftParenthesis:
          child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "MediaQuery",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$3(node2) {
  this.children(node2);
}
var media_query = Object.freeze({
  __proto__: null,
  name: name$3,
  structure: structure$3,
  parse: parse$6,
  generate: generate$3
});
var name$4 = "QueryFeature";
var structure$4 = {
  name: String,
  value: ["Identifier", "Number", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function parse$7() {
  const start2 = this.tokenStart;
  let value = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  const name3 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number$1:
        if (this.lookupNonWSType(1) === Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }
        break;
      case Dimension:
        value = this.Dimension();
        break;
      case Function$1:
        value = this.QueryCSSFunction();
        break;
      case Ident:
        value = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio, function, or identifier is expected");
        break;
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "QueryFeature",
    loc: this.getLocation(start2, this.tokenStart),
    name: name3,
    value
  };
}
function generate$4(node2) {
  this.token(LeftParenthesis, "(");
  this.token(Ident, node2.name);
  if (node2.value !== null) {
    this.token(Colon, ":");
    this.node(node2.value);
  }
  this.token(RightParenthesis, ")");
}
var query_feature = Object.freeze({
  __proto__: null,
  name: name$4,
  structure: structure$4,
  parse: parse$7,
  generate: generate$4
});
var name$5 = "QueryFeatureRange";
var structure$5 = {
  name: String,
  value: ["Identifier", "Number", "Comparison", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function lookup_non_WS_type_and_value(offset2, type2, referenceStr) {
  let current_type;
  do {
    current_type = this.lookupType(offset2++);
    if (current_type !== WhiteSpace) {
      break;
    }
  } while (current_type !== 0);
  return current_type === type2 ? this.lookupValue(offset2 - 1, referenceStr) : false;
}
function parse$8() {
  const start2 = this.tokenStart;
  const children = this.createList();
  let child = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  while (!this.eof && this.tokenType !== RightParenthesis) {
    switch (this.tokenType) {
      case Number$1:
        if (lookup_non_WS_type_and_value.call(this, 1, Delim, "/")) {
          child = this.Ratio();
        } else {
          child = this.Number();
        }
        break;
      case Delim:
        child = this.Comparison();
        break;
      case Dimension:
        child = this.Dimension();
        break;
      case Function$1:
        child = this.QueryCSSFunction();
        break;
      case Ident:
        child = this.Identifier();
        break;
      default:
        this.error("Number, dimension, comparison, ratio, function, or identifier is expected");
        break;
    }
    children.push(child);
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "QueryFeatureRange",
    loc: this.getLocation(start2, this.tokenStart),
    children
  };
}
function generate$5(node2) {
  this.children(node2);
}
var query_feature_range = Object.freeze({
  __proto__: null,
  name: name$5,
  structure: structure$5,
  parse: parse$8,
  generate: generate$5
});
var QUERY_CSS_FUNCTIONS = /* @__PURE__ */ new Set(["calc", "clamp", "min", "max"]);
var name$6 = "QueryCSSFunction";
var structure$6 = {
  name: String,
  expression: String
};
function parse$9() {
  const start2 = this.tokenStart;
  const name3 = this.consumeFunctionName();
  if (!QUERY_CSS_FUNCTIONS.has(name3)) {
    this.error('Unknown query single value function; expected: "calc", "clamp", "max", min"');
  }
  const body2 = this.Raw(this.tokenIndex, null, false);
  this.eat(RightParenthesis);
  return {
    type: "QueryCSSFunction",
    loc: this.getLocation(start2, this.tokenStart),
    name: name3,
    expression: body2.value
  };
}
function generate$6(node2) {
  this.token(Function, `${node2.name}(`);
  this.node(node2.expression);
  this.token(RightParenthesis, ")");
}
var query_css_function = Object.freeze({
  __proto__: null,
  name: name$6,
  structure: structure$6,
  parse: parse$9,
  generate: generate$6
});
var node = Object.freeze({
  __proto__: null,
  Comparison: comparison,
  ContainerFeatureStyle: container_feature_style,
  ContainerQuery: container_query,
  MediaQuery: media_query,
  QueryFeature: query_feature,
  QueryFeatureRange: query_feature_range,
  QueryCSSFunction: query_css_function
});
var cqSyntax = Ab({
  atrule: {
    container: {
      parse: {
        prelude() {
          return this.createSingleNodeList(this.ContainerQuery());
        },
        block(isStyleBlock = false) {
          return this.Block(isStyleBlock);
        }
      }
    }
  },
  node
});
var parse$a = cqSyntax.parse;
var regex_closing_style_tag = /<\/style\s*>/;
var regex_starts_with_closing_style_tag = /^<\/style\s*>/;
function read_style(parser2, start2, attributes2) {
  const content_start = parser2.index;
  const styles = parser2.read_until(regex_closing_style_tag, parser_errors.unclosed_style);
  if (parser2.index >= parser2.template.length) {
    parser2.error(parser_errors.unclosed_style);
  }
  const content_end = parser2.index;
  if (parser2.css_mode === "none") {
    parser2.read(regex_starts_with_closing_style_tag);
    return null;
  }
  let ast2;
  try {
    ast2 = parse$a(styles, {
      positions: true,
      offset: content_start,
      onParseError(error2) {
        throw error2;
      }
    });
  } catch (err) {
    if (err.name === "SyntaxError") {
      parser2.error(parser_errors.css_syntax_error(err.message), err.offset);
    } else {
      throw err;
    }
  }
  ast2 = JSON.parse(JSON.stringify(ast2));
  walk(ast2, {
    enter: (node2) => {
      if (node2.type === "Selector") {
        for (let i = 0; i < node2.children.length; i += 1) {
          const a = node2.children[i];
          const b = node2.children[i + 1];
          if (is_ref_selector(a, b)) {
            parser2.error(parser_errors.invalid_ref_selector, a.loc.start.offset);
          }
        }
      }
      if (node2.type === "Declaration" && node2.value.type === "Value" && node2.value.children.length === 0) {
        parser2.error(parser_errors.invalid_declaration, node2.start);
      }
      if (node2.type === "PseudoClassSelector" && node2.name === "global" && node2.children === null) {
        parser2.error(parser_errors.empty_global_selector, node2.loc.start.offset);
      }
      if (node2.loc) {
        node2.start = node2.loc.start.offset;
        node2.end = node2.loc.end.offset;
        delete node2.loc;
      }
    }
  });
  parser2.read(regex_starts_with_closing_style_tag);
  const end2 = parser2.index;
  return {
    type: "Style",
    start: start2,
    end: end2,
    attributes: attributes2,
    children: ast2.children,
    content: {
      start: content_start,
      end: content_end,
      styles
    }
  };
}
function is_ref_selector(a, b) {
  if (!b)
    return false;
  return a.type === "TypeSelector" && a.name === "ref" && b.type === "PseudoClassSelector";
}
var entities = {
  "CounterClockwiseContourIntegral;": 8755,
  "ClockwiseContourIntegral;": 8754,
  "DoubleLongLeftRightArrow;": 10234,
  "NotNestedGreaterGreater;": 10914,
  "DiacriticalDoubleAcute;": 733,
  "NotSquareSupersetEqual;": 8931,
  "CloseCurlyDoubleQuote;": 8221,
  "DoubleContourIntegral;": 8751,
  "FilledVerySmallSquare;": 9642,
  "NegativeVeryThinSpace;": 8203,
  "NotPrecedesSlantEqual;": 8928,
  "NotRightTriangleEqual;": 8941,
  "NotSucceedsSlantEqual;": 8929,
  "CapitalDifferentialD;": 8517,
  "DoubleLeftRightArrow;": 8660,
  "DoubleLongRightArrow;": 10233,
  "EmptyVerySmallSquare;": 9643,
  "NestedGreaterGreater;": 8811,
  "NotDoubleVerticalBar;": 8742,
  "NotGreaterSlantEqual;": 10878,
  "NotLeftTriangleEqual;": 8940,
  "NotSquareSubsetEqual;": 8930,
  "OpenCurlyDoubleQuote;": 8220,
  "ReverseUpEquilibrium;": 10607,
  "DoubleLongLeftArrow;": 10232,
  "DownLeftRightVector;": 10576,
  "LeftArrowRightArrow;": 8646,
  "NegativeMediumSpace;": 8203,
  "NotGreaterFullEqual;": 8807,
  "NotRightTriangleBar;": 10704,
  "RightArrowLeftArrow;": 8644,
  "SquareSupersetEqual;": 8850,
  "leftrightsquigarrow;": 8621,
  "DownRightTeeVector;": 10591,
  "DownRightVectorBar;": 10583,
  "LongLeftRightArrow;": 10231,
  "Longleftrightarrow;": 10234,
  "NegativeThickSpace;": 8203,
  "NotLeftTriangleBar;": 10703,
  "PrecedesSlantEqual;": 8828,
  "ReverseEquilibrium;": 8651,
  "RightDoubleBracket;": 10215,
  "RightDownTeeVector;": 10589,
  "RightDownVectorBar;": 10581,
  "RightTriangleEqual;": 8885,
  "SquareIntersection;": 8851,
  "SucceedsSlantEqual;": 8829,
  "blacktriangleright;": 9656,
  "longleftrightarrow;": 10231,
  "DoubleUpDownArrow;": 8661,
  "DoubleVerticalBar;": 8741,
  "DownLeftTeeVector;": 10590,
  "DownLeftVectorBar;": 10582,
  "FilledSmallSquare;": 9724,
  "GreaterSlantEqual;": 10878,
  "LeftDoubleBracket;": 10214,
  "LeftDownTeeVector;": 10593,
  "LeftDownVectorBar;": 10585,
  "LeftTriangleEqual;": 8884,
  "NegativeThinSpace;": 8203,
  "NotGreaterGreater;": 8811,
  "NotLessSlantEqual;": 10877,
  "NotNestedLessLess;": 10913,
  "NotReverseElement;": 8716,
  "NotSquareSuperset;": 8848,
  "NotTildeFullEqual;": 8775,
  "RightAngleBracket;": 10217,
  "RightUpDownVector;": 10575,
  "SquareSubsetEqual;": 8849,
  "VerticalSeparator;": 10072,
  "blacktriangledown;": 9662,
  "blacktriangleleft;": 9666,
  "leftrightharpoons;": 8651,
  "rightleftharpoons;": 8652,
  "twoheadrightarrow;": 8608,
  "DiacriticalAcute;": 180,
  "DiacriticalGrave;": 96,
  "DiacriticalTilde;": 732,
  "DoubleRightArrow;": 8658,
  "DownArrowUpArrow;": 8693,
  "EmptySmallSquare;": 9723,
  "GreaterEqualLess;": 8923,
  "GreaterFullEqual;": 8807,
  "LeftAngleBracket;": 10216,
  "LeftUpDownVector;": 10577,
  "LessEqualGreater;": 8922,
  "NonBreakingSpace;": 160,
  "NotPrecedesEqual;": 10927,
  "NotRightTriangle;": 8939,
  "NotSucceedsEqual;": 10928,
  "NotSucceedsTilde;": 8831,
  "NotSupersetEqual;": 8841,
  "RightTriangleBar;": 10704,
  "RightUpTeeVector;": 10588,
  "RightUpVectorBar;": 10580,
  "UnderParenthesis;": 9181,
  "UpArrowDownArrow;": 8645,
  "circlearrowright;": 8635,
  "downharpoonright;": 8642,
  "ntrianglerighteq;": 8941,
  "rightharpoondown;": 8641,
  "rightrightarrows;": 8649,
  "twoheadleftarrow;": 8606,
  "vartriangleright;": 8883,
  "CloseCurlyQuote;": 8217,
  "ContourIntegral;": 8750,
  "DoubleDownArrow;": 8659,
  "DoubleLeftArrow;": 8656,
  "DownRightVector;": 8641,
  "LeftRightVector;": 10574,
  "LeftTriangleBar;": 10703,
  "LeftUpTeeVector;": 10592,
  "LeftUpVectorBar;": 10584,
  "LowerRightArrow;": 8600,
  "NotGreaterEqual;": 8817,
  "NotGreaterTilde;": 8821,
  "NotHumpDownHump;": 8782,
  "NotLeftTriangle;": 8938,
  "NotSquareSubset;": 8847,
  "OverParenthesis;": 9180,
  "RightDownVector;": 8642,
  "ShortRightArrow;": 8594,
  "UpperRightArrow;": 8599,
  "bigtriangledown;": 9661,
  "circlearrowleft;": 8634,
  "curvearrowright;": 8631,
  "downharpoonleft;": 8643,
  "leftharpoondown;": 8637,
  "leftrightarrows;": 8646,
  "nLeftrightarrow;": 8654,
  "nleftrightarrow;": 8622,
  "ntrianglelefteq;": 8940,
  "rightleftarrows;": 8644,
  "rightsquigarrow;": 8605,
  "rightthreetimes;": 8908,
  "straightepsilon;": 1013,
  "trianglerighteq;": 8885,
  "vartriangleleft;": 8882,
  "DiacriticalDot;": 729,
  "DoubleRightTee;": 8872,
  "DownLeftVector;": 8637,
  "GreaterGreater;": 10914,
  "HorizontalLine;": 9472,
  "InvisibleComma;": 8291,
  "InvisibleTimes;": 8290,
  "LeftDownVector;": 8643,
  "LeftRightArrow;": 8596,
  "Leftrightarrow;": 8660,
  "LessSlantEqual;": 10877,
  "LongRightArrow;": 10230,
  "Longrightarrow;": 10233,
  "LowerLeftArrow;": 8601,
  "NestedLessLess;": 8810,
  "NotGreaterLess;": 8825,
  "NotLessGreater;": 8824,
  "NotSubsetEqual;": 8840,
  "NotVerticalBar;": 8740,
  "OpenCurlyQuote;": 8216,
  "ReverseElement;": 8715,
  "RightTeeVector;": 10587,
  "RightVectorBar;": 10579,
  "ShortDownArrow;": 8595,
  "ShortLeftArrow;": 8592,
  "SquareSuperset;": 8848,
  "TildeFullEqual;": 8773,
  "UpperLeftArrow;": 8598,
  "ZeroWidthSpace;": 8203,
  "curvearrowleft;": 8630,
  "doublebarwedge;": 8966,
  "downdownarrows;": 8650,
  "hookrightarrow;": 8618,
  "leftleftarrows;": 8647,
  "leftrightarrow;": 8596,
  "leftthreetimes;": 8907,
  "longrightarrow;": 10230,
  "looparrowright;": 8620,
  "nshortparallel;": 8742,
  "ntriangleright;": 8939,
  "rightarrowtail;": 8611,
  "rightharpoonup;": 8640,
  "trianglelefteq;": 8884,
  "upharpoonright;": 8638,
  "ApplyFunction;": 8289,
  "DifferentialD;": 8518,
  "DoubleLeftTee;": 10980,
  "DoubleUpArrow;": 8657,
  "LeftTeeVector;": 10586,
  "LeftVectorBar;": 10578,
  "LessFullEqual;": 8806,
  "LongLeftArrow;": 10229,
  "Longleftarrow;": 10232,
  "NotEqualTilde;": 8770,
  "NotTildeEqual;": 8772,
  "NotTildeTilde;": 8777,
  "Poincareplane;": 8460,
  "PrecedesEqual;": 10927,
  "PrecedesTilde;": 8830,
  "RightArrowBar;": 8677,
  "RightTeeArrow;": 8614,
  "RightTriangle;": 8883,
  "RightUpVector;": 8638,
  "SucceedsEqual;": 10928,
  "SucceedsTilde;": 8831,
  "SupersetEqual;": 8839,
  "UpEquilibrium;": 10606,
  "VerticalTilde;": 8768,
  "VeryThinSpace;": 8202,
  "bigtriangleup;": 9651,
  "blacktriangle;": 9652,
  "divideontimes;": 8903,
  "fallingdotseq;": 8786,
  "hookleftarrow;": 8617,
  "leftarrowtail;": 8610,
  "leftharpoonup;": 8636,
  "longleftarrow;": 10229,
  "looparrowleft;": 8619,
  "measuredangle;": 8737,
  "ntriangleleft;": 8938,
  "shortparallel;": 8741,
  "smallsetminus;": 8726,
  "triangleright;": 9657,
  "upharpoonleft;": 8639,
  "varsubsetneqq;": 10955,
  "varsupsetneqq;": 10956,
  "DownArrowBar;": 10515,
  "DownTeeArrow;": 8615,
  "ExponentialE;": 8519,
  "GreaterEqual;": 8805,
  "GreaterTilde;": 8819,
  "HilbertSpace;": 8459,
  "HumpDownHump;": 8782,
  "Intersection;": 8898,
  "LeftArrowBar;": 8676,
  "LeftTeeArrow;": 8612,
  "LeftTriangle;": 8882,
  "LeftUpVector;": 8639,
  "NotCongruent;": 8802,
  "NotHumpEqual;": 8783,
  "NotLessEqual;": 8816,
  "NotLessTilde;": 8820,
  "Proportional;": 8733,
  "RightCeiling;": 8969,
  "RoundImplies;": 10608,
  "ShortUpArrow;": 8593,
  "SquareSubset;": 8847,
  "UnderBracket;": 9141,
  "VerticalLine;": 124,
  "blacklozenge;": 10731,
  "exponentiale;": 8519,
  "risingdotseq;": 8787,
  "triangledown;": 9663,
  "triangleleft;": 9667,
  "varsubsetneq;": 8842,
  "varsupsetneq;": 8843,
  "CircleMinus;": 8854,
  "CircleTimes;": 8855,
  "Equilibrium;": 8652,
  "GreaterLess;": 8823,
  "LeftCeiling;": 8968,
  "LessGreater;": 8822,
  "MediumSpace;": 8287,
  "NotLessLess;": 8810,
  "NotPrecedes;": 8832,
  "NotSucceeds;": 8833,
  "NotSuperset;": 8835,
  "OverBracket;": 9140,
  "RightVector;": 8640,
  "Rrightarrow;": 8667,
  "RuleDelayed;": 10740,
  "SmallCircle;": 8728,
  "SquareUnion;": 8852,
  "SubsetEqual;": 8838,
  "UpDownArrow;": 8597,
  "Updownarrow;": 8661,
  "VerticalBar;": 8739,
  "backepsilon;": 1014,
  "blacksquare;": 9642,
  "circledcirc;": 8858,
  "circleddash;": 8861,
  "curlyeqprec;": 8926,
  "curlyeqsucc;": 8927,
  "diamondsuit;": 9830,
  "eqslantless;": 10901,
  "expectation;": 8496,
  "nRightarrow;": 8655,
  "nrightarrow;": 8603,
  "preccurlyeq;": 8828,
  "precnapprox;": 10937,
  "quaternions;": 8461,
  "straightphi;": 981,
  "succcurlyeq;": 8829,
  "succnapprox;": 10938,
  "thickapprox;": 8776,
  "updownarrow;": 8597,
  "Bernoullis;": 8492,
  "CirclePlus;": 8853,
  "EqualTilde;": 8770,
  "Fouriertrf;": 8497,
  "ImaginaryI;": 8520,
  "Laplacetrf;": 8466,
  "LeftVector;": 8636,
  "Lleftarrow;": 8666,
  "NotElement;": 8713,
  "NotGreater;": 8815,
  "Proportion;": 8759,
  "RightArrow;": 8594,
  "RightFloor;": 8971,
  "Rightarrow;": 8658,
  "ThickSpace;": 8287,
  "TildeEqual;": 8771,
  "TildeTilde;": 8776,
  "UnderBrace;": 9183,
  "UpArrowBar;": 10514,
  "UpTeeArrow;": 8613,
  "circledast;": 8859,
  "complement;": 8705,
  "curlywedge;": 8911,
  "eqslantgtr;": 10902,
  "gtreqqless;": 10892,
  "lessapprox;": 10885,
  "lesseqqgtr;": 10891,
  "lmoustache;": 9136,
  "longmapsto;": 10236,
  "mapstodown;": 8615,
  "mapstoleft;": 8612,
  "nLeftarrow;": 8653,
  "nleftarrow;": 8602,
  "nsubseteqq;": 10949,
  "nsupseteqq;": 10950,
  "precapprox;": 10935,
  "rightarrow;": 8594,
  "rmoustache;": 9137,
  "sqsubseteq;": 8849,
  "sqsupseteq;": 8850,
  "subsetneqq;": 10955,
  "succapprox;": 10936,
  "supsetneqq;": 10956,
  "upuparrows;": 8648,
  "varepsilon;": 1013,
  "varnothing;": 8709,
  "Backslash;": 8726,
  "CenterDot;": 183,
  "CircleDot;": 8857,
  "Congruent;": 8801,
  "Coproduct;": 8720,
  "DoubleDot;": 168,
  "DownArrow;": 8595,
  "DownBreve;": 785,
  "Downarrow;": 8659,
  "HumpEqual;": 8783,
  "LeftArrow;": 8592,
  "LeftFloor;": 8970,
  "Leftarrow;": 8656,
  "LessTilde;": 8818,
  "Mellintrf;": 8499,
  "MinusPlus;": 8723,
  "NotCupCap;": 8813,
  "NotExists;": 8708,
  "NotSubset;": 8834,
  "OverBrace;": 9182,
  "PlusMinus;": 177,
  "Therefore;": 8756,
  "ThinSpace;": 8201,
  "TripleDot;": 8411,
  "UnionPlus;": 8846,
  "backprime;": 8245,
  "backsimeq;": 8909,
  "bigotimes;": 10754,
  "centerdot;": 183,
  "checkmark;": 10003,
  "complexes;": 8450,
  "dotsquare;": 8865,
  "downarrow;": 8595,
  "gtrapprox;": 10886,
  "gtreqless;": 8923,
  "gvertneqq;": 8809,
  "heartsuit;": 9829,
  "leftarrow;": 8592,
  "lesseqgtr;": 8922,
  "lvertneqq;": 8808,
  "ngeqslant;": 10878,
  "nleqslant;": 10877,
  "nparallel;": 8742,
  "nshortmid;": 8740,
  "nsubseteq;": 8840,
  "nsupseteq;": 8841,
  "pitchfork;": 8916,
  "rationals;": 8474,
  "spadesuit;": 9824,
  "subseteqq;": 10949,
  "subsetneq;": 8842,
  "supseteqq;": 10950,
  "supsetneq;": 8843,
  "therefore;": 8756,
  "triangleq;": 8796,
  "varpropto;": 8733,
  "DDotrahd;": 10513,
  "DotEqual;": 8784,
  "Integral;": 8747,
  "LessLess;": 10913,
  "NotEqual;": 8800,
  "NotTilde;": 8769,
  "PartialD;": 8706,
  "Precedes;": 8826,
  "RightTee;": 8866,
  "Succeeds;": 8827,
  "SuchThat;": 8715,
  "Superset;": 8835,
  "Uarrocir;": 10569,
  "UnderBar;": 95,
  "andslope;": 10840,
  "angmsdaa;": 10664,
  "angmsdab;": 10665,
  "angmsdac;": 10666,
  "angmsdad;": 10667,
  "angmsdae;": 10668,
  "angmsdaf;": 10669,
  "angmsdag;": 10670,
  "angmsdah;": 10671,
  "angrtvbd;": 10653,
  "approxeq;": 8778,
  "awconint;": 8755,
  "backcong;": 8780,
  "barwedge;": 8965,
  "bbrktbrk;": 9142,
  "bigoplus;": 10753,
  "bigsqcup;": 10758,
  "biguplus;": 10756,
  "bigwedge;": 8896,
  "boxminus;": 8863,
  "boxtimes;": 8864,
  "bsolhsub;": 10184,
  "capbrcup;": 10825,
  "circledR;": 174,
  "circledS;": 9416,
  "cirfnint;": 10768,
  "clubsuit;": 9827,
  "cupbrcap;": 10824,
  "curlyvee;": 8910,
  "cwconint;": 8754,
  "doteqdot;": 8785,
  "dotminus;": 8760,
  "drbkarow;": 10512,
  "dzigrarr;": 10239,
  "elinters;": 9191,
  "emptyset;": 8709,
  "eqvparsl;": 10725,
  "fpartint;": 10765,
  "geqslant;": 10878,
  "gesdotol;": 10884,
  "gnapprox;": 10890,
  "hksearow;": 10533,
  "hkswarow;": 10534,
  "imagline;": 8464,
  "imagpart;": 8465,
  "infintie;": 10717,
  "integers;": 8484,
  "intercal;": 8890,
  "intlarhk;": 10775,
  "laemptyv;": 10676,
  "ldrushar;": 10571,
  "leqslant;": 10877,
  "lesdotor;": 10883,
  "llcorner;": 8990,
  "lnapprox;": 10889,
  "lrcorner;": 8991,
  "lurdshar;": 10570,
  "mapstoup;": 8613,
  "multimap;": 8888,
  "naturals;": 8469,
  "ncongdot;": 10861,
  "notindot;": 8949,
  "otimesas;": 10806,
  "parallel;": 8741,
  "plusacir;": 10787,
  "pointint;": 10773,
  "precneqq;": 10933,
  "precnsim;": 8936,
  "profalar;": 9006,
  "profline;": 8978,
  "profsurf;": 8979,
  "raemptyv;": 10675,
  "realpart;": 8476,
  "rppolint;": 10770,
  "rtriltri;": 10702,
  "scpolint;": 10771,
  "setminus;": 8726,
  "shortmid;": 8739,
  "smeparsl;": 10724,
  "sqsubset;": 8847,
  "sqsupset;": 8848,
  "subseteq;": 8838,
  "succneqq;": 10934,
  "succnsim;": 8937,
  "supseteq;": 8839,
  "thetasym;": 977,
  "thicksim;": 8764,
  "timesbar;": 10801,
  "triangle;": 9653,
  "triminus;": 10810,
  "trpezium;": 9186,
  "ulcorner;": 8988,
  "urcorner;": 8989,
  "varkappa;": 1008,
  "varsigma;": 962,
  "vartheta;": 977,
  "Because;": 8757,
  "Cayleys;": 8493,
  "Cconint;": 8752,
  "Cedilla;": 184,
  "Diamond;": 8900,
  "DownTee;": 8868,
  "Element;": 8712,
  "Epsilon;": 917,
  "Implies;": 8658,
  "LeftTee;": 8867,
  "NewLine;": 10,
  "NoBreak;": 8288,
  "NotLess;": 8814,
  "Omicron;": 927,
  "OverBar;": 8254,
  "Product;": 8719,
  "UpArrow;": 8593,
  "Uparrow;": 8657,
  "Upsilon;": 933,
  "alefsym;": 8501,
  "angrtvb;": 8894,
  "angzarr;": 9084,
  "asympeq;": 8781,
  "backsim;": 8765,
  "because;": 8757,
  "bemptyv;": 10672,
  "between;": 8812,
  "bigcirc;": 9711,
  "bigodot;": 10752,
  "bigstar;": 9733,
  "bnequiv;": 8801,
  "boxplus;": 8862,
  "ccupssm;": 10832,
  "cemptyv;": 10674,
  "cirscir;": 10690,
  "coloneq;": 8788,
  "congdot;": 10861,
  "cudarrl;": 10552,
  "cudarrr;": 10549,
  "cularrp;": 10557,
  "curarrm;": 10556,
  "dbkarow;": 10511,
  "ddagger;": 8225,
  "ddotseq;": 10871,
  "demptyv;": 10673,
  "diamond;": 8900,
  "digamma;": 989,
  "dotplus;": 8724,
  "dwangle;": 10662,
  "epsilon;": 949,
  "eqcolon;": 8789,
  "equivDD;": 10872,
  "gesdoto;": 10882,
  "gtquest;": 10876,
  "gtrless;": 8823,
  "harrcir;": 10568,
  "intprod;": 10812,
  "isindot;": 8949,
  "larrbfs;": 10527,
  "larrsim;": 10611,
  "lbrksld;": 10639,
  "lbrkslu;": 10637,
  "ldrdhar;": 10599,
  "lesdoto;": 10881,
  "lessdot;": 8918,
  "lessgtr;": 8822,
  "lesssim;": 8818,
  "lotimes;": 10804,
  "lozenge;": 9674,
  "ltquest;": 10875,
  "luruhar;": 10598,
  "maltese;": 10016,
  "minusdu;": 10794,
  "napprox;": 8777,
  "natural;": 9838,
  "nearrow;": 8599,
  "nexists;": 8708,
  "notinva;": 8713,
  "notinvb;": 8951,
  "notinvc;": 8950,
  "notniva;": 8716,
  "notnivb;": 8958,
  "notnivc;": 8957,
  "npolint;": 10772,
  "npreceq;": 10927,
  "nsqsube;": 8930,
  "nsqsupe;": 8931,
  "nsubset;": 8834,
  "nsucceq;": 10928,
  "nsupset;": 8835,
  "nvinfin;": 10718,
  "nvltrie;": 8884,
  "nvrtrie;": 8885,
  "nwarrow;": 8598,
  "olcross;": 10683,
  "omicron;": 959,
  "orderof;": 8500,
  "orslope;": 10839,
  "pertenk;": 8241,
  "planckh;": 8462,
  "pluscir;": 10786,
  "plussim;": 10790,
  "plustwo;": 10791,
  "precsim;": 8830,
  "quatint;": 10774,
  "questeq;": 8799,
  "rarrbfs;": 10528,
  "rarrsim;": 10612,
  "rbrksld;": 10638,
  "rbrkslu;": 10640,
  "rdldhar;": 10601,
  "realine;": 8475,
  "rotimes;": 10805,
  "ruluhar;": 10600,
  "searrow;": 8600,
  "simplus;": 10788,
  "simrarr;": 10610,
  "subedot;": 10947,
  "submult;": 10945,
  "subplus;": 10943,
  "subrarr;": 10617,
  "succsim;": 8831,
  "supdsub;": 10968,
  "supedot;": 10948,
  "suphsol;": 10185,
  "suphsub;": 10967,
  "suplarr;": 10619,
  "supmult;": 10946,
  "supplus;": 10944,
  "swarrow;": 8601,
  "topfork;": 10970,
  "triplus;": 10809,
  "tritime;": 10811,
  "uparrow;": 8593,
  "upsilon;": 965,
  "uwangle;": 10663,
  "vzigzag;": 10650,
  "zigrarr;": 8669,
  "Aacute;": 193,
  "Abreve;": 258,
  "Agrave;": 192,
  "Assign;": 8788,
  "Atilde;": 195,
  "Barwed;": 8966,
  "Bumpeq;": 8782,
  "Cacute;": 262,
  "Ccaron;": 268,
  "Ccedil;": 199,
  "Colone;": 10868,
  "Conint;": 8751,
  "CupCap;": 8781,
  "Dagger;": 8225,
  "Dcaron;": 270,
  "DotDot;": 8412,
  "Dstrok;": 272,
  "Eacute;": 201,
  "Ecaron;": 282,
  "Egrave;": 200,
  "Exists;": 8707,
  "ForAll;": 8704,
  "Gammad;": 988,
  "Gbreve;": 286,
  "Gcedil;": 290,
  "HARDcy;": 1066,
  "Hstrok;": 294,
  "Iacute;": 205,
  "Igrave;": 204,
  "Itilde;": 296,
  "Jsercy;": 1032,
  "Kcedil;": 310,
  "Lacute;": 313,
  "Lambda;": 923,
  "Lcaron;": 317,
  "Lcedil;": 315,
  "Lmidot;": 319,
  "Lstrok;": 321,
  "Nacute;": 323,
  "Ncaron;": 327,
  "Ncedil;": 325,
  "Ntilde;": 209,
  "Oacute;": 211,
  "Odblac;": 336,
  "Ograve;": 210,
  "Oslash;": 216,
  "Otilde;": 213,
  "Otimes;": 10807,
  "Racute;": 340,
  "Rarrtl;": 10518,
  "Rcaron;": 344,
  "Rcedil;": 342,
  "SHCHcy;": 1065,
  "SOFTcy;": 1068,
  "Sacute;": 346,
  "Scaron;": 352,
  "Scedil;": 350,
  "Square;": 9633,
  "Subset;": 8912,
  "Supset;": 8913,
  "Tcaron;": 356,
  "Tcedil;": 354,
  "Tstrok;": 358,
  "Uacute;": 218,
  "Ubreve;": 364,
  "Udblac;": 368,
  "Ugrave;": 217,
  "Utilde;": 360,
  "Vdashl;": 10982,
  "Verbar;": 8214,
  "Vvdash;": 8874,
  "Yacute;": 221,
  "Zacute;": 377,
  "Zcaron;": 381,
  "aacute;": 225,
  "abreve;": 259,
  "agrave;": 224,
  "andand;": 10837,
  "angmsd;": 8737,
  "angsph;": 8738,
  "apacir;": 10863,
  "approx;": 8776,
  "atilde;": 227,
  "barvee;": 8893,
  "barwed;": 8965,
  "becaus;": 8757,
  "bernou;": 8492,
  "bigcap;": 8898,
  "bigcup;": 8899,
  "bigvee;": 8897,
  "bkarow;": 10509,
  "bottom;": 8869,
  "bowtie;": 8904,
  "boxbox;": 10697,
  "bprime;": 8245,
  "brvbar;": 166,
  "bullet;": 8226,
  "bumpeq;": 8783,
  "cacute;": 263,
  "capand;": 10820,
  "capcap;": 10827,
  "capcup;": 10823,
  "capdot;": 10816,
  "ccaron;": 269,
  "ccedil;": 231,
  "circeq;": 8791,
  "cirmid;": 10991,
  "colone;": 8788,
  "commat;": 64,
  "compfn;": 8728,
  "conint;": 8750,
  "coprod;": 8720,
  "copysr;": 8471,
  "cularr;": 8630,
  "cupcap;": 10822,
  "cupcup;": 10826,
  "cupdot;": 8845,
  "curarr;": 8631,
  "curren;": 164,
  "cylcty;": 9005,
  "dagger;": 8224,
  "daleth;": 8504,
  "dcaron;": 271,
  "dfisht;": 10623,
  "divide;": 247,
  "divonx;": 8903,
  "dlcorn;": 8990,
  "dlcrop;": 8973,
  "dollar;": 36,
  "drcorn;": 8991,
  "drcrop;": 8972,
  "dstrok;": 273,
  "eacute;": 233,
  "easter;": 10862,
  "ecaron;": 283,
  "ecolon;": 8789,
  "egrave;": 232,
  "egsdot;": 10904,
  "elsdot;": 10903,
  "emptyv;": 8709,
  "emsp13;": 8196,
  "emsp14;": 8197,
  "eparsl;": 10723,
  "eqcirc;": 8790,
  "equals;": 61,
  "equest;": 8799,
  "female;": 9792,
  "ffilig;": 64259,
  "ffllig;": 64260,
  "forall;": 8704,
  "frac12;": 189,
  "frac13;": 8531,
  "frac14;": 188,
  "frac15;": 8533,
  "frac16;": 8537,
  "frac18;": 8539,
  "frac23;": 8532,
  "frac25;": 8534,
  "frac34;": 190,
  "frac35;": 8535,
  "frac38;": 8540,
  "frac45;": 8536,
  "frac56;": 8538,
  "frac58;": 8541,
  "frac78;": 8542,
  "gacute;": 501,
  "gammad;": 989,
  "gbreve;": 287,
  "gesdot;": 10880,
  "gesles;": 10900,
  "gtlPar;": 10645,
  "gtrarr;": 10616,
  "gtrdot;": 8919,
  "gtrsim;": 8819,
  "hairsp;": 8202,
  "hamilt;": 8459,
  "hardcy;": 1098,
  "hearts;": 9829,
  "hellip;": 8230,
  "hercon;": 8889,
  "homtht;": 8763,
  "horbar;": 8213,
  "hslash;": 8463,
  "hstrok;": 295,
  "hybull;": 8259,
  "hyphen;": 8208,
  "iacute;": 237,
  "igrave;": 236,
  "iiiint;": 10764,
  "iinfin;": 10716,
  "incare;": 8453,
  "inodot;": 305,
  "intcal;": 8890,
  "iquest;": 191,
  "isinsv;": 8947,
  "itilde;": 297,
  "jsercy;": 1112,
  "kappav;": 1008,
  "kcedil;": 311,
  "kgreen;": 312,
  "lAtail;": 10523,
  "lacute;": 314,
  "lagran;": 8466,
  "lambda;": 955,
  "langle;": 10216,
  "larrfs;": 10525,
  "larrhk;": 8617,
  "larrlp;": 8619,
  "larrpl;": 10553,
  "larrtl;": 8610,
  "latail;": 10521,
  "lbrace;": 123,
  "lbrack;": 91,
  "lcaron;": 318,
  "lcedil;": 316,
  "ldquor;": 8222,
  "lesdot;": 10879,
  "lesges;": 10899,
  "lfisht;": 10620,
  "lfloor;": 8970,
  "lharul;": 10602,
  "llhard;": 10603,
  "lmidot;": 320,
  "lmoust;": 9136,
  "loplus;": 10797,
  "lowast;": 8727,
  "lowbar;": 95,
  "lparlt;": 10643,
  "lrhard;": 10605,
  "lsaquo;": 8249,
  "lsquor;": 8218,
  "lstrok;": 322,
  "lthree;": 8907,
  "ltimes;": 8905,
  "ltlarr;": 10614,
  "ltrPar;": 10646,
  "mapsto;": 8614,
  "marker;": 9646,
  "mcomma;": 10793,
  "midast;": 42,
  "midcir;": 10992,
  "middot;": 183,
  "minusb;": 8863,
  "minusd;": 8760,
  "mnplus;": 8723,
  "models;": 8871,
  "mstpos;": 8766,
  "nVDash;": 8879,
  "nVdash;": 8878,
  "nacute;": 324,
  "nbumpe;": 8783,
  "ncaron;": 328,
  "ncedil;": 326,
  "nearhk;": 10532,
  "nequiv;": 8802,
  "nesear;": 10536,
  "nexist;": 8708,
  "nltrie;": 8940,
  "notinE;": 8953,
  "nparsl;": 11005,
  "nprcue;": 8928,
  "nrarrc;": 10547,
  "nrarrw;": 8605,
  "nrtrie;": 8941,
  "nsccue;": 8929,
  "nsimeq;": 8772,
  "ntilde;": 241,
  "numero;": 8470,
  "nvDash;": 8877,
  "nvHarr;": 10500,
  "nvdash;": 8876,
  "nvlArr;": 10498,
  "nvrArr;": 10499,
  "nwarhk;": 10531,
  "nwnear;": 10535,
  "oacute;": 243,
  "odblac;": 337,
  "odsold;": 10684,
  "ograve;": 242,
  "ominus;": 8854,
  "origof;": 8886,
  "oslash;": 248,
  "otilde;": 245,
  "otimes;": 8855,
  "parsim;": 10995,
  "percnt;": 37,
  "period;": 46,
  "permil;": 8240,
  "phmmat;": 8499,
  "planck;": 8463,
  "plankv;": 8463,
  "plusdo;": 8724,
  "plusdu;": 10789,
  "plusmn;": 177,
  "preceq;": 10927,
  "primes;": 8473,
  "prnsim;": 8936,
  "propto;": 8733,
  "prurel;": 8880,
  "puncsp;": 8200,
  "qprime;": 8279,
  "rAtail;": 10524,
  "racute;": 341,
  "rangle;": 10217,
  "rarrap;": 10613,
  "rarrfs;": 10526,
  "rarrhk;": 8618,
  "rarrlp;": 8620,
  "rarrpl;": 10565,
  "rarrtl;": 8611,
  "ratail;": 10522,
  "rbrace;": 125,
  "rbrack;": 93,
  "rcaron;": 345,
  "rcedil;": 343,
  "rdquor;": 8221,
  "rfisht;": 10621,
  "rfloor;": 8971,
  "rharul;": 10604,
  "rmoust;": 9137,
  "roplus;": 10798,
  "rpargt;": 10644,
  "rsaquo;": 8250,
  "rsquor;": 8217,
  "rthree;": 8908,
  "rtimes;": 8906,
  "sacute;": 347,
  "scaron;": 353,
  "scedil;": 351,
  "scnsim;": 8937,
  "searhk;": 10533,
  "seswar;": 10537,
  "sfrown;": 8994,
  "shchcy;": 1097,
  "sigmaf;": 962,
  "sigmav;": 962,
  "simdot;": 10858,
  "smashp;": 10803,
  "softcy;": 1100,
  "solbar;": 9023,
  "spades;": 9824,
  "sqcaps;": 8851,
  "sqcups;": 8852,
  "sqsube;": 8849,
  "sqsupe;": 8850,
  "square;": 9633,
  "squarf;": 9642,
  "ssetmn;": 8726,
  "ssmile;": 8995,
  "sstarf;": 8902,
  "subdot;": 10941,
  "subset;": 8834,
  "subsim;": 10951,
  "subsub;": 10965,
  "subsup;": 10963,
  "succeq;": 10928,
  "supdot;": 10942,
  "supset;": 8835,
  "supsim;": 10952,
  "supsub;": 10964,
  "supsup;": 10966,
  "swarhk;": 10534,
  "swnwar;": 10538,
  "target;": 8982,
  "tcaron;": 357,
  "tcedil;": 355,
  "telrec;": 8981,
  "there4;": 8756,
  "thetav;": 977,
  "thinsp;": 8201,
  "thksim;": 8764,
  "timesb;": 8864,
  "timesd;": 10800,
  "topbot;": 9014,
  "topcir;": 10993,
  "tprime;": 8244,
  "tridot;": 9708,
  "tstrok;": 359,
  "uacute;": 250,
  "ubreve;": 365,
  "udblac;": 369,
  "ufisht;": 10622,
  "ugrave;": 249,
  "ulcorn;": 8988,
  "ulcrop;": 8975,
  "urcorn;": 8989,
  "urcrop;": 8974,
  "utilde;": 361,
  "vangrt;": 10652,
  "varphi;": 981,
  "varrho;": 1009,
  "veebar;": 8891,
  "vellip;": 8942,
  "verbar;": 124,
  "vsubnE;": 10955,
  "vsubne;": 8842,
  "vsupnE;": 10956,
  "vsupne;": 8843,
  "wedbar;": 10847,
  "wedgeq;": 8793,
  "weierp;": 8472,
  "wreath;": 8768,
  "xoplus;": 10753,
  "xotime;": 10754,
  "xsqcup;": 10758,
  "xuplus;": 10756,
  "xwedge;": 8896,
  "yacute;": 253,
  "zacute;": 378,
  "zcaron;": 382,
  "zeetrf;": 8488,
  "AElig;": 198,
  Aacute: 193,
  "Acirc;": 194,
  Agrave: 192,
  "Alpha;": 913,
  "Amacr;": 256,
  "Aogon;": 260,
  "Aring;": 197,
  Atilde: 195,
  "Breve;": 728,
  Ccedil: 199,
  "Ccirc;": 264,
  "Colon;": 8759,
  "Cross;": 10799,
  "Dashv;": 10980,
  "Delta;": 916,
  Eacute: 201,
  "Ecirc;": 202,
  Egrave: 200,
  "Emacr;": 274,
  "Eogon;": 280,
  "Equal;": 10869,
  "Gamma;": 915,
  "Gcirc;": 284,
  "Hacek;": 711,
  "Hcirc;": 292,
  "IJlig;": 306,
  Iacute: 205,
  "Icirc;": 206,
  Igrave: 204,
  "Imacr;": 298,
  "Iogon;": 302,
  "Iukcy;": 1030,
  "Jcirc;": 308,
  "Jukcy;": 1028,
  "Kappa;": 922,
  Ntilde: 209,
  "OElig;": 338,
  Oacute: 211,
  "Ocirc;": 212,
  Ograve: 210,
  "Omacr;": 332,
  "Omega;": 937,
  Oslash: 216,
  Otilde: 213,
  "Prime;": 8243,
  "RBarr;": 10512,
  "Scirc;": 348,
  "Sigma;": 931,
  "THORN;": 222,
  "TRADE;": 8482,
  "TSHcy;": 1035,
  "Theta;": 920,
  "Tilde;": 8764,
  Uacute: 218,
  "Ubrcy;": 1038,
  "Ucirc;": 219,
  Ugrave: 217,
  "Umacr;": 362,
  "Union;": 8899,
  "Uogon;": 370,
  "UpTee;": 8869,
  "Uring;": 366,
  "VDash;": 8875,
  "Vdash;": 8873,
  "Wcirc;": 372,
  "Wedge;": 8896,
  Yacute: 221,
  "Ycirc;": 374,
  aacute: 225,
  "acirc;": 226,
  "acute;": 180,
  "aelig;": 230,
  agrave: 224,
  "aleph;": 8501,
  "alpha;": 945,
  "amacr;": 257,
  "amalg;": 10815,
  "angle;": 8736,
  "angrt;": 8735,
  "angst;": 197,
  "aogon;": 261,
  "aring;": 229,
  "asymp;": 8776,
  atilde: 227,
  "awint;": 10769,
  "bcong;": 8780,
  "bdquo;": 8222,
  "bepsi;": 1014,
  "blank;": 9251,
  "blk12;": 9618,
  "blk14;": 9617,
  "blk34;": 9619,
  "block;": 9608,
  "boxDL;": 9559,
  "boxDR;": 9556,
  "boxDl;": 9558,
  "boxDr;": 9555,
  "boxHD;": 9574,
  "boxHU;": 9577,
  "boxHd;": 9572,
  "boxHu;": 9575,
  "boxUL;": 9565,
  "boxUR;": 9562,
  "boxUl;": 9564,
  "boxUr;": 9561,
  "boxVH;": 9580,
  "boxVL;": 9571,
  "boxVR;": 9568,
  "boxVh;": 9579,
  "boxVl;": 9570,
  "boxVr;": 9567,
  "boxdL;": 9557,
  "boxdR;": 9554,
  "boxdl;": 9488,
  "boxdr;": 9484,
  "boxhD;": 9573,
  "boxhU;": 9576,
  "boxhd;": 9516,
  "boxhu;": 9524,
  "boxuL;": 9563,
  "boxuR;": 9560,
  "boxul;": 9496,
  "boxur;": 9492,
  "boxvH;": 9578,
  "boxvL;": 9569,
  "boxvR;": 9566,
  "boxvh;": 9532,
  "boxvl;": 9508,
  "boxvr;": 9500,
  "breve;": 728,
  brvbar: 166,
  "bsemi;": 8271,
  "bsime;": 8909,
  "bsolb;": 10693,
  "bumpE;": 10926,
  "bumpe;": 8783,
  "caret;": 8257,
  "caron;": 711,
  "ccaps;": 10829,
  ccedil: 231,
  "ccirc;": 265,
  "ccups;": 10828,
  "cedil;": 184,
  "check;": 10003,
  "clubs;": 9827,
  "colon;": 58,
  "comma;": 44,
  "crarr;": 8629,
  "cross;": 10007,
  "csube;": 10961,
  "csupe;": 10962,
  "ctdot;": 8943,
  "cuepr;": 8926,
  "cuesc;": 8927,
  "cupor;": 10821,
  curren: 164,
  "cuvee;": 8910,
  "cuwed;": 8911,
  "cwint;": 8753,
  "dashv;": 8867,
  "dblac;": 733,
  "ddarr;": 8650,
  "delta;": 948,
  "dharl;": 8643,
  "dharr;": 8642,
  "diams;": 9830,
  "disin;": 8946,
  divide: 247,
  "doteq;": 8784,
  "dtdot;": 8945,
  "dtrif;": 9662,
  "duarr;": 8693,
  "duhar;": 10607,
  "eDDot;": 10871,
  eacute: 233,
  "ecirc;": 234,
  "efDot;": 8786,
  egrave: 232,
  "emacr;": 275,
  "empty;": 8709,
  "eogon;": 281,
  "eplus;": 10865,
  "epsiv;": 1013,
  "eqsim;": 8770,
  "equiv;": 8801,
  "erDot;": 8787,
  "erarr;": 10609,
  "esdot;": 8784,
  "exist;": 8707,
  "fflig;": 64256,
  "filig;": 64257,
  "fjlig;": 102,
  "fllig;": 64258,
  "fltns;": 9649,
  "forkv;": 10969,
  frac12: 189,
  frac14: 188,
  frac34: 190,
  "frasl;": 8260,
  "frown;": 8994,
  "gamma;": 947,
  "gcirc;": 285,
  "gescc;": 10921,
  "gimel;": 8503,
  "gneqq;": 8809,
  "gnsim;": 8935,
  "grave;": 96,
  "gsime;": 10894,
  "gsiml;": 10896,
  "gtcir;": 10874,
  "gtdot;": 8919,
  "harrw;": 8621,
  "hcirc;": 293,
  "hoarr;": 8703,
  iacute: 237,
  "icirc;": 238,
  "iexcl;": 161,
  igrave: 236,
  "iiint;": 8749,
  "iiota;": 8489,
  "ijlig;": 307,
  "imacr;": 299,
  "image;": 8465,
  "imath;": 305,
  "imped;": 437,
  "infin;": 8734,
  "iogon;": 303,
  "iprod;": 10812,
  iquest: 191,
  "isinE;": 8953,
  "isins;": 8948,
  "isinv;": 8712,
  "iukcy;": 1110,
  "jcirc;": 309,
  "jmath;": 567,
  "jukcy;": 1108,
  "kappa;": 954,
  "lAarr;": 8666,
  "lBarr;": 10510,
  "langd;": 10641,
  "laquo;": 171,
  "larrb;": 8676,
  "lates;": 10925,
  "lbarr;": 10508,
  "lbbrk;": 10098,
  "lbrke;": 10635,
  "lceil;": 8968,
  "ldquo;": 8220,
  "lescc;": 10920,
  "lhard;": 8637,
  "lharu;": 8636,
  "lhblk;": 9604,
  "llarr;": 8647,
  "lltri;": 9722,
  "lneqq;": 8808,
  "lnsim;": 8934,
  "loang;": 10220,
  "loarr;": 8701,
  "lobrk;": 10214,
  "lopar;": 10629,
  "lrarr;": 8646,
  "lrhar;": 8651,
  "lrtri;": 8895,
  "lsime;": 10893,
  "lsimg;": 10895,
  "lsquo;": 8216,
  "ltcir;": 10873,
  "ltdot;": 8918,
  "ltrie;": 8884,
  "ltrif;": 9666,
  "mDDot;": 8762,
  "mdash;": 8212,
  "micro;": 181,
  middot: 183,
  "minus;": 8722,
  "mumap;": 8888,
  "nabla;": 8711,
  "napid;": 8779,
  "napos;": 329,
  "natur;": 9838,
  "nbump;": 8782,
  "ncong;": 8775,
  "ndash;": 8211,
  "neArr;": 8663,
  "nearr;": 8599,
  "nedot;": 8784,
  "nesim;": 8770,
  "ngeqq;": 8807,
  "ngsim;": 8821,
  "nhArr;": 8654,
  "nharr;": 8622,
  "nhpar;": 10994,
  "nlArr;": 8653,
  "nlarr;": 8602,
  "nleqq;": 8806,
  "nless;": 8814,
  "nlsim;": 8820,
  "nltri;": 8938,
  "notin;": 8713,
  "notni;": 8716,
  "npart;": 8706,
  "nprec;": 8832,
  "nrArr;": 8655,
  "nrarr;": 8603,
  "nrtri;": 8939,
  "nsime;": 8772,
  "nsmid;": 8740,
  "nspar;": 8742,
  "nsubE;": 10949,
  "nsube;": 8840,
  "nsucc;": 8833,
  "nsupE;": 10950,
  "nsupe;": 8841,
  ntilde: 241,
  "numsp;": 8199,
  "nvsim;": 8764,
  "nwArr;": 8662,
  "nwarr;": 8598,
  oacute: 243,
  "ocirc;": 244,
  "odash;": 8861,
  "oelig;": 339,
  "ofcir;": 10687,
  ograve: 242,
  "ohbar;": 10677,
  "olarr;": 8634,
  "olcir;": 10686,
  "oline;": 8254,
  "omacr;": 333,
  "omega;": 969,
  "operp;": 10681,
  "oplus;": 8853,
  "orarr;": 8635,
  "order;": 8500,
  oslash: 248,
  otilde: 245,
  "ovbar;": 9021,
  "parsl;": 11005,
  "phone;": 9742,
  "plusb;": 8862,
  "pluse;": 10866,
  plusmn: 177,
  "pound;": 163,
  "prcue;": 8828,
  "prime;": 8242,
  "prnap;": 10937,
  "prsim;": 8830,
  "quest;": 63,
  "rAarr;": 8667,
  "rBarr;": 10511,
  "radic;": 8730,
  "rangd;": 10642,
  "range;": 10661,
  "raquo;": 187,
  "rarrb;": 8677,
  "rarrc;": 10547,
  "rarrw;": 8605,
  "ratio;": 8758,
  "rbarr;": 10509,
  "rbbrk;": 10099,
  "rbrke;": 10636,
  "rceil;": 8969,
  "rdquo;": 8221,
  "reals;": 8477,
  "rhard;": 8641,
  "rharu;": 8640,
  "rlarr;": 8644,
  "rlhar;": 8652,
  "rnmid;": 10990,
  "roang;": 10221,
  "roarr;": 8702,
  "robrk;": 10215,
  "ropar;": 10630,
  "rrarr;": 8649,
  "rsquo;": 8217,
  "rtrie;": 8885,
  "rtrif;": 9656,
  "sbquo;": 8218,
  "sccue;": 8829,
  "scirc;": 349,
  "scnap;": 10938,
  "scsim;": 8831,
  "sdotb;": 8865,
  "sdote;": 10854,
  "seArr;": 8664,
  "searr;": 8600,
  "setmn;": 8726,
  "sharp;": 9839,
  "sigma;": 963,
  "simeq;": 8771,
  "simgE;": 10912,
  "simlE;": 10911,
  "simne;": 8774,
  "slarr;": 8592,
  "smile;": 8995,
  "smtes;": 10924,
  "sqcap;": 8851,
  "sqcup;": 8852,
  "sqsub;": 8847,
  "sqsup;": 8848,
  "srarr;": 8594,
  "starf;": 9733,
  "strns;": 175,
  "subnE;": 10955,
  "subne;": 8842,
  "supnE;": 10956,
  "supne;": 8843,
  "swArr;": 8665,
  "swarr;": 8601,
  "szlig;": 223,
  "theta;": 952,
  "thkap;": 8776,
  "thorn;": 254,
  "tilde;": 732,
  "times;": 215,
  "trade;": 8482,
  "trisb;": 10701,
  "tshcy;": 1115,
  "twixt;": 8812,
  uacute: 250,
  "ubrcy;": 1118,
  "ucirc;": 251,
  "udarr;": 8645,
  "udhar;": 10606,
  ugrave: 249,
  "uharl;": 8639,
  "uharr;": 8638,
  "uhblk;": 9600,
  "ultri;": 9720,
  "umacr;": 363,
  "uogon;": 371,
  "uplus;": 8846,
  "upsih;": 978,
  "uring;": 367,
  "urtri;": 9721,
  "utdot;": 8944,
  "utrif;": 9652,
  "uuarr;": 8648,
  "vBarv;": 10985,
  "vDash;": 8872,
  "varpi;": 982,
  "vdash;": 8866,
  "veeeq;": 8794,
  "vltri;": 8882,
  "vnsub;": 8834,
  "vnsup;": 8835,
  "vprop;": 8733,
  "vrtri;": 8883,
  "wcirc;": 373,
  "wedge;": 8743,
  "xcirc;": 9711,
  "xdtri;": 9661,
  "xhArr;": 10234,
  "xharr;": 10231,
  "xlArr;": 10232,
  "xlarr;": 10229,
  "xodot;": 10752,
  "xrArr;": 10233,
  "xrarr;": 10230,
  "xutri;": 9651,
  yacute: 253,
  "ycirc;": 375,
  AElig: 198,
  Acirc: 194,
  "Aopf;": 120120,
  Aring: 197,
  "Ascr;": 119964,
  "Auml;": 196,
  "Barv;": 10983,
  "Beta;": 914,
  "Bopf;": 120121,
  "Bscr;": 8492,
  "CHcy;": 1063,
  "COPY;": 169,
  "Cdot;": 266,
  "Copf;": 8450,
  "Cscr;": 119966,
  "DJcy;": 1026,
  "DScy;": 1029,
  "DZcy;": 1039,
  "Darr;": 8609,
  "Dopf;": 120123,
  "Dscr;": 119967,
  Ecirc: 202,
  "Edot;": 278,
  "Eopf;": 120124,
  "Escr;": 8496,
  "Esim;": 10867,
  "Euml;": 203,
  "Fopf;": 120125,
  "Fscr;": 8497,
  "GJcy;": 1027,
  "Gdot;": 288,
  "Gopf;": 120126,
  "Gscr;": 119970,
  "Hopf;": 8461,
  "Hscr;": 8459,
  "IEcy;": 1045,
  "IOcy;": 1025,
  Icirc: 206,
  "Idot;": 304,
  "Iopf;": 120128,
  "Iota;": 921,
  "Iscr;": 8464,
  "Iuml;": 207,
  "Jopf;": 120129,
  "Jscr;": 119973,
  "KHcy;": 1061,
  "KJcy;": 1036,
  "Kopf;": 120130,
  "Kscr;": 119974,
  "LJcy;": 1033,
  "Lang;": 10218,
  "Larr;": 8606,
  "Lopf;": 120131,
  "Lscr;": 8466,
  "Mopf;": 120132,
  "Mscr;": 8499,
  "NJcy;": 1034,
  "Nopf;": 8469,
  "Nscr;": 119977,
  Ocirc: 212,
  "Oopf;": 120134,
  "Oscr;": 119978,
  "Ouml;": 214,
  "Popf;": 8473,
  "Pscr;": 119979,
  "QUOT;": 34,
  "Qopf;": 8474,
  "Qscr;": 119980,
  "Rang;": 10219,
  "Rarr;": 8608,
  "Ropf;": 8477,
  "Rscr;": 8475,
  "SHcy;": 1064,
  "Sopf;": 120138,
  "Sqrt;": 8730,
  "Sscr;": 119982,
  "Star;": 8902,
  THORN: 222,
  "TScy;": 1062,
  "Topf;": 120139,
  "Tscr;": 119983,
  "Uarr;": 8607,
  Ucirc: 219,
  "Uopf;": 120140,
  "Upsi;": 978,
  "Uscr;": 119984,
  "Uuml;": 220,
  "Vbar;": 10987,
  "Vert;": 8214,
  "Vopf;": 120141,
  "Vscr;": 119985,
  "Wopf;": 120142,
  "Wscr;": 119986,
  "Xopf;": 120143,
  "Xscr;": 119987,
  "YAcy;": 1071,
  "YIcy;": 1031,
  "YUcy;": 1070,
  "Yopf;": 120144,
  "Yscr;": 119988,
  "Yuml;": 376,
  "ZHcy;": 1046,
  "Zdot;": 379,
  "Zeta;": 918,
  "Zopf;": 8484,
  "Zscr;": 119989,
  acirc: 226,
  acute: 180,
  aelig: 230,
  "andd;": 10844,
  "andv;": 10842,
  "ange;": 10660,
  "aopf;": 120146,
  "apid;": 8779,
  "apos;": 39,
  aring: 229,
  "ascr;": 119990,
  "auml;": 228,
  "bNot;": 10989,
  "bbrk;": 9141,
  "beta;": 946,
  "beth;": 8502,
  "bnot;": 8976,
  "bopf;": 120147,
  "boxH;": 9552,
  "boxV;": 9553,
  "boxh;": 9472,
  "boxv;": 9474,
  "bscr;": 119991,
  "bsim;": 8765,
  "bsol;": 92,
  "bull;": 8226,
  "bump;": 8782,
  "caps;": 8745,
  "cdot;": 267,
  cedil: 184,
  "cent;": 162,
  "chcy;": 1095,
  "cirE;": 10691,
  "circ;": 710,
  "cire;": 8791,
  "comp;": 8705,
  "cong;": 8773,
  "copf;": 120148,
  "copy;": 169,
  "cscr;": 119992,
  "csub;": 10959,
  "csup;": 10960,
  "cups;": 8746,
  "dArr;": 8659,
  "dHar;": 10597,
  "darr;": 8595,
  "dash;": 8208,
  "diam;": 8900,
  "djcy;": 1106,
  "dopf;": 120149,
  "dscr;": 119993,
  "dscy;": 1109,
  "dsol;": 10742,
  "dtri;": 9663,
  "dzcy;": 1119,
  "eDot;": 8785,
  "ecir;": 8790,
  ecirc: 234,
  "edot;": 279,
  "emsp;": 8195,
  "ensp;": 8194,
  "eopf;": 120150,
  "epar;": 8917,
  "epsi;": 949,
  "escr;": 8495,
  "esim;": 8770,
  "euml;": 235,
  "euro;": 8364,
  "excl;": 33,
  "flat;": 9837,
  "fnof;": 402,
  "fopf;": 120151,
  "fork;": 8916,
  "fscr;": 119995,
  "gdot;": 289,
  "geqq;": 8807,
  "gesl;": 8923,
  "gjcy;": 1107,
  "gnap;": 10890,
  "gneq;": 10888,
  "gopf;": 120152,
  "gscr;": 8458,
  "gsim;": 8819,
  "gtcc;": 10919,
  "gvnE;": 8809,
  "hArr;": 8660,
  "half;": 189,
  "harr;": 8596,
  "hbar;": 8463,
  "hopf;": 120153,
  "hscr;": 119997,
  icirc: 238,
  "iecy;": 1077,
  iexcl: 161,
  "imof;": 8887,
  "iocy;": 1105,
  "iopf;": 120154,
  "iota;": 953,
  "iscr;": 119998,
  "isin;": 8712,
  "iuml;": 239,
  "jopf;": 120155,
  "jscr;": 119999,
  "khcy;": 1093,
  "kjcy;": 1116,
  "kopf;": 120156,
  "kscr;": 12e4,
  "lArr;": 8656,
  "lHar;": 10594,
  "lang;": 10216,
  laquo: 171,
  "larr;": 8592,
  "late;": 10925,
  "lcub;": 123,
  "ldca;": 10550,
  "ldsh;": 8626,
  "leqq;": 8806,
  "lesg;": 8922,
  "ljcy;": 1113,
  "lnap;": 10889,
  "lneq;": 10887,
  "lopf;": 120157,
  "lozf;": 10731,
  "lpar;": 40,
  "lscr;": 120001,
  "lsim;": 8818,
  "lsqb;": 91,
  "ltcc;": 10918,
  "ltri;": 9667,
  "lvnE;": 8808,
  "macr;": 175,
  "male;": 9794,
  "malt;": 10016,
  micro: 181,
  "mlcp;": 10971,
  "mldr;": 8230,
  "mopf;": 120158,
  "mscr;": 120002,
  "nGtv;": 8811,
  "nLtv;": 8810,
  "nang;": 8736,
  "napE;": 10864,
  "nbsp;": 160,
  "ncap;": 10819,
  "ncup;": 10818,
  "ngeq;": 8817,
  "nges;": 10878,
  "ngtr;": 8815,
  "nisd;": 8954,
  "njcy;": 1114,
  "nldr;": 8229,
  "nleq;": 8816,
  "nles;": 10877,
  "nmid;": 8740,
  "nopf;": 120159,
  "npar;": 8742,
  "npre;": 10927,
  "nsce;": 10928,
  "nscr;": 120003,
  "nsim;": 8769,
  "nsub;": 8836,
  "nsup;": 8837,
  "ntgl;": 8825,
  "ntlg;": 8824,
  "nvap;": 8781,
  "nvge;": 8805,
  "nvgt;": 62,
  "nvle;": 8804,
  "nvlt;": 60,
  "oast;": 8859,
  "ocir;": 8858,
  ocirc: 244,
  "odiv;": 10808,
  "odot;": 8857,
  "ogon;": 731,
  "oint;": 8750,
  "omid;": 10678,
  "oopf;": 120160,
  "opar;": 10679,
  "ordf;": 170,
  "ordm;": 186,
  "oror;": 10838,
  "oscr;": 8500,
  "osol;": 8856,
  "ouml;": 246,
  "para;": 182,
  "part;": 8706,
  "perp;": 8869,
  "phiv;": 981,
  "plus;": 43,
  "popf;": 120161,
  pound: 163,
  "prap;": 10935,
  "prec;": 8826,
  "prnE;": 10933,
  "prod;": 8719,
  "prop;": 8733,
  "pscr;": 120005,
  "qint;": 10764,
  "qopf;": 120162,
  "qscr;": 120006,
  "quot;": 34,
  "rArr;": 8658,
  "rHar;": 10596,
  "race;": 8765,
  "rang;": 10217,
  raquo: 187,
  "rarr;": 8594,
  "rcub;": 125,
  "rdca;": 10551,
  "rdsh;": 8627,
  "real;": 8476,
  "rect;": 9645,
  "rhov;": 1009,
  "ring;": 730,
  "ropf;": 120163,
  "rpar;": 41,
  "rscr;": 120007,
  "rsqb;": 93,
  "rtri;": 9657,
  "scap;": 10936,
  "scnE;": 10934,
  "sdot;": 8901,
  "sect;": 167,
  "semi;": 59,
  "sext;": 10038,
  "shcy;": 1096,
  "sime;": 8771,
  "simg;": 10910,
  "siml;": 10909,
  "smid;": 8739,
  "smte;": 10924,
  "solb;": 10692,
  "sopf;": 120164,
  "spar;": 8741,
  "squf;": 9642,
  "sscr;": 120008,
  "star;": 9734,
  "subE;": 10949,
  "sube;": 8838,
  "succ;": 8827,
  "sung;": 9834,
  "sup1;": 185,
  "sup2;": 178,
  "sup3;": 179,
  "supE;": 10950,
  "supe;": 8839,
  szlig: 223,
  "tbrk;": 9140,
  "tdot;": 8411,
  thorn: 254,
  times: 215,
  "tint;": 8749,
  "toea;": 10536,
  "topf;": 120165,
  "tosa;": 10537,
  "trie;": 8796,
  "tscr;": 120009,
  "tscy;": 1094,
  "uArr;": 8657,
  "uHar;": 10595,
  "uarr;": 8593,
  ucirc: 251,
  "uopf;": 120166,
  "upsi;": 965,
  "uscr;": 120010,
  "utri;": 9653,
  "uuml;": 252,
  "vArr;": 8661,
  "vBar;": 10984,
  "varr;": 8597,
  "vert;": 124,
  "vopf;": 120167,
  "vscr;": 120011,
  "wopf;": 120168,
  "wscr;": 120012,
  "xcap;": 8898,
  "xcup;": 8899,
  "xmap;": 10236,
  "xnis;": 8955,
  "xopf;": 120169,
  "xscr;": 120013,
  "xvee;": 8897,
  "yacy;": 1103,
  "yicy;": 1111,
  "yopf;": 120170,
  "yscr;": 120014,
  "yucy;": 1102,
  "yuml;": 255,
  "zdot;": 380,
  "zeta;": 950,
  "zhcy;": 1078,
  "zopf;": 120171,
  "zscr;": 120015,
  "zwnj;": 8204,
  "AMP;": 38,
  "Acy;": 1040,
  "Afr;": 120068,
  "And;": 10835,
  Auml: 196,
  "Bcy;": 1041,
  "Bfr;": 120069,
  COPY: 169,
  "Cap;": 8914,
  "Cfr;": 8493,
  "Chi;": 935,
  "Cup;": 8915,
  "Dcy;": 1044,
  "Del;": 8711,
  "Dfr;": 120071,
  "Dot;": 168,
  "ENG;": 330,
  "ETH;": 208,
  "Ecy;": 1069,
  "Efr;": 120072,
  "Eta;": 919,
  Euml: 203,
  "Fcy;": 1060,
  "Ffr;": 120073,
  "Gcy;": 1043,
  "Gfr;": 120074,
  "Hat;": 94,
  "Hfr;": 8460,
  "Icy;": 1048,
  "Ifr;": 8465,
  "Int;": 8748,
  Iuml: 207,
  "Jcy;": 1049,
  "Jfr;": 120077,
  "Kcy;": 1050,
  "Kfr;": 120078,
  "Lcy;": 1051,
  "Lfr;": 120079,
  "Lsh;": 8624,
  "Map;": 10501,
  "Mcy;": 1052,
  "Mfr;": 120080,
  "Ncy;": 1053,
  "Nfr;": 120081,
  "Not;": 10988,
  "Ocy;": 1054,
  "Ofr;": 120082,
  Ouml: 214,
  "Pcy;": 1055,
  "Pfr;": 120083,
  "Phi;": 934,
  "Psi;": 936,
  QUOT: 34,
  "Qfr;": 120084,
  "REG;": 174,
  "Rcy;": 1056,
  "Rfr;": 8476,
  "Rho;": 929,
  "Rsh;": 8625,
  "Scy;": 1057,
  "Sfr;": 120086,
  "Sub;": 8912,
  "Sum;": 8721,
  "Sup;": 8913,
  "Tab;": 9,
  "Tau;": 932,
  "Tcy;": 1058,
  "Tfr;": 120087,
  "Ucy;": 1059,
  "Ufr;": 120088,
  Uuml: 220,
  "Vcy;": 1042,
  "Vee;": 8897,
  "Vfr;": 120089,
  "Wfr;": 120090,
  "Xfr;": 120091,
  "Ycy;": 1067,
  "Yfr;": 120092,
  "Zcy;": 1047,
  "Zfr;": 8488,
  "acE;": 8766,
  "acd;": 8767,
  "acy;": 1072,
  "afr;": 120094,
  "amp;": 38,
  "and;": 8743,
  "ang;": 8736,
  "apE;": 10864,
  "ape;": 8778,
  "ast;": 42,
  auml: 228,
  "bcy;": 1073,
  "bfr;": 120095,
  "bne;": 61,
  "bot;": 8869,
  "cap;": 8745,
  cent: 162,
  "cfr;": 120096,
  "chi;": 967,
  "cir;": 9675,
  copy: 169,
  "cup;": 8746,
  "dcy;": 1076,
  "deg;": 176,
  "dfr;": 120097,
  "die;": 168,
  "div;": 247,
  "dot;": 729,
  "ecy;": 1101,
  "efr;": 120098,
  "egs;": 10902,
  "ell;": 8467,
  "els;": 10901,
  "eng;": 331,
  "eta;": 951,
  "eth;": 240,
  euml: 235,
  "fcy;": 1092,
  "ffr;": 120099,
  "gEl;": 10892,
  "gap;": 10886,
  "gcy;": 1075,
  "gel;": 8923,
  "geq;": 8805,
  "ges;": 10878,
  "gfr;": 120100,
  "ggg;": 8921,
  "glE;": 10898,
  "gla;": 10917,
  "glj;": 10916,
  "gnE;": 8809,
  "gne;": 10888,
  "hfr;": 120101,
  "icy;": 1080,
  "iff;": 8660,
  "ifr;": 120102,
  "int;": 8747,
  iuml: 239,
  "jcy;": 1081,
  "jfr;": 120103,
  "kcy;": 1082,
  "kfr;": 120104,
  "lEg;": 10891,
  "lap;": 10885,
  "lat;": 10923,
  "lcy;": 1083,
  "leg;": 8922,
  "leq;": 8804,
  "les;": 10877,
  "lfr;": 120105,
  "lgE;": 10897,
  "lnE;": 8808,
  "lne;": 10887,
  "loz;": 9674,
  "lrm;": 8206,
  "lsh;": 8624,
  macr: 175,
  "map;": 8614,
  "mcy;": 1084,
  "mfr;": 120106,
  "mho;": 8487,
  "mid;": 8739,
  "nGg;": 8921,
  "nGt;": 8811,
  "nLl;": 8920,
  "nLt;": 8810,
  "nap;": 8777,
  nbsp: 160,
  "ncy;": 1085,
  "nfr;": 120107,
  "ngE;": 8807,
  "nge;": 8817,
  "ngt;": 8815,
  "nis;": 8956,
  "niv;": 8715,
  "nlE;": 8806,
  "nle;": 8816,
  "nlt;": 8814,
  "not;": 172,
  "npr;": 8832,
  "nsc;": 8833,
  "num;": 35,
  "ocy;": 1086,
  "ofr;": 120108,
  "ogt;": 10689,
  "ohm;": 937,
  "olt;": 10688,
  "ord;": 10845,
  ordf: 170,
  ordm: 186,
  "orv;": 10843,
  ouml: 246,
  "par;": 8741,
  para: 182,
  "pcy;": 1087,
  "pfr;": 120109,
  "phi;": 966,
  "piv;": 982,
  "prE;": 10931,
  "pre;": 10927,
  "psi;": 968,
  "qfr;": 120110,
  quot: 34,
  "rcy;": 1088,
  "reg;": 174,
  "rfr;": 120111,
  "rho;": 961,
  "rlm;": 8207,
  "rsh;": 8625,
  "scE;": 10932,
  "sce;": 10928,
  "scy;": 1089,
  sect: 167,
  "sfr;": 120112,
  "shy;": 173,
  "sim;": 8764,
  "smt;": 10922,
  "sol;": 47,
  "squ;": 9633,
  "sub;": 8834,
  "sum;": 8721,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  "sup;": 8835,
  "tau;": 964,
  "tcy;": 1090,
  "tfr;": 120113,
  "top;": 8868,
  "ucy;": 1091,
  "ufr;": 120114,
  "uml;": 168,
  uuml: 252,
  "vcy;": 1074,
  "vee;": 8744,
  "vfr;": 120115,
  "wfr;": 120116,
  "xfr;": 120117,
  "ycy;": 1099,
  "yen;": 165,
  "yfr;": 120118,
  yuml: 255,
  "zcy;": 1079,
  "zfr;": 120119,
  "zwj;": 8205,
  AMP: 38,
  "DD;": 8517,
  ETH: 208,
  "GT;": 62,
  "Gg;": 8921,
  "Gt;": 8811,
  "Im;": 8465,
  "LT;": 60,
  "Ll;": 8920,
  "Lt;": 8810,
  "Mu;": 924,
  "Nu;": 925,
  "Or;": 10836,
  "Pi;": 928,
  "Pr;": 10939,
  REG: 174,
  "Re;": 8476,
  "Sc;": 10940,
  "Xi;": 926,
  "ac;": 8766,
  "af;": 8289,
  amp: 38,
  "ap;": 8776,
  "dd;": 8518,
  deg: 176,
  "ee;": 8519,
  "eg;": 10906,
  "el;": 10905,
  eth: 240,
  "gE;": 8807,
  "ge;": 8805,
  "gg;": 8811,
  "gl;": 8823,
  "gt;": 62,
  "ic;": 8291,
  "ii;": 8520,
  "in;": 8712,
  "it;": 8290,
  "lE;": 8806,
  "le;": 8804,
  "lg;": 8822,
  "ll;": 8810,
  "lt;": 60,
  "mp;": 8723,
  "mu;": 956,
  "ne;": 8800,
  "ni;": 8715,
  not: 172,
  "nu;": 957,
  "oS;": 9416,
  "or;": 8744,
  "pi;": 960,
  "pm;": 177,
  "pr;": 8826,
  reg: 174,
  "rx;": 8478,
  "sc;": 8827,
  shy: 173,
  uml: 168,
  "wp;": 8472,
  "wr;": 8768,
  "xi;": 958,
  yen: 165,
  GT: 62,
  LT: 60,
  gt: 62,
  lt: 60
};
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
function reg_exp_entity(entity_name, is_attribute_value) {
  if (is_attribute_value && !entity_name.endsWith(";")) {
    return `${entity_name}\\b(?!=)`;
  }
  return entity_name;
}
function get_entity_pattern(is_attribute_value) {
  const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
  const reg_exp_entities = Object.keys(entities).map((entity_name) => reg_exp_entity(entity_name, is_attribute_value));
  const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
  return entity_pattern;
}
var entity_pattern_content = get_entity_pattern(false);
var entity_pattern_attr_value = get_entity_pattern(true);
function decode_character_references(html2, is_attribute_value) {
  const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
  return html2.replace(entity_pattern, (match, entity) => {
    let code2;
    if (entity[0] !== "#") {
      code2 = entities[entity];
    } else if (entity[1] === "x") {
      code2 = parseInt(entity.substring(2), 16);
    } else {
      code2 = parseInt(entity.substring(1), 10);
    }
    if (!code2) {
      return match;
    }
    return String.fromCodePoint(validate_code(code2));
  });
}
var NUL = 0;
function validate_code(code2) {
  if (code2 === 10) {
    return 32;
  }
  if (code2 < 128) {
    return code2;
  }
  if (code2 <= 159) {
    return windows_1252[code2 - 128];
  }
  if (code2 < 55296) {
    return code2;
  }
  if (code2 <= 57343) {
    return NUL;
  }
  if (code2 <= 65535) {
    return code2;
  }
  if (code2 >= 65536 && code2 <= 131071) {
    return code2;
  }
  if (code2 >= 131072 && code2 <= 196607) {
    return code2;
  }
  return NUL;
}
var disallowed_contents = /* @__PURE__ */ new Map([
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["dt", /* @__PURE__ */ new Set(["dt", "dd"])],
  ["dd", /* @__PURE__ */ new Set(["dt", "dd"])],
  [
    "p",
    new Set("address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "))
  ],
  ["rt", /* @__PURE__ */ new Set(["rt", "rp"])],
  ["rp", /* @__PURE__ */ new Set(["rt", "rp"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup"])],
  ["option", /* @__PURE__ */ new Set(["option", "optgroup"])],
  ["thead", /* @__PURE__ */ new Set(["tbody", "tfoot"])],
  ["tbody", /* @__PURE__ */ new Set(["tbody", "tfoot"])],
  ["tfoot", /* @__PURE__ */ new Set(["tbody"])],
  ["tr", /* @__PURE__ */ new Set(["tr", "tbody"])],
  ["td", /* @__PURE__ */ new Set(["td", "th", "tr"])],
  ["th", /* @__PURE__ */ new Set(["td", "th", "tr"])]
]);
function closing_tag_omitted(current2, next) {
  if (disallowed_contents.has(current2)) {
    if (!next || disallowed_contents.get(current2).has(next)) {
      return true;
    }
  }
  return false;
}
var valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
var regex_starts_with_invalid_attr_value = /^(\/>|[\s"'=<>`])/;
var meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "Head"],
  ["svelte:options", "Options"],
  ["svelte:window", "Window"],
  ["svelte:document", "Document"],
  ["svelte:body", "Body"]
]);
var valid_meta_tags = Array.from(meta_tags.keys()).concat("svelte:self", "svelte:component", "svelte:fragment", "svelte:element");
var specials = /* @__PURE__ */ new Map([
  [
    "script",
    {
      read: read_script,
      property: "js"
    }
  ],
  [
    "style",
    {
      read: read_style,
      property: "css"
    }
  ]
]);
var SELF = /^svelte:self(?=[\s/>])/;
var COMPONENT = /^svelte:component(?=[\s/>])/;
var SLOT = /^svelte:fragment(?=[\s/>])/;
var ELEMENT = /^svelte:element(?=[\s/>])/;
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type: type2 } = stack[i];
    if (type2 === "Head")
      return true;
    if (type2 === "Element" || type2 === "InlineComponent")
      return false;
  }
  return false;
}
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_capital_letter = /[A-Z]/;
function tag(parser2) {
  const start2 = parser2.index++;
  let parent = parser2.current();
  if (parser2.eat("!--")) {
    const data3 = parser2.read_until(regex_closing_comment);
    parser2.eat("-->", true, parser_errors.unclosed_comment);
    parser2.current().children.push({
      start: start2,
      end: parser2.index,
      type: "Comment",
      data: data3,
      ignores: extract_svelte_ignore(data3)
    });
    return;
  }
  const is_closing_tag = parser2.eat("/");
  const name3 = read_tag_name(parser2);
  if (meta_tags.has(name3)) {
    const slug = meta_tags.get(name3).toLowerCase();
    if (is_closing_tag) {
      if ((name3 === "svelte:window" || name3 === "svelte:body") && parser2.current().children.length) {
        parser2.error(parser_errors.invalid_element_content(slug, name3), parser2.current().children[0].start);
      }
    } else {
      if (name3 in parser2.meta_tags) {
        parser2.error(parser_errors.duplicate_element(slug, name3), start2);
      }
      if (parser2.stack.length > 1) {
        parser2.error(parser_errors.invalid_element_placement(slug, name3), start2);
      }
      parser2.meta_tags[name3] = true;
    }
  }
  const type2 = meta_tags.has(name3) ? meta_tags.get(name3) : regex_capital_letter.test(name3[0]) || name3 === "svelte:self" || name3 === "svelte:component" ? "InlineComponent" : name3 === "svelte:fragment" ? "SlotTemplate" : name3 === "title" && parent_is_head(parser2.stack) ? "Title" : name3 === "slot" && !parser2.customElement ? "Slot" : "Element";
  const element2 = {
    start: start2,
    end: null,
    type: type2,
    name: name3,
    attributes: [],
    children: []
  };
  parser2.allow_whitespace();
  if (is_closing_tag) {
    if (is_void(name3)) {
      parser2.error(parser_errors.invalid_void_content(name3), start2);
    }
    parser2.eat(">", true);
    while (parent.name !== name3) {
      if (parent.type !== "Element") {
        const error2 = parser2.last_auto_closed_tag && parser2.last_auto_closed_tag.tag === name3 ? parser_errors.invalid_closing_tag_autoclosed(name3, parser2.last_auto_closed_tag.reason) : parser_errors.invalid_closing_tag_unopened(name3);
        parser2.error(error2, start2);
      }
      parent.end = start2;
      parser2.stack.pop();
      parent = parser2.current();
    }
    parent.end = parser2.index;
    parser2.stack.pop();
    if (parser2.last_auto_closed_tag && parser2.stack.length < parser2.last_auto_closed_tag.depth) {
      parser2.last_auto_closed_tag = null;
    }
    return;
  } else if (closing_tag_omitted(parent.name, name3)) {
    parent.end = start2;
    parser2.stack.pop();
    parser2.last_auto_closed_tag = {
      tag: parent.name,
      reason: name3,
      depth: parser2.stack.length
    };
  }
  const unique_names = /* @__PURE__ */ new Set();
  let attribute2;
  while (attribute2 = read_attribute(parser2, unique_names)) {
    element2.attributes.push(attribute2);
    parser2.allow_whitespace();
  }
  if (name3 === "svelte:component") {
    const index2 = element2.attributes.findIndex((attr) => attr.type === "Attribute" && attr.name === "this");
    if (index2 === -1) {
      parser2.error(parser_errors.missing_component_definition, start2);
    }
    const definition2 = element2.attributes.splice(index2, 1)[0];
    if (definition2.value === true || definition2.value.length !== 1 || definition2.value[0].type === "Text") {
      parser2.error(parser_errors.invalid_component_definition, definition2.start);
    }
    element2.expression = definition2.value[0].expression;
  }
  if (name3 === "svelte:element") {
    const index2 = element2.attributes.findIndex((attr) => attr.type === "Attribute" && attr.name === "this");
    if (index2 === -1) {
      parser2.error(parser_errors.missing_element_definition, start2);
    }
    const definition2 = element2.attributes.splice(index2, 1)[0];
    if (definition2.value === true) {
      parser2.error(parser_errors.invalid_element_definition, definition2.start);
    }
    element2.tag = definition2.value[0].data || definition2.value[0].expression;
  }
  if (specials.has(name3) && parser2.stack.length === 1) {
    const special = specials.get(name3);
    parser2.eat(">", true);
    const content = special.read(parser2, start2, element2.attributes);
    if (content)
      parser2[special.property].push(content);
    return;
  }
  parser2.current().children.push(element2);
  const self_closing = parser2.eat("/") || is_void(name3);
  parser2.eat(">", true);
  if (self_closing) {
    element2.end = parser2.index;
  } else if (name3 === "textarea") {
    element2.children = read_sequence(parser2, () => regex_closing_textarea_tag.test(parser2.template.slice(parser2.index)), "inside <textarea>");
    parser2.read(regex_closing_textarea_tag);
    element2.end = parser2.index;
  } else if (name3 === "script" || name3 === "style") {
    const start3 = parser2.index;
    const data3 = parser2.read_until(new RegExp(`</${name3}>`));
    const end2 = parser2.index;
    element2.children.push({ start: start3, end: end2, type: "Text", data: data3 });
    parser2.eat(`</${name3}>`, true);
    element2.end = parser2.index;
  } else {
    parser2.stack.push(element2);
  }
}
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
function read_tag_name(parser2) {
  const start2 = parser2.index;
  if (parser2.read(SELF)) {
    let i = parser2.stack.length;
    let legal = false;
    while (i--) {
      const fragment2 = parser2.stack[i];
      if (fragment2.type === "IfBlock" || fragment2.type === "EachBlock" || fragment2.type === "InlineComponent") {
        legal = true;
        break;
      }
    }
    if (!legal) {
      parser2.error(parser_errors.invalid_self_placement, start2);
    }
    return "svelte:self";
  }
  if (parser2.read(COMPONENT))
    return "svelte:component";
  if (parser2.read(ELEMENT))
    return "svelte:element";
  if (parser2.read(SLOT))
    return "svelte:fragment";
  const name3 = parser2.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (meta_tags.has(name3))
    return name3;
  if (name3.startsWith("svelte:")) {
    const match = fuzzymatch(name3.slice(7), valid_meta_tags);
    parser2.error(parser_errors.invalid_tag_name_svelte_element(valid_meta_tags, match), start2);
  }
  if (!valid_tag_name.test(name3)) {
    parser2.error(parser_errors.invalid_tag_name, start2);
  }
  return name3;
}
var regex_token_ending_character = /[\s=\/>"']/;
var regex_starts_with_quote_characters = /^["']/;
function read_attribute(parser2, unique_names) {
  const start2 = parser2.index;
  function check_unique(name4) {
    if (unique_names.has(name4)) {
      parser2.error(parser_errors.duplicate_attribute, start2);
    }
    unique_names.add(name4);
  }
  if (parser2.eat("{")) {
    parser2.allow_whitespace();
    if (parser2.eat("...")) {
      const expression = read_expression(parser2);
      parser2.allow_whitespace();
      parser2.eat("}", true);
      return {
        start: start2,
        end: parser2.index,
        type: "Spread",
        expression
      };
    } else {
      const value_start = parser2.index;
      const name4 = parser2.read_identifier();
      parser2.allow_whitespace();
      parser2.eat("}", true);
      if (name4 === null) {
        parser2.error(parser_errors.empty_attribute_shorthand, start2);
      }
      check_unique(name4);
      return {
        start: start2,
        end: parser2.index,
        type: "Attribute",
        name: name4,
        value: [{
          start: value_start,
          end: value_start + name4.length,
          type: "AttributeShorthand",
          expression: {
            start: value_start,
            end: value_start + name4.length,
            type: "Identifier",
            name: name4
          }
        }]
      };
    }
  }
  const name3 = parser2.read_until(regex_token_ending_character);
  if (!name3)
    return null;
  let end2 = parser2.index;
  parser2.allow_whitespace();
  const colon_index = name3.indexOf(":");
  const type2 = colon_index !== -1 && get_directive_type(name3.slice(0, colon_index));
  let value = true;
  if (parser2.eat("=")) {
    parser2.allow_whitespace();
    value = read_attribute_value(parser2);
    end2 = parser2.index;
  } else if (parser2.match_regex(regex_starts_with_quote_characters)) {
    parser2.error(parser_errors.unexpected_token("="), parser2.index);
  }
  if (type2) {
    const [directive_name, ...modifiers] = name3.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      parser2.error(parser_errors.empty_directive_name(type2), start2 + colon_index + 1);
    }
    if (type2 === "Binding" && directive_name !== "this") {
      check_unique(directive_name);
    } else if (type2 !== "EventHandler" && type2 !== "Action") {
      check_unique(name3);
    }
    if (type2 === "Ref") {
      parser2.error(parser_errors.invalid_ref_directive(directive_name), start2);
    }
    if (type2 === "StyleDirective") {
      return {
        start: start2,
        end: end2,
        type: type2,
        name: directive_name,
        modifiers,
        value
      };
    }
    const first_value = value[0];
    let expression = null;
    if (first_value) {
      const attribute_contains_text = value.length > 1 || first_value.type === "Text";
      if (attribute_contains_text) {
        parser2.error(parser_errors.invalid_directive_value, first_value.start);
      } else {
        expression = first_value.expression;
      }
    }
    const directive = {
      start: start2,
      end: end2,
      type: type2,
      name: directive_name,
      modifiers,
      expression
    };
    if (type2 === "Transition") {
      const direction = name3.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if (!directive.expression && (type2 === "Binding" || type2 === "Class")) {
      directive.expression = {
        start: directive.start + colon_index + 1,
        end: directive.end,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  check_unique(name3);
  return {
    start: start2,
    end: end2,
    type: "Attribute",
    name: name3,
    value
  };
}
function get_directive_type(name3) {
  if (name3 === "use")
    return "Action";
  if (name3 === "animate")
    return "Animation";
  if (name3 === "bind")
    return "Binding";
  if (name3 === "class")
    return "Class";
  if (name3 === "style")
    return "StyleDirective";
  if (name3 === "on")
    return "EventHandler";
  if (name3 === "let")
    return "Let";
  if (name3 === "ref")
    return "Ref";
  if (name3 === "in" || name3 === "out" || name3 === "transition")
    return "Transition";
}
function read_attribute_value(parser2) {
  const quote_mark = parser2.eat("'") ? "'" : parser2.eat('"') ? '"' : null;
  if (quote_mark && parser2.eat(quote_mark)) {
    return [{
      start: parser2.index - 1,
      end: parser2.index - 1,
      type: "Text",
      raw: "",
      data: ""
    }];
  }
  let value;
  try {
    value = read_sequence(parser2, () => {
      if (quote_mark)
        return parser2.match(quote_mark);
      return !!parser2.match_regex(regex_starts_with_invalid_attr_value);
    }, "in attribute value");
  } catch (error2) {
    if (error2.code === "parse-error") {
      if (parser2.template.slice(error2.pos - 1, error2.pos + 1) === "/>") {
        parser2.index = error2.pos;
        parser2.error(parser_errors.unclosed_attribute_value(quote_mark || "}"));
      }
    }
    throw error2;
  }
  if (value.length === 0 && !quote_mark) {
    parser2.error(parser_errors.missing_attribute_value);
  }
  if (quote_mark)
    parser2.index += 1;
  return value;
}
function read_sequence(parser2, done, location) {
  let current_chunk = {
    start: parser2.index,
    end: null,
    type: "Text",
    raw: "",
    data: null
  };
  const chunks = [];
  function flush(end2) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw, true);
      current_chunk.end = end2;
      chunks.push(current_chunk);
    }
  }
  while (parser2.index < parser2.template.length) {
    const index2 = parser2.index;
    if (done()) {
      flush(parser2.index);
      return chunks;
    } else if (parser2.eat("{")) {
      if (parser2.match("#")) {
        const index3 = parser2.index - 1;
        parser2.eat("#");
        const name3 = parser2.read_until(/[^a-z]/);
        parser2.error(parser_errors.invalid_logic_block_placement(location, name3), index3);
      } else if (parser2.match("@")) {
        const index3 = parser2.index - 1;
        parser2.eat("@");
        const name3 = parser2.read_until(/[^a-z]/);
        parser2.error(parser_errors.invalid_tag_placement(location, name3), index3);
      }
      flush(parser2.index - 1);
      parser2.allow_whitespace();
      const expression = read_expression(parser2);
      parser2.allow_whitespace();
      parser2.eat("}", true);
      chunks.push({
        start: index2,
        end: parser2.index,
        type: "MustacheTag",
        expression
      });
      current_chunk = {
        start: parser2.index,
        end: null,
        type: "Text",
        raw: "",
        data: null
      };
    } else {
      current_chunk.raw += parser2.template[parser2.index++];
    }
  }
  parser2.error(parser_errors.unexpected_eof);
}
function full_char_code_at(str2, i) {
  const code2 = str2.charCodeAt(i);
  if (code2 <= 55295 || code2 >= 57344)
    return code2;
  const next = str2.charCodeAt(i + 1);
  return (code2 << 10) + next - 56613888;
}
var SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
var SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
var CURLY_BRACKET_OPEN = "{".charCodeAt(0);
var CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
function is_bracket_open(code2) {
  return code2 === SQUARE_BRACKET_OPEN || code2 === CURLY_BRACKET_OPEN;
}
function is_bracket_close(code2) {
  return code2 === SQUARE_BRACKET_CLOSE || code2 === CURLY_BRACKET_CLOSE;
}
function is_bracket_pair(open, close) {
  return open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE || open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE;
}
function get_bracket_close(open) {
  if (open === SQUARE_BRACKET_OPEN) {
    return SQUARE_BRACKET_CLOSE;
  }
  if (open === CURLY_BRACKET_OPEN) {
    return CURLY_BRACKET_CLOSE;
  }
}
function read_context(parser2) {
  const start2 = parser2.index;
  let i = parser2.index;
  const code2 = full_char_code_at(parser2.template, i);
  if (isIdentifierStart(code2, true)) {
    return {
      type: "Identifier",
      name: parser2.read_identifier(),
      start: start2,
      end: parser2.index
    };
  }
  if (!is_bracket_open(code2)) {
    parser2.error(parser_errors.unexpected_token_destructure);
  }
  const bracket_stack = [code2];
  i += code2 <= 65535 ? 1 : 2;
  while (i < parser2.template.length) {
    const code3 = full_char_code_at(parser2.template, i);
    if (is_bracket_open(code3)) {
      bracket_stack.push(code3);
    } else if (is_bracket_close(code3)) {
      if (!is_bracket_pair(bracket_stack[bracket_stack.length - 1], code3)) {
        parser2.error(parser_errors.unexpected_token(String.fromCharCode(get_bracket_close(bracket_stack[bracket_stack.length - 1]))));
      }
      bracket_stack.pop();
      if (bracket_stack.length === 0) {
        i += code3 <= 65535 ? 1 : 2;
        break;
      }
    }
    i += code3 <= 65535 ? 1 : 2;
  }
  parser2.index = i;
  const pattern_string = parser2.template.slice(start2, i);
  try {
    let space_with_newline = parser2.template.slice(0, start2).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    return parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start2 - 1).left;
  } catch (error2) {
    parser2.acorn_error(error2);
  }
}
function trim_start(str2) {
  return str2.replace(regex_starts_with_whitespaces, "");
}
function trim_end(str2) {
  return str2.replace(regex_ends_with_whitespaces, "");
}
function to_string(node2) {
  switch (node2.type) {
    case "IfBlock":
      return "{#if} block";
    case "ThenBlock":
      return "{:then} block";
    case "ElseBlock":
      return "{:else} block";
    case "PendingBlock":
    case "AwaitBlock":
      return "{#await} block";
    case "CatchBlock":
      return "{:catch} block";
    case "EachBlock":
      return "{#each} block";
    case "RawMustacheTag":
      return "{@html} block";
    case "DebugTag":
      return "{@debug} block";
    case "ConstTag":
      return "{@const} tag";
    case "Element":
    case "InlineComponent":
    case "Slot":
    case "Title":
      return `<${node2.name}> tag`;
    default:
      return node2.type;
  }
}
function trim_whitespace(block2, trim_before, trim_after) {
  if (!block2.children || block2.children.length === 0)
    return;
  const first_child = block2.children[0];
  const last_child = block2.children[block2.children.length - 1];
  if (first_child.type === "Text" && trim_before) {
    first_child.data = trim_start(first_child.data);
    if (!first_child.data)
      block2.children.shift();
  }
  if (last_child.type === "Text" && trim_after) {
    last_child.data = trim_end(last_child.data);
    if (!last_child.data)
      block2.children.pop();
  }
  if (block2.else) {
    trim_whitespace(block2.else, trim_before, trim_after);
  }
  if (first_child.elseif) {
    trim_whitespace(first_child, trim_before, trim_after);
  }
}
var regex_whitespace_with_closing_curly_brace = /^\s*}/;
function mustache(parser2) {
  const start2 = parser2.index;
  parser2.index += 1;
  parser2.allow_whitespace();
  if (parser2.eat("/")) {
    let block2 = parser2.current();
    let expected;
    if (closing_tag_omitted(block2.name)) {
      block2.end = start2;
      parser2.stack.pop();
      block2 = parser2.current();
    }
    if (block2.type === "ElseBlock" || block2.type === "PendingBlock" || block2.type === "ThenBlock" || block2.type === "CatchBlock") {
      block2.end = start2;
      parser2.stack.pop();
      block2 = parser2.current();
      expected = "await";
    }
    if (block2.type === "IfBlock") {
      expected = "if";
    } else if (block2.type === "EachBlock") {
      expected = "each";
    } else if (block2.type === "AwaitBlock") {
      expected = "await";
    } else if (block2.type === "KeyBlock") {
      expected = "key";
    } else {
      parser2.error(parser_errors.unexpected_block_close);
    }
    parser2.eat(expected, true);
    parser2.allow_whitespace();
    parser2.eat("}", true);
    while (block2.elseif) {
      block2.end = parser2.index;
      parser2.stack.pop();
      block2 = parser2.current();
      if (block2.else) {
        block2.else.end = start2;
      }
    }
    const char_before = parser2.template[block2.start - 1];
    const char_after = parser2.template[parser2.index];
    const trim_before = !char_before || regex_whitespace.test(char_before);
    const trim_after = !char_after || regex_whitespace.test(char_after);
    trim_whitespace(block2, trim_before, trim_after);
    block2.end = parser2.index;
    parser2.stack.pop();
  } else if (parser2.eat(":else")) {
    if (parser2.eat("if")) {
      parser2.error(parser_errors.invalid_elseif);
    }
    parser2.allow_whitespace();
    if (parser2.eat("if")) {
      const block2 = parser2.current();
      if (block2.type !== "IfBlock") {
        parser2.error(parser2.stack.some((block3) => block3.type === "IfBlock") ? parser_errors.invalid_elseif_placement_unclosed_block(to_string(block2)) : parser_errors.invalid_elseif_placement_outside_if);
      }
      parser2.require_whitespace();
      const expression = read_expression(parser2);
      parser2.allow_whitespace();
      parser2.eat("}", true);
      block2.else = {
        start: parser2.index,
        end: null,
        type: "ElseBlock",
        children: [
          {
            start: parser2.index,
            end: null,
            type: "IfBlock",
            elseif: true,
            expression,
            children: []
          }
        ]
      };
      parser2.stack.push(block2.else.children[0]);
    } else {
      const block2 = parser2.current();
      if (block2.type !== "IfBlock" && block2.type !== "EachBlock") {
        parser2.error(parser2.stack.some((block3) => block3.type === "IfBlock" || block3.type === "EachBlock") ? parser_errors.invalid_else_placement_unclosed_block(to_string(block2)) : parser_errors.invalid_else_placement_outside_if);
      }
      parser2.allow_whitespace();
      parser2.eat("}", true);
      block2.else = {
        start: parser2.index,
        end: null,
        type: "ElseBlock",
        children: []
      };
      parser2.stack.push(block2.else);
    }
  } else if (parser2.match(":then") || parser2.match(":catch")) {
    const block2 = parser2.current();
    const is_then = parser2.eat(":then") || !parser2.eat(":catch");
    if (is_then) {
      if (block2.type !== "PendingBlock") {
        parser2.error(parser2.stack.some((block3) => block3.type === "PendingBlock") ? parser_errors.invalid_then_placement_unclosed_block(to_string(block2)) : parser_errors.invalid_then_placement_without_await);
      }
    } else {
      if (block2.type !== "ThenBlock" && block2.type !== "PendingBlock") {
        parser2.error(parser2.stack.some((block3) => block3.type === "ThenBlock" || block3.type === "PendingBlock") ? parser_errors.invalid_catch_placement_unclosed_block(to_string(block2)) : parser_errors.invalid_catch_placement_without_await);
      }
    }
    block2.end = start2;
    parser2.stack.pop();
    const await_block = parser2.current();
    if (!parser2.eat("}")) {
      parser2.require_whitespace();
      await_block[is_then ? "value" : "error"] = read_context(parser2);
      parser2.allow_whitespace();
      parser2.eat("}", true);
    }
    const new_block = {
      start: start2,
      end: null,
      type: is_then ? "ThenBlock" : "CatchBlock",
      children: [],
      skip: false
    };
    await_block[is_then ? "then" : "catch"] = new_block;
    parser2.stack.push(new_block);
  } else if (parser2.eat("#")) {
    let type2;
    if (parser2.eat("if")) {
      type2 = "IfBlock";
    } else if (parser2.eat("each")) {
      type2 = "EachBlock";
    } else if (parser2.eat("await")) {
      type2 = "AwaitBlock";
    } else if (parser2.eat("key")) {
      type2 = "KeyBlock";
    } else {
      parser2.error(parser_errors.expected_block_type);
    }
    parser2.require_whitespace();
    const expression = read_expression(parser2);
    const block2 = type2 === "AwaitBlock" ? {
      start: start2,
      end: null,
      type: type2,
      expression,
      value: null,
      error: null,
      pending: {
        start: null,
        end: null,
        type: "PendingBlock",
        children: [],
        skip: true
      },
      then: {
        start: null,
        end: null,
        type: "ThenBlock",
        children: [],
        skip: true
      },
      catch: {
        start: null,
        end: null,
        type: "CatchBlock",
        children: [],
        skip: true
      }
    } : {
      start: start2,
      end: null,
      type: type2,
      expression,
      children: []
    };
    parser2.allow_whitespace();
    if (type2 === "EachBlock") {
      parser2.eat("as", true);
      parser2.require_whitespace();
      block2.context = read_context(parser2);
      parser2.allow_whitespace();
      if (parser2.eat(",")) {
        parser2.allow_whitespace();
        block2.index = parser2.read_identifier();
        if (!block2.index)
          parser2.error(parser_errors.expected_name);
        parser2.allow_whitespace();
      }
      if (parser2.eat("(")) {
        parser2.allow_whitespace();
        block2.key = read_expression(parser2);
        parser2.allow_whitespace();
        parser2.eat(")", true);
        parser2.allow_whitespace();
      }
    }
    const await_block_shorthand = type2 === "AwaitBlock" && parser2.eat("then");
    if (await_block_shorthand) {
      if (parser2.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser2.allow_whitespace();
      } else {
        parser2.require_whitespace();
        block2.value = read_context(parser2);
        parser2.allow_whitespace();
      }
    }
    const await_block_catch_shorthand = !await_block_shorthand && type2 === "AwaitBlock" && parser2.eat("catch");
    if (await_block_catch_shorthand) {
      if (parser2.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser2.allow_whitespace();
      } else {
        parser2.require_whitespace();
        block2.error = read_context(parser2);
        parser2.allow_whitespace();
      }
    }
    parser2.eat("}", true);
    parser2.current().children.push(block2);
    parser2.stack.push(block2);
    if (type2 === "AwaitBlock") {
      let child_block;
      if (await_block_shorthand) {
        block2.then.skip = false;
        child_block = block2.then;
      } else if (await_block_catch_shorthand) {
        block2.catch.skip = false;
        child_block = block2.catch;
      } else {
        block2.pending.skip = false;
        child_block = block2.pending;
      }
      child_block.start = parser2.index;
      parser2.stack.push(child_block);
    }
  } else if (parser2.eat("@html")) {
    parser2.require_whitespace();
    const expression = read_expression(parser2);
    parser2.allow_whitespace();
    parser2.eat("}", true);
    parser2.current().children.push({
      start: start2,
      end: parser2.index,
      type: "RawMustacheTag",
      expression
    });
  } else if (parser2.eat("@debug")) {
    let identifiers;
    if (parser2.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser2);
      identifiers = expression.type === "SequenceExpression" ? expression.expressions : [expression];
      identifiers.forEach((node2) => {
        if (node2.type !== "Identifier") {
          parser2.error(parser_errors.invalid_debug_args, node2.start);
        }
      });
      parser2.allow_whitespace();
      parser2.eat("}", true);
    }
    parser2.current().children.push({
      start: start2,
      end: parser2.index,
      type: "DebugTag",
      identifiers
    });
  } else if (parser2.eat("@const")) {
    parser2.require_whitespace();
    const expression = read_expression(parser2);
    if (!(expression.type === "AssignmentExpression" && expression.operator === "=")) {
      parser2.error({
        code: "invalid-const-args",
        message: "{@const ...} must be an assignment."
      }, start2);
    }
    parser2.allow_whitespace();
    parser2.eat("}", true);
    parser2.current().children.push({
      start: start2,
      end: parser2.index,
      type: "ConstTag",
      expression
    });
  } else {
    const expression = read_expression(parser2);
    parser2.allow_whitespace();
    parser2.eat("}", true);
    parser2.current().children.push({
      start: start2,
      end: parser2.index,
      type: "MustacheTag",
      expression
    });
  }
}
function text(parser2) {
  const start2 = parser2.index;
  let data3 = "";
  while (parser2.index < parser2.template.length && !parser2.match("<") && !parser2.match("{")) {
    data3 += parser2.template[parser2.index++];
  }
  const node2 = {
    start: start2,
    end: parser2.index,
    type: "Text",
    raw: data3,
    data: decode_character_references(data3, false)
  };
  parser2.current().children.push(node2);
}
function fragment(parser2) {
  if (parser2.match("<")) {
    return tag;
  }
  if (parser2.match("{")) {
    return mustache;
  }
  return text;
}
var reserved = /* @__PURE__ */ new Set([
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield"
]);
function getLocator(source, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var offsetLine = options2.offsetLine || 0;
  var offsetColumn = options2.offsetColumn || 0;
  var originalLines = source.split("\n");
  var start2 = 0;
  var lineRanges = originalLines.map(function(line2, i2) {
    var end2 = start2 + line2.length + 1;
    var range2 = { start: start2, end: end2, line: i2 };
    start2 = end2;
    return range2;
  });
  var i = 0;
  function rangeContains(range2, index2) {
    return range2.start <= index2 && index2 < range2.end;
  }
  function getLocation(range2, index2) {
    return { line: offsetLine + range2.line, column: offsetColumn + index2 - range2.start, character: index2 };
  }
  function locate3(search, startIndex) {
    if (typeof search === "string") {
      search = source.indexOf(search, startIndex || 0);
    }
    var range2 = lineRanges[i];
    var d2 = search >= range2.end ? 1 : -1;
    while (range2) {
      if (rangeContains(range2, search))
        return getLocation(range2, search);
      i += d2;
      range2 = lineRanges[i];
    }
  }
  return locate3;
}
function locate(source, search, options2) {
  if (typeof options2 === "number") {
    throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");
  }
  return getLocator(source, options2)(search, options2 && options2.startIndex);
}
var regex_tabs = /^\t+/;
function tabs_to_spaces(str2) {
  return str2.replace(regex_tabs, (match) => match.split("	").join("  "));
}
function get_code_frame(source, line2, column) {
  const lines = source.split("\n");
  const frame_start = Math.max(0, line2 - 2);
  const frame_end = Math.min(line2 + 3, lines.length);
  const digits = String(frame_end + 1).length;
  return lines.slice(frame_start, frame_end).map((str2, i) => {
    const is_error_line = frame_start + i === line2;
    const line_num = String(i + frame_start + 1).padStart(digits, " ");
    if (is_error_line) {
      const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str2.slice(0, column)).length) + "^";
      return `${line_num}: ${tabs_to_spaces(str2)}
${indicator}`;
    }
    return `${line_num}: ${tabs_to_spaces(str2)}`;
  }).join("\n");
}
var CompileError = class extends Error {
  toString() {
    return `${this.message} (${this.start.line}:${this.start.column})
${this.frame}`;
  }
};
function error(message2, props) {
  const error2 = new CompileError(message2);
  error2.name = props.name;
  const start2 = locate(props.source, props.start, { offsetLine: 1 });
  const end2 = locate(props.source, props.end || props.start, { offsetLine: 1 });
  error2.code = props.code;
  error2.start = start2;
  error2.end = end2;
  error2.pos = props.start;
  error2.filename = props.filename;
  error2.frame = get_code_frame(props.source, start2.line - 1, start2.column);
  throw error2;
}
var regex_position_indicator = / \(\d+:\d+\)$/;
var Parser$1 = class {
  constructor(template, options2) {
    this.index = 0;
    this.stack = [];
    this.css = [];
    this.js = [];
    this.meta_tags = {};
    if (typeof template !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.template = template.trimRight();
    this.filename = options2.filename;
    this.customElement = options2.customElement;
    this.css_mode = options2.css;
    this.html = {
      start: null,
      end: null,
      type: "Fragment",
      children: []
    };
    this.stack.push(this.html);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current2 = this.current();
      const type2 = current2.type === "Element" ? `<${current2.name}>` : "Block";
      const slug = current2.type === "Element" ? "element" : "block";
      this.error({
        code: `unclosed-${slug}`,
        message: `${type2} was left open`
      }, current2.start);
    }
    if (state !== fragment) {
      this.error({
        code: "unexpected-eof",
        message: "Unexpected end of input"
      });
    }
    if (this.html.children.length) {
      let start2 = this.html.children[0].start;
      while (regex_whitespace.test(template[start2]))
        start2 += 1;
      let end2 = this.html.children[this.html.children.length - 1].end;
      while (regex_whitespace.test(template[end2 - 1]))
        end2 -= 1;
      this.html.start = start2;
      this.html.end = end2;
    } else {
      this.html.start = this.html.end = null;
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  acorn_error(err) {
    this.error({
      code: "parse-error",
      message: err.message.replace(regex_position_indicator, "")
    }, err.pos);
  }
  error({ code: code2, message: message2 }, index2 = this.index) {
    error(message2, {
      name: "ParseError",
      code: code2,
      source: this.template,
      start: index2,
      filename: this.filename
    });
  }
  eat(str2, required, error2) {
    if (this.match(str2)) {
      this.index += str2.length;
      return true;
    }
    if (required) {
      this.error(error2 || (this.index === this.template.length ? parser_errors.unexpected_eof_token(str2) : parser_errors.unexpected_token(str2)));
    }
    return false;
  }
  match(str2) {
    return this.template.slice(this.index, this.index + str2.length) === str2;
  }
  /**
   * Match a regex at the current index
   * @param pattern Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0)
      return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  /**
   * Search for a regex starting at the current index and return the result if it matches
   * @param pattern Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result)
      this.index += result.length;
    return result;
  }
  read_identifier(allow_reserved = false) {
    const start2 = this.index;
    let i = this.index;
    const code2 = full_char_code_at(this.template, i);
    if (!isIdentifierStart(code2, true))
      return null;
    i += code2 <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code3 = full_char_code_at(this.template, i);
      if (!isIdentifierChar(code3, true))
        break;
      i += code3 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && reserved.has(identifier)) {
      this.error({
        code: "unexpected-reserved-word",
        message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`
      }, start2);
    }
    return identifier;
  }
  read_until(pattern, error_message) {
    if (this.index >= this.template.length) {
      this.error(error_message || {
        code: "unexpected-eof",
        message: "Unexpected end of input"
      });
    }
    const start2 = this.index;
    const match = pattern.exec(this.template.slice(start2));
    if (match) {
      this.index = start2 + match.index;
      return this.template.slice(start2, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start2);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      this.error({
        code: "missing-whitespace",
        message: "Expected whitespace"
      });
    }
    this.allow_whitespace();
  }
};
function parse$b(template, options2 = {}) {
  const parser2 = new Parser$1(template, options2);
  if (parser2.css.length > 1) {
    parser2.error(parser_errors.duplicate_style, parser2.css[1].start);
  }
  const instance_scripts = parser2.js.filter((script) => script.context === "default");
  const module_scripts = parser2.js.filter((script) => script.context === "module");
  if (instance_scripts.length > 1) {
    parser2.error(parser_errors.invalid_script_instance, instance_scripts[1].start);
  }
  if (module_scripts.length > 1) {
    parser2.error(parser_errors.invalid_script_module, module_scripts[1].start);
  }
  return {
    html: parser2.html,
    css: parser2.css[0],
    instance: instance_scripts[0],
    module: module_scripts[0]
  };
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function unwrapExports(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function createCommonjsModule(fn2, module) {
  return module = { exports: {} }, fn2(module, module.exports), module.exports;
}
function getCjsExportFromNamespace(n) {
  return n && n["default"] || n;
}
var iteratorProxy_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  function iteratorProxy() {
    var values2 = this;
    var index2 = 0;
    var iter = {
      "@@iterator": function iterator() {
        return iter;
      },
      next: function next() {
        if (index2 < values2.length) {
          var value = values2[index2];
          index2 = index2 + 1;
          return {
            done: false,
            value
          };
        } else {
          return {
            done: true
          };
        }
      }
    };
    return iter;
  }
  var _default = iteratorProxy;
  exports.default = _default;
});
unwrapExports(iteratorProxy_1);
var iterationDecorator_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = iterationDecorator;
  var _iteratorProxy = _interopRequireDefault(iteratorProxy_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function iterationDecorator(collection, entries) {
    if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
      Object.defineProperty(collection, Symbol.iterator, {
        value: _iteratorProxy.default.bind(entries)
      });
    }
    return collection;
  }
});
unwrapExports(iterationDecorator_1);
var ariaPropsMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i) {
    var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i2 == null)
      return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _s2, _e2;
    try {
      for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
        _arr.push(_s2.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i2["return"] != null)
          _i2["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it3 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it3) {
      if (Array.isArray(o) || (it3 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it3)
          o = it3;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it3 = it3.call(o);
    }, n: function n() {
      var step = it3.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it3.return != null)
          it3.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var properties = [["aria-activedescendant", {
    "type": "id"
  }], ["aria-atomic", {
    "type": "boolean"
  }], ["aria-autocomplete", {
    "type": "token",
    "values": ["inline", "list", "both", "none"]
  }], ["aria-busy", {
    "type": "boolean"
  }], ["aria-checked", {
    "type": "tristate"
  }], ["aria-colcount", {
    type: "integer"
  }], ["aria-colindex", {
    type: "integer"
  }], ["aria-colspan", {
    type: "integer"
  }], ["aria-controls", {
    "type": "idlist"
  }], ["aria-current", {
    type: "token",
    values: ["page", "step", "location", "date", "time", true, false]
  }], ["aria-describedby", {
    "type": "idlist"
  }], ["aria-details", {
    "type": "id"
  }], ["aria-disabled", {
    "type": "boolean"
  }], ["aria-dropeffect", {
    "type": "tokenlist",
    "values": ["copy", "execute", "link", "move", "none", "popup"]
  }], ["aria-errormessage", {
    "type": "id"
  }], ["aria-expanded", {
    "type": "boolean",
    "allowundefined": true
  }], ["aria-flowto", {
    "type": "idlist"
  }], ["aria-grabbed", {
    "type": "boolean",
    "allowundefined": true
  }], ["aria-haspopup", {
    "type": "token",
    "values": [false, true, "menu", "listbox", "tree", "grid", "dialog"]
  }], ["aria-hidden", {
    "type": "boolean",
    "allowundefined": true
  }], ["aria-invalid", {
    "type": "token",
    "values": ["grammar", false, "spelling", true]
  }], ["aria-keyshortcuts", {
    type: "string"
  }], ["aria-label", {
    "type": "string"
  }], ["aria-labelledby", {
    "type": "idlist"
  }], ["aria-level", {
    "type": "integer"
  }], ["aria-live", {
    "type": "token",
    "values": ["assertive", "off", "polite"]
  }], ["aria-modal", {
    type: "boolean"
  }], ["aria-multiline", {
    "type": "boolean"
  }], ["aria-multiselectable", {
    "type": "boolean"
  }], ["aria-orientation", {
    "type": "token",
    "values": ["vertical", "undefined", "horizontal"]
  }], ["aria-owns", {
    "type": "idlist"
  }], ["aria-placeholder", {
    type: "string"
  }], ["aria-posinset", {
    "type": "integer"
  }], ["aria-pressed", {
    "type": "tristate"
  }], ["aria-readonly", {
    "type": "boolean"
  }], ["aria-relevant", {
    "type": "tokenlist",
    "values": ["additions", "all", "removals", "text"]
  }], ["aria-required", {
    "type": "boolean"
  }], ["aria-roledescription", {
    type: "string"
  }], ["aria-rowcount", {
    type: "integer"
  }], ["aria-rowindex", {
    type: "integer"
  }], ["aria-rowspan", {
    type: "integer"
  }], ["aria-selected", {
    "type": "boolean",
    "allowundefined": true
  }], ["aria-setsize", {
    "type": "integer"
  }], ["aria-sort", {
    "type": "token",
    "values": ["ascending", "descending", "none", "other"]
  }], ["aria-valuemax", {
    "type": "number"
  }], ["aria-valuemin", {
    "type": "number"
  }], ["aria-valuenow", {
    "type": "number"
  }], ["aria-valuetext", {
    "type": "string"
  }]];
  var ariaPropsMap = {
    entries: function entries() {
      return properties;
    },
    forEach: function forEach3(fn2) {
      var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var _iterator = _createForOfIteratorHelper(properties), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values2 = _step$value[1];
          fn2.call(thisArg, values2, key, properties);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    get: function get(key) {
      var item = properties.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has(key) {
      return !!ariaPropsMap.get(key);
    },
    keys: function keys3() {
      return properties.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return properties.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
  exports.default = _default;
});
unwrapExports(ariaPropsMap_1);
var domMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i) {
    var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i2 == null)
      return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _s2, _e2;
    try {
      for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
        _arr.push(_s2.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i2["return"] != null)
          _i2["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it3 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it3) {
      if (Array.isArray(o) || (it3 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it3)
          o = it3;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it3 = it3.call(o);
    }, n: function n() {
      var step = it3.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it3.return != null)
          it3.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var dom = [["a", {
    reserved: false
  }], ["abbr", {
    reserved: false
  }], ["acronym", {
    reserved: false
  }], ["address", {
    reserved: false
  }], ["applet", {
    reserved: false
  }], ["area", {
    reserved: false
  }], ["article", {
    reserved: false
  }], ["aside", {
    reserved: false
  }], ["audio", {
    reserved: false
  }], ["b", {
    reserved: false
  }], ["base", {
    reserved: true
  }], ["bdi", {
    reserved: false
  }], ["bdo", {
    reserved: false
  }], ["big", {
    reserved: false
  }], ["blink", {
    reserved: false
  }], ["blockquote", {
    reserved: false
  }], ["body", {
    reserved: false
  }], ["br", {
    reserved: false
  }], ["button", {
    reserved: false
  }], ["canvas", {
    reserved: false
  }], ["caption", {
    reserved: false
  }], ["center", {
    reserved: false
  }], ["cite", {
    reserved: false
  }], ["code", {
    reserved: false
  }], ["col", {
    reserved: true
  }], ["colgroup", {
    reserved: true
  }], ["content", {
    reserved: false
  }], ["data", {
    reserved: false
  }], ["datalist", {
    reserved: false
  }], ["dd", {
    reserved: false
  }], ["del", {
    reserved: false
  }], ["details", {
    reserved: false
  }], ["dfn", {
    reserved: false
  }], ["dialog", {
    reserved: false
  }], ["dir", {
    reserved: false
  }], ["div", {
    reserved: false
  }], ["dl", {
    reserved: false
  }], ["dt", {
    reserved: false
  }], ["em", {
    reserved: false
  }], ["embed", {
    reserved: false
  }], ["fieldset", {
    reserved: false
  }], ["figcaption", {
    reserved: false
  }], ["figure", {
    reserved: false
  }], ["font", {
    reserved: false
  }], ["footer", {
    reserved: false
  }], ["form", {
    reserved: false
  }], ["frame", {
    reserved: false
  }], ["frameset", {
    reserved: false
  }], ["h1", {
    reserved: false
  }], ["h2", {
    reserved: false
  }], ["h3", {
    reserved: false
  }], ["h4", {
    reserved: false
  }], ["h5", {
    reserved: false
  }], ["h6", {
    reserved: false
  }], ["head", {
    reserved: true
  }], ["header", {
    reserved: false
  }], ["hgroup", {
    reserved: false
  }], ["hr", {
    reserved: false
  }], ["html", {
    reserved: true
  }], ["i", {
    reserved: false
  }], ["iframe", {
    reserved: false
  }], ["img", {
    reserved: false
  }], ["input", {
    reserved: false
  }], ["ins", {
    reserved: false
  }], ["kbd", {
    reserved: false
  }], ["keygen", {
    reserved: false
  }], ["label", {
    reserved: false
  }], ["legend", {
    reserved: false
  }], ["li", {
    reserved: false
  }], ["link", {
    reserved: true
  }], ["main", {
    reserved: false
  }], ["map", {
    reserved: false
  }], ["mark", {
    reserved: false
  }], ["marquee", {
    reserved: false
  }], ["menu", {
    reserved: false
  }], ["menuitem", {
    reserved: false
  }], ["meta", {
    reserved: true
  }], ["meter", {
    reserved: false
  }], ["nav", {
    reserved: false
  }], ["noembed", {
    reserved: true
  }], ["noscript", {
    reserved: true
  }], ["object", {
    reserved: false
  }], ["ol", {
    reserved: false
  }], ["optgroup", {
    reserved: false
  }], ["option", {
    reserved: false
  }], ["output", {
    reserved: false
  }], ["p", {
    reserved: false
  }], ["param", {
    reserved: true
  }], ["picture", {
    reserved: true
  }], ["pre", {
    reserved: false
  }], ["progress", {
    reserved: false
  }], ["q", {
    reserved: false
  }], ["rp", {
    reserved: false
  }], ["rt", {
    reserved: false
  }], ["rtc", {
    reserved: false
  }], ["ruby", {
    reserved: false
  }], ["s", {
    reserved: false
  }], ["samp", {
    reserved: false
  }], ["script", {
    reserved: true
  }], ["section", {
    reserved: false
  }], ["select", {
    reserved: false
  }], ["small", {
    reserved: false
  }], ["source", {
    reserved: true
  }], ["spacer", {
    reserved: false
  }], ["span", {
    reserved: false
  }], ["strike", {
    reserved: false
  }], ["strong", {
    reserved: false
  }], ["style", {
    reserved: true
  }], ["sub", {
    reserved: false
  }], ["summary", {
    reserved: false
  }], ["sup", {
    reserved: false
  }], ["table", {
    reserved: false
  }], ["tbody", {
    reserved: false
  }], ["td", {
    reserved: false
  }], ["textarea", {
    reserved: false
  }], ["tfoot", {
    reserved: false
  }], ["th", {
    reserved: false
  }], ["thead", {
    reserved: false
  }], ["time", {
    reserved: false
  }], ["title", {
    reserved: true
  }], ["tr", {
    reserved: false
  }], ["track", {
    reserved: true
  }], ["tt", {
    reserved: false
  }], ["u", {
    reserved: false
  }], ["ul", {
    reserved: false
  }], ["var", {
    reserved: false
  }], ["video", {
    reserved: false
  }], ["wbr", {
    reserved: false
  }], ["xmp", {
    reserved: false
  }]];
  var domMap = {
    entries: function entries() {
      return dom;
    },
    forEach: function forEach3(fn2) {
      var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var _iterator = _createForOfIteratorHelper(dom), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values2 = _step$value[1];
          fn2.call(thisArg, values2, key, dom);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    get: function get(key) {
      var item = dom.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has(key) {
      return !!domMap.get(key);
    },
    keys: function keys3() {
      return dom.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return dom.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default = (0, _iterationDecorator.default)(domMap, domMap.entries());
  exports.default = _default;
});
unwrapExports(domMap_1);
var commandRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var commandRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menuitem"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  };
  var _default = commandRole;
  exports.default = _default;
});
unwrapExports(commandRole_1);
var compositeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var compositeRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  };
  var _default = compositeRole;
  exports.default = _default;
});
unwrapExports(compositeRole_1);
var inputRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var inputRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null
    },
    relatedConcepts: [{
      concept: {
        name: "input"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  };
  var _default = inputRole;
  exports.default = _default;
});
unwrapExports(inputRole_1);
var landmarkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var landmarkRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = landmarkRole;
  exports.default = _default;
});
unwrapExports(landmarkRole_1);
var rangeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var rangeRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuemax": null,
      "aria-valuemin": null,
      "aria-valuenow": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default = rangeRole;
  exports.default = _default;
});
unwrapExports(rangeRole_1);
var roletypeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var roletypeRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {
      "aria-atomic": null,
      "aria-busy": null,
      "aria-controls": null,
      "aria-current": null,
      "aria-describedby": null,
      "aria-details": null,
      "aria-dropeffect": null,
      "aria-flowto": null,
      "aria-grabbed": null,
      "aria-hidden": null,
      "aria-keyshortcuts": null,
      "aria-label": null,
      "aria-labelledby": null,
      "aria-live": null,
      "aria-owns": null,
      "aria-relevant": null,
      "aria-roledescription": null
    },
    relatedConcepts: [{
      concept: {
        name: "rel"
      },
      module: "HTML"
    }, {
      concept: {
        name: "role"
      },
      module: "XHTML"
    }, {
      concept: {
        name: "type"
      },
      module: "Dublin Core"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: []
  };
  var _default = roletypeRole;
  exports.default = _default;
});
unwrapExports(roletypeRole_1);
var sectionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var sectionRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "frontmatter"
      },
      module: "DTB"
    }, {
      concept: {
        name: "level"
      },
      module: "DTB"
    }, {
      concept: {
        name: "level"
      },
      module: "SMIL"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default = sectionRole;
  exports.default = _default;
});
unwrapExports(sectionRole_1);
var sectionheadRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var sectionheadRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default = sectionheadRole;
  exports.default = _default;
});
unwrapExports(sectionheadRole_1);
var selectRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var selectRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
  };
  var _default = selectRole;
  exports.default = _default;
});
unwrapExports(selectRole_1);
var structureRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var structureRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  };
  var _default = structureRole;
  exports.default = _default;
});
unwrapExports(structureRole_1);
var widgetRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var widgetRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  };
  var _default = widgetRole;
  exports.default = _default;
});
unwrapExports(widgetRole_1);
var windowRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var windowRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-modal": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  };
  var _default = windowRole;
  exports.default = _default;
});
unwrapExports(windowRole_1);
var ariaAbstractRoles_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _commandRole = _interopRequireDefault(commandRole_1);
  var _compositeRole = _interopRequireDefault(compositeRole_1);
  var _inputRole = _interopRequireDefault(inputRole_1);
  var _landmarkRole = _interopRequireDefault(landmarkRole_1);
  var _rangeRole = _interopRequireDefault(rangeRole_1);
  var _roletypeRole = _interopRequireDefault(roletypeRole_1);
  var _sectionRole = _interopRequireDefault(sectionRole_1);
  var _sectionheadRole = _interopRequireDefault(sectionheadRole_1);
  var _selectRole = _interopRequireDefault(selectRole_1);
  var _structureRole = _interopRequireDefault(structureRole_1);
  var _widgetRole = _interopRequireDefault(widgetRole_1);
  var _windowRole = _interopRequireDefault(windowRole_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
  var _default = ariaAbstractRoles;
  exports.default = _default;
});
unwrapExports(ariaAbstractRoles_1);
var alertRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var alertRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-atomic": "true",
      "aria-live": "assertive"
    },
    relatedConcepts: [{
      concept: {
        name: "alert"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = alertRole;
  exports.default = _default;
});
unwrapExports(alertRole_1);
var alertdialogRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var alertdialogRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "alert"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
  };
  var _default = alertdialogRole;
  exports.default = _default;
});
unwrapExports(alertdialogRole_1);
var applicationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var applicationRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "Device Independence Delivery Unit"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default = applicationRole;
  exports.default = _default;
});
unwrapExports(applicationRole_1);
var articleRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var articleRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "article"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "document"]]
  };
  var _default = articleRole;
  exports.default = _default;
});
unwrapExports(articleRole_1);
var bannerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var bannerRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        constraints: ["direct descendant of document"],
        name: "header"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = bannerRole;
  exports.default = _default;
});
unwrapExports(bannerRole_1);
var blockquoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var blockquoteRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = blockquoteRole;
  exports.default = _default;
});
unwrapExports(blockquoteRole_1);
var buttonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var buttonRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-pressed": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-pressed"
        }, {
          name: "type",
          value: "checkbox"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "aria-expanded",
          value: "false"
        }],
        name: "summary"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "aria-expanded",
          value: "true"
        }],
        constraints: ["direct descendant of details element with the open attribute defined"],
        name: "summary"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "button"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "image"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "reset"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "submit"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "button"
      },
      module: "HTML"
    }, {
      concept: {
        name: "trigger"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  };
  var _default = buttonRole;
  exports.default = _default;
});
unwrapExports(buttonRole_1);
var captionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var captionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: ["figure", "grid", "table"],
    requiredContextRole: ["figure", "grid", "table"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = captionRole;
  exports.default = _default;
});
unwrapExports(captionRole_1);
var cellRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var cellRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-colindex": null,
      "aria-colspan": null,
      "aria-rowindex": null,
      "aria-rowspan": null
    },
    relatedConcepts: [{
      concept: {
        constraints: ["descendant of table"],
        name: "td"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = cellRole;
  exports.default = _default;
});
unwrapExports(cellRole_1);
var checkboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var checkboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "checkbox"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "option"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input"]]
  };
  var _default = checkboxRole;
  exports.default = _default;
});
unwrapExports(checkboxRole_1);
var codeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var codeRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = codeRole;
  exports.default = _default;
});
unwrapExports(codeRole_1);
var columnheaderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var columnheaderRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-sort": null
    },
    relatedConcepts: [{
      attributes: [{
        name: "scope",
        value: "col"
      }],
      concept: {
        name: "th"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
  };
  var _default = columnheaderRole;
  exports.default = _default;
});
unwrapExports(columnheaderRole_1);
var comboboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var comboboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-autocomplete": null,
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-expanded": "false",
      "aria-haspopup": "listbox"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "email"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "search"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "tel"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "text"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "multiple"
        }, {
          constraints: ["undefined"],
          name: "size"
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "multiple"
        }, {
          name: "size",
          value: 1
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-controls": null,
      "aria-expanded": "false"
    },
    superClass: [["roletype", "widget", "input"]]
  };
  var _default = comboboxRole;
  exports.default = _default;
});
unwrapExports(comboboxRole_1);
var complementaryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var complementaryRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "aside"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = complementaryRole;
  exports.default = _default;
});
unwrapExports(complementaryRole_1);
var contentinfoRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var contentinfoRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        constraints: ["direct descendant of document"],
        name: "footer"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = contentinfoRole;
  exports.default = _default;
});
unwrapExports(contentinfoRole_1);
var definitionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var definitionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dd"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = definitionRole;
  exports.default = _default;
});
unwrapExports(definitionRole_1);
var deletionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var deletionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = deletionRole;
  exports.default = _default;
});
unwrapExports(deletionRole_1);
var dialogRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var dialogRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dialog"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "window"]]
  };
  var _default = dialogRole;
  exports.default = _default;
});
unwrapExports(dialogRole_1);
var directoryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var directoryRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      module: "DAISY Guide"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "list"]]
  };
  var _default = directoryRole;
  exports.default = _default;
});
unwrapExports(directoryRole_1);
var documentRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var documentRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "Device Independence Delivery Unit"
      }
    }, {
      concept: {
        name: "body"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default = documentRole;
  exports.default = _default;
});
unwrapExports(documentRole_1);
var emphasisRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var emphasisRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = emphasisRole;
  exports.default = _default;
});
unwrapExports(emphasisRole_1);
var feedRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var feedRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["article"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "list"]]
  };
  var _default = feedRole;
  exports.default = _default;
});
unwrapExports(feedRole_1);
var figureRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var figureRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "figure"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = figureRole;
  exports.default = _default;
});
unwrapExports(figureRole_1);
var formRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var formRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-label"
        }],
        name: "form"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-labelledby"
        }],
        name: "form"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "name"
        }],
        name: "form"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = formRole;
  exports.default = _default;
});
unwrapExports(formRole_1);
var genericRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var genericRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "span"
      },
      module: "HTML"
    }, {
      concept: {
        name: "div"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default = genericRole;
  exports.default = _default;
});
unwrapExports(genericRole_1);
var gridRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var gridRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-multiselectable": null,
      "aria-readonly": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "role",
          value: "grid"
        }],
        name: "table"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
  };
  var _default = gridRole;
  exports.default = _default;
});
unwrapExports(gridRole_1);
var gridcellRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var gridcellRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-selected": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "role",
          value: "gridcell"
        }],
        name: "td"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
  };
  var _default = gridcellRole;
  exports.default = _default;
});
unwrapExports(gridcellRole_1);
var groupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var groupRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null
    },
    relatedConcepts: [{
      concept: {
        name: "details"
      },
      module: "HTML"
    }, {
      concept: {
        name: "fieldset"
      },
      module: "HTML"
    }, {
      concept: {
        name: "optgroup"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = groupRole;
  exports.default = _default;
});
unwrapExports(groupRole_1);
var headingRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var headingRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-level": "2"
    },
    relatedConcepts: [{
      concept: {
        name: "h1"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h2"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h3"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h4"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h5"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h6"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-level": "2"
    },
    superClass: [["roletype", "structure", "sectionhead"]]
  };
  var _default = headingRole;
  exports.default = _default;
});
unwrapExports(headingRole_1);
var imgRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var imgRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "alt"
        }],
        name: "img"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "alt"
        }],
        name: "img"
      },
      module: "HTML"
    }, {
      concept: {
        name: "imggroup"
      },
      module: "DTB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = imgRole;
  exports.default = _default;
});
unwrapExports(imgRole_1);
var insertionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var insertionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = insertionRole;
  exports.default = _default;
});
unwrapExports(insertionRole_1);
var linkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var linkRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "href"
        }],
        name: "a"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "href"
        }],
        name: "area"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "href"
        }],
        name: "link"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  };
  var _default = linkRole;
  exports.default = _default;
});
unwrapExports(linkRole_1);
var listRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var listRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menu"
      },
      module: "HTML"
    }, {
      concept: {
        name: "ol"
      },
      module: "HTML"
    }, {
      concept: {
        name: "ul"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["listitem"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = listRole;
  exports.default = _default;
});
unwrapExports(listRole_1);
var listboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var listboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-invalid": null,
      "aria-multiselectable": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-orientation": "vertical"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: [">1"],
          name: "size"
        }, {
          name: "multiple"
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: [">1"],
          name: "size"
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "multiple"
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        name: "datalist"
      },
      module: "HTML"
    }, {
      concept: {
        name: "list"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["option", "group"], ["option"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  };
  var _default = listboxRole;
  exports.default = _default;
});
unwrapExports(listboxRole_1);
var listitemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var listitemRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-level": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        constraints: ["direct descendant of ol, ul or menu"],
        name: "li"
      },
      module: "HTML"
    }, {
      concept: {
        name: "item"
      },
      module: "XForms"
    }],
    requireContextRole: ["directory", "list"],
    requiredContextRole: ["directory", "list"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = listitemRole;
  exports.default = _default;
});
unwrapExports(listitemRole_1);
var logRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var logRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-live": "polite"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = logRole;
  exports.default = _default;
});
unwrapExports(logRole_1);
var mainRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var mainRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "main"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = mainRole;
  exports.default = _default;
});
unwrapExports(mainRole_1);
var marqueeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var marqueeRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = marqueeRole;
  exports.default = _default;
});
unwrapExports(marqueeRole_1);
var mathRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var mathRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "math"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = mathRole;
  exports.default = _default;
});
unwrapExports(mathRole_1);
var menuRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var menuRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "vertical"
    },
    relatedConcepts: [{
      concept: {
        name: "MENU"
      },
      module: "JAPI"
    }, {
      concept: {
        name: "list"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }, {
      concept: {
        name: "sidebar"
      },
      module: "DTB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  };
  var _default = menuRole;
  exports.default = _default;
});
unwrapExports(menuRole_1);
var menubarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var menubarRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      concept: {
        name: "toolbar"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
  };
  var _default = menubarRole;
  exports.default = _default;
});
unwrapExports(menubarRole_1);
var menuitemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var menuitemRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "MENU_ITEM"
      },
      module: "JAPI"
    }, {
      concept: {
        name: "listitem"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "menuitem"
      },
      module: "HTML"
    }, {
      concept: {
        name: "option"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  };
  var _default = menuitemRole;
  exports.default = _default;
});
unwrapExports(menuitemRole_1);
var menuitemcheckboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var menuitemcheckboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menuitem"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
  };
  var _default = menuitemcheckboxRole;
  exports.default = _default;
});
unwrapExports(menuitemcheckboxRole_1);
var menuitemradioRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var menuitemradioRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menuitem"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
  };
  var _default = menuitemradioRole;
  exports.default = _default;
});
unwrapExports(menuitemradioRole_1);
var meterRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var meterRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuetext": null,
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-valuenow": null
    },
    superClass: [["roletype", "structure", "range"]]
  };
  var _default = meterRole;
  exports.default = _default;
});
unwrapExports(meterRole_1);
var navigationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var navigationRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "nav"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = navigationRole;
  exports.default = _default;
});
unwrapExports(navigationRole_1);
var noneRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var noneRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: []
  };
  var _default = noneRole;
  exports.default = _default;
});
unwrapExports(noneRole_1);
var noteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var noteRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = noteRole;
  exports.default = _default;
});
unwrapExports(noteRole_1);
var optionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var optionRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-posinset": null,
      "aria-setsize": null,
      "aria-selected": "false"
    },
    relatedConcepts: [{
      concept: {
        name: "item"
      },
      module: "XForms"
    }, {
      concept: {
        name: "listitem"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "option"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-selected": "false"
    },
    superClass: [["roletype", "widget", "input"]]
  };
  var _default = optionRole;
  exports.default = _default;
});
unwrapExports(optionRole_1);
var paragraphRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var paragraphRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = paragraphRole;
  exports.default = _default;
});
unwrapExports(paragraphRole_1);
var presentationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var presentationRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default = presentationRole;
  exports.default = _default;
});
unwrapExports(presentationRole_1);
var progressbarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var progressbarRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuetext": null
    },
    relatedConcepts: [{
      concept: {
        name: "progress"
      },
      module: "HTML"
    }, {
      concept: {
        name: "status"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
  };
  var _default = progressbarRole;
  exports.default = _default;
});
unwrapExports(progressbarRole_1);
var radioRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var radioRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "radio"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input"]]
  };
  var _default = radioRole;
  exports.default = _default;
});
unwrapExports(radioRole_1);
var radiogroupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var radiogroupRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        name: "list"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["radio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  };
  var _default = radiogroupRole;
  exports.default = _default;
});
unwrapExports(radiogroupRole_1);
var regionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var regionRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-label"
        }],
        name: "section"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-labelledby"
        }],
        name: "section"
      },
      module: "HTML"
    }, {
      concept: {
        name: "Device Independence Glossart perceivable unit"
      }
    }, {
      concept: {
        name: "frame"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = regionRole;
  exports.default = _default;
});
unwrapExports(regionRole_1);
var rowRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var rowRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-colindex": null,
      "aria-expanded": null,
      "aria-level": null,
      "aria-posinset": null,
      "aria-rowindex": null,
      "aria-selected": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "tr"
      },
      module: "HTML"
    }],
    requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
    requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
    requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
  };
  var _default = rowRole;
  exports.default = _default;
});
unwrapExports(rowRole_1);
var rowgroupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var rowgroupRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "tbody"
      },
      module: "HTML"
    }, {
      concept: {
        name: "tfoot"
      },
      module: "HTML"
    }, {
      concept: {
        name: "thead"
      },
      module: "HTML"
    }],
    requireContextRole: ["grid", "table", "treegrid"],
    requiredContextRole: ["grid", "table", "treegrid"],
    requiredOwnedElements: [["row"]],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default = rowgroupRole;
  exports.default = _default;
});
unwrapExports(rowgroupRole_1);
var rowheaderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var rowheaderRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-sort": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "scope",
          value: "row"
        }],
        name: "th"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "scope",
          value: "rowgroup"
        }],
        name: "th"
      },
      module: "HTML"
    }],
    requireContextRole: ["row", "rowgroup"],
    requiredContextRole: ["row", "rowgroup"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
  };
  var _default = rowheaderRole;
  exports.default = _default;
});
unwrapExports(rowheaderRole_1);
var scrollbarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var scrollbarRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-valuetext": null,
      "aria-orientation": "vertical",
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-controls": null,
      "aria-valuenow": null
    },
    superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
  };
  var _default = scrollbarRole;
  exports.default = _default;
});
unwrapExports(scrollbarRole_1);
var searchRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var searchRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = searchRole;
  exports.default = _default;
});
unwrapExports(searchRole_1);
var searchboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var searchboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "search"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "input", "textbox"]]
  };
  var _default = searchboxRole;
  exports.default = _default;
});
unwrapExports(searchboxRole_1);
var separatorRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var separatorRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-orientation": "horizontal",
      "aria-valuemax": "100",
      "aria-valuemin": "0",
      "aria-valuenow": null,
      "aria-valuetext": null
    },
    relatedConcepts: [{
      concept: {
        name: "hr"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default = separatorRole;
  exports.default = _default;
});
unwrapExports(separatorRole_1);
var sliderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var sliderRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-valuetext": null,
      "aria-orientation": "horizontal",
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "range"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-valuenow": null
    },
    superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
  };
  var _default = sliderRole;
  exports.default = _default;
});
unwrapExports(sliderRole_1);
var spinbuttonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var spinbuttonRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-valuetext": null,
      "aria-valuenow": "0"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "number"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
  };
  var _default = spinbuttonRole;
  exports.default = _default;
});
unwrapExports(spinbuttonRole_1);
var statusRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var statusRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-atomic": "true",
      "aria-live": "polite"
    },
    relatedConcepts: [{
      concept: {
        name: "output"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = statusRole;
  exports.default = _default;
});
unwrapExports(statusRole_1);
var strongRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var strongRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = strongRole;
  exports.default = _default;
});
unwrapExports(strongRole_1);
var subscriptRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var subscriptRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = subscriptRole;
  exports.default = _default;
});
unwrapExports(subscriptRole_1);
var superscriptRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var superscriptRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = superscriptRole;
  exports.default = _default;
});
unwrapExports(superscriptRole_1);
var switchRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var switchRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "button"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox"]]
  };
  var _default = switchRole;
  exports.default = _default;
});
unwrapExports(switchRole_1);
var tabRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var tabRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-posinset": null,
      "aria-setsize": null,
      "aria-selected": "false"
    },
    relatedConcepts: [],
    requireContextRole: ["tablist"],
    requiredContextRole: ["tablist"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
  };
  var _default = tabRole;
  exports.default = _default;
});
unwrapExports(tabRole_1);
var tableRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var tableRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-colcount": null,
      "aria-rowcount": null
    },
    relatedConcepts: [{
      concept: {
        name: "table"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = tableRole;
  exports.default = _default;
});
unwrapExports(tableRole_1);
var tablistRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var tablistRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-level": null,
      "aria-multiselectable": null,
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      module: "DAISY",
      concept: {
        name: "guide"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["tab"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"]]
  };
  var _default = tablistRole;
  exports.default = _default;
});
unwrapExports(tablistRole_1);
var tabpanelRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var tabpanelRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = tabpanelRole;
  exports.default = _default;
});
unwrapExports(tabpanelRole_1);
var termRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var termRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dfn"
      },
      module: "HTML"
    }, {
      concept: {
        name: "dt"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = termRole;
  exports.default = _default;
});
unwrapExports(termRole_1);
var textboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var textboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-autocomplete": null,
      "aria-errormessage": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-multiline": null,
      "aria-placeholder": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "type"
        }, {
          constraints: ["undefined"],
          name: "list"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "email"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "tel"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "text"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "input"
      },
      module: "XForms"
    }, {
      concept: {
        name: "textarea"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "input"]]
  };
  var _default = textboxRole;
  exports.default = _default;
});
unwrapExports(textboxRole_1);
var timeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var timeRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = timeRole;
  exports.default = _default;
});
unwrapExports(timeRole_1);
var timerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var timerRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "status"]]
  };
  var _default = timerRole;
  exports.default = _default;
});
unwrapExports(timerRole_1);
var toolbarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var toolbarRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      concept: {
        name: "menubar"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"]]
  };
  var _default = toolbarRole;
  exports.default = _default;
});
unwrapExports(toolbarRole_1);
var tooltipRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var tooltipRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = tooltipRole;
  exports.default = _default;
});
unwrapExports(tooltipRole_1);
var treeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var treeRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-multiselectable": null,
      "aria-required": null,
      "aria-orientation": "vertical"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  };
  var _default = treeRole;
  exports.default = _default;
});
unwrapExports(treeRole_1);
var treegridRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var treegridRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
  };
  var _default = treegridRole;
  exports.default = _default;
});
unwrapExports(treegridRole_1);
var treeitemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var treeitemRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-expanded": null,
      "aria-haspopup": null
    },
    relatedConcepts: [],
    requireContextRole: ["group", "tree"],
    requiredContextRole: ["group", "tree"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-selected": null
    },
    superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
  };
  var _default = treeitemRole;
  exports.default = _default;
});
unwrapExports(treeitemRole_1);
var ariaLiteralRoles_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _alertRole = _interopRequireDefault(alertRole_1);
  var _alertdialogRole = _interopRequireDefault(alertdialogRole_1);
  var _applicationRole = _interopRequireDefault(applicationRole_1);
  var _articleRole = _interopRequireDefault(articleRole_1);
  var _bannerRole = _interopRequireDefault(bannerRole_1);
  var _blockquoteRole = _interopRequireDefault(blockquoteRole_1);
  var _buttonRole = _interopRequireDefault(buttonRole_1);
  var _captionRole = _interopRequireDefault(captionRole_1);
  var _cellRole = _interopRequireDefault(cellRole_1);
  var _checkboxRole = _interopRequireDefault(checkboxRole_1);
  var _codeRole = _interopRequireDefault(codeRole_1);
  var _columnheaderRole = _interopRequireDefault(columnheaderRole_1);
  var _comboboxRole = _interopRequireDefault(comboboxRole_1);
  var _complementaryRole = _interopRequireDefault(complementaryRole_1);
  var _contentinfoRole = _interopRequireDefault(contentinfoRole_1);
  var _definitionRole = _interopRequireDefault(definitionRole_1);
  var _deletionRole = _interopRequireDefault(deletionRole_1);
  var _dialogRole = _interopRequireDefault(dialogRole_1);
  var _directoryRole = _interopRequireDefault(directoryRole_1);
  var _documentRole = _interopRequireDefault(documentRole_1);
  var _emphasisRole = _interopRequireDefault(emphasisRole_1);
  var _feedRole = _interopRequireDefault(feedRole_1);
  var _figureRole = _interopRequireDefault(figureRole_1);
  var _formRole = _interopRequireDefault(formRole_1);
  var _genericRole = _interopRequireDefault(genericRole_1);
  var _gridRole = _interopRequireDefault(gridRole_1);
  var _gridcellRole = _interopRequireDefault(gridcellRole_1);
  var _groupRole = _interopRequireDefault(groupRole_1);
  var _headingRole = _interopRequireDefault(headingRole_1);
  var _imgRole = _interopRequireDefault(imgRole_1);
  var _insertionRole = _interopRequireDefault(insertionRole_1);
  var _linkRole = _interopRequireDefault(linkRole_1);
  var _listRole = _interopRequireDefault(listRole_1);
  var _listboxRole = _interopRequireDefault(listboxRole_1);
  var _listitemRole = _interopRequireDefault(listitemRole_1);
  var _logRole = _interopRequireDefault(logRole_1);
  var _mainRole = _interopRequireDefault(mainRole_1);
  var _marqueeRole = _interopRequireDefault(marqueeRole_1);
  var _mathRole = _interopRequireDefault(mathRole_1);
  var _menuRole = _interopRequireDefault(menuRole_1);
  var _menubarRole = _interopRequireDefault(menubarRole_1);
  var _menuitemRole = _interopRequireDefault(menuitemRole_1);
  var _menuitemcheckboxRole = _interopRequireDefault(menuitemcheckboxRole_1);
  var _menuitemradioRole = _interopRequireDefault(menuitemradioRole_1);
  var _meterRole = _interopRequireDefault(meterRole_1);
  var _navigationRole = _interopRequireDefault(navigationRole_1);
  var _noneRole = _interopRequireDefault(noneRole_1);
  var _noteRole = _interopRequireDefault(noteRole_1);
  var _optionRole = _interopRequireDefault(optionRole_1);
  var _paragraphRole = _interopRequireDefault(paragraphRole_1);
  var _presentationRole = _interopRequireDefault(presentationRole_1);
  var _progressbarRole = _interopRequireDefault(progressbarRole_1);
  var _radioRole = _interopRequireDefault(radioRole_1);
  var _radiogroupRole = _interopRequireDefault(radiogroupRole_1);
  var _regionRole = _interopRequireDefault(regionRole_1);
  var _rowRole = _interopRequireDefault(rowRole_1);
  var _rowgroupRole = _interopRequireDefault(rowgroupRole_1);
  var _rowheaderRole = _interopRequireDefault(rowheaderRole_1);
  var _scrollbarRole = _interopRequireDefault(scrollbarRole_1);
  var _searchRole = _interopRequireDefault(searchRole_1);
  var _searchboxRole = _interopRequireDefault(searchboxRole_1);
  var _separatorRole = _interopRequireDefault(separatorRole_1);
  var _sliderRole = _interopRequireDefault(sliderRole_1);
  var _spinbuttonRole = _interopRequireDefault(spinbuttonRole_1);
  var _statusRole = _interopRequireDefault(statusRole_1);
  var _strongRole = _interopRequireDefault(strongRole_1);
  var _subscriptRole = _interopRequireDefault(subscriptRole_1);
  var _superscriptRole = _interopRequireDefault(superscriptRole_1);
  var _switchRole = _interopRequireDefault(switchRole_1);
  var _tabRole = _interopRequireDefault(tabRole_1);
  var _tableRole = _interopRequireDefault(tableRole_1);
  var _tablistRole = _interopRequireDefault(tablistRole_1);
  var _tabpanelRole = _interopRequireDefault(tabpanelRole_1);
  var _termRole = _interopRequireDefault(termRole_1);
  var _textboxRole = _interopRequireDefault(textboxRole_1);
  var _timeRole = _interopRequireDefault(timeRole_1);
  var _timerRole = _interopRequireDefault(timerRole_1);
  var _toolbarRole = _interopRequireDefault(toolbarRole_1);
  var _tooltipRole = _interopRequireDefault(tooltipRole_1);
  var _treeRole = _interopRequireDefault(treeRole_1);
  var _treegridRole = _interopRequireDefault(treegridRole_1);
  var _treeitemRole = _interopRequireDefault(treeitemRole_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
  var _default = ariaLiteralRoles;
  exports.default = _default;
});
unwrapExports(ariaLiteralRoles_1);
var docAbstractRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docAbstractRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "abstract [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = docAbstractRole;
  exports.default = _default;
});
unwrapExports(docAbstractRole_1);
var docAcknowledgmentsRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docAcknowledgmentsRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "acknowledgments [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docAcknowledgmentsRole;
  exports.default = _default;
});
unwrapExports(docAcknowledgmentsRole_1);
var docAfterwordRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docAfterwordRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "afterword [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docAfterwordRole;
  exports.default = _default;
});
unwrapExports(docAfterwordRole_1);
var docAppendixRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docAppendixRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "appendix [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docAppendixRole;
  exports.default = _default;
});
unwrapExports(docAppendixRole_1);
var docBacklinkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docBacklinkRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "content"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "referrer [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  };
  var _default = docBacklinkRole;
  exports.default = _default;
});
unwrapExports(docBacklinkRole_1);
var docBiblioentryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docBiblioentryRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "EPUB biblioentry [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: ["doc-bibliography"],
    requiredContextRole: ["doc-bibliography"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "listitem"]]
  };
  var _default = docBiblioentryRole;
  exports.default = _default;
});
unwrapExports(docBiblioentryRole_1);
var docBibliographyRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docBibliographyRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "bibliography [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["doc-biblioentry"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docBibliographyRole;
  exports.default = _default;
});
unwrapExports(docBibliographyRole_1);
var docBibliorefRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docBibliorefRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "biblioref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  };
  var _default = docBibliorefRole;
  exports.default = _default;
});
unwrapExports(docBibliorefRole_1);
var docChapterRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docChapterRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "chapter [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docChapterRole;
  exports.default = _default;
});
unwrapExports(docChapterRole_1);
var docColophonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docColophonRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "colophon [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = docColophonRole;
  exports.default = _default;
});
unwrapExports(docColophonRole_1);
var docConclusionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docConclusionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "conclusion [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docConclusionRole;
  exports.default = _default;
});
unwrapExports(docConclusionRole_1);
var docCoverRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docCoverRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "cover [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "img"]]
  };
  var _default = docCoverRole;
  exports.default = _default;
});
unwrapExports(docCoverRole_1);
var docCreditRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docCreditRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "credit [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = docCreditRole;
  exports.default = _default;
});
unwrapExports(docCreditRole_1);
var docCreditsRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docCreditsRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "credits [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docCreditsRole;
  exports.default = _default;
});
unwrapExports(docCreditsRole_1);
var docDedicationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docDedicationRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "dedication [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = docDedicationRole;
  exports.default = _default;
});
unwrapExports(docDedicationRole_1);
var docEndnoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docEndnoteRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "rearnote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: ["doc-endnotes"],
    requiredContextRole: ["doc-endnotes"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "listitem"]]
  };
  var _default = docEndnoteRole;
  exports.default = _default;
});
unwrapExports(docEndnoteRole_1);
var docEndnotesRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docEndnotesRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "rearnotes [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["doc-endnote"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docEndnotesRole;
  exports.default = _default;
});
unwrapExports(docEndnotesRole_1);
var docEpigraphRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docEpigraphRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "epigraph [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = docEpigraphRole;
  exports.default = _default;
});
unwrapExports(docEpigraphRole_1);
var docEpilogueRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docEpilogueRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "epilogue [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docEpilogueRole;
  exports.default = _default;
});
unwrapExports(docEpilogueRole_1);
var docErrataRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docErrataRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "errata [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docErrataRole;
  exports.default = _default;
});
unwrapExports(docErrataRole_1);
var docExampleRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docExampleRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = docExampleRole;
  exports.default = _default;
});
unwrapExports(docExampleRole_1);
var docFootnoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docFootnoteRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "footnote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = docFootnoteRole;
  exports.default = _default;
});
unwrapExports(docFootnoteRole_1);
var docForewordRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docForewordRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "foreword [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docForewordRole;
  exports.default = _default;
});
unwrapExports(docForewordRole_1);
var docGlossaryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docGlossaryRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "glossary [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["definition"], ["term"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docGlossaryRole;
  exports.default = _default;
});
unwrapExports(docGlossaryRole_1);
var docGlossrefRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docGlossrefRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "glossref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  };
  var _default = docGlossrefRole;
  exports.default = _default;
});
unwrapExports(docGlossrefRole_1);
var docIndexRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docIndexRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "index [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  };
  var _default = docIndexRole;
  exports.default = _default;
});
unwrapExports(docIndexRole_1);
var docIntroductionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docIntroductionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "introduction [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docIntroductionRole;
  exports.default = _default;
});
unwrapExports(docIntroductionRole_1);
var docNoterefRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docNoterefRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "noteref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  };
  var _default = docNoterefRole;
  exports.default = _default;
});
unwrapExports(docNoterefRole_1);
var docNoticeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docNoticeRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "notice [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "note"]]
  };
  var _default = docNoticeRole;
  exports.default = _default;
});
unwrapExports(docNoticeRole_1);
var docPagebreakRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPagebreakRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "pagebreak [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "separator"]]
  };
  var _default = docPagebreakRole;
  exports.default = _default;
});
unwrapExports(docPagebreakRole_1);
var docPagelistRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPagelistRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "page-list [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  };
  var _default = docPagelistRole;
  exports.default = _default;
});
unwrapExports(docPagelistRole_1);
var docPartRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPartRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "part [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docPartRole;
  exports.default = _default;
});
unwrapExports(docPartRole_1);
var docPrefaceRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPrefaceRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "preface [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docPrefaceRole;
  exports.default = _default;
});
unwrapExports(docPrefaceRole_1);
var docPrologueRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPrologueRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "prologue [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default = docPrologueRole;
  exports.default = _default;
});
unwrapExports(docPrologueRole_1);
var docPullquoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPullquoteRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "pullquote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["none"]]
  };
  var _default = docPullquoteRole;
  exports.default = _default;
});
unwrapExports(docPullquoteRole_1);
var docQnaRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docQnaRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "qna [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default = docQnaRole;
  exports.default = _default;
});
unwrapExports(docQnaRole_1);
var docSubtitleRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docSubtitleRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "subtitle [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "sectionhead"]]
  };
  var _default = docSubtitleRole;
  exports.default = _default;
});
unwrapExports(docSubtitleRole_1);
var docTipRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docTipRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "help [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "note"]]
  };
  var _default = docTipRole;
  exports.default = _default;
});
unwrapExports(docTipRole_1);
var docTocRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docTocRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "toc [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  };
  var _default = docTocRole;
  exports.default = _default;
});
unwrapExports(docTocRole_1);
var ariaDpubRoles_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _docAbstractRole = _interopRequireDefault(docAbstractRole_1);
  var _docAcknowledgmentsRole = _interopRequireDefault(docAcknowledgmentsRole_1);
  var _docAfterwordRole = _interopRequireDefault(docAfterwordRole_1);
  var _docAppendixRole = _interopRequireDefault(docAppendixRole_1);
  var _docBacklinkRole = _interopRequireDefault(docBacklinkRole_1);
  var _docBiblioentryRole = _interopRequireDefault(docBiblioentryRole_1);
  var _docBibliographyRole = _interopRequireDefault(docBibliographyRole_1);
  var _docBibliorefRole = _interopRequireDefault(docBibliorefRole_1);
  var _docChapterRole = _interopRequireDefault(docChapterRole_1);
  var _docColophonRole = _interopRequireDefault(docColophonRole_1);
  var _docConclusionRole = _interopRequireDefault(docConclusionRole_1);
  var _docCoverRole = _interopRequireDefault(docCoverRole_1);
  var _docCreditRole = _interopRequireDefault(docCreditRole_1);
  var _docCreditsRole = _interopRequireDefault(docCreditsRole_1);
  var _docDedicationRole = _interopRequireDefault(docDedicationRole_1);
  var _docEndnoteRole = _interopRequireDefault(docEndnoteRole_1);
  var _docEndnotesRole = _interopRequireDefault(docEndnotesRole_1);
  var _docEpigraphRole = _interopRequireDefault(docEpigraphRole_1);
  var _docEpilogueRole = _interopRequireDefault(docEpilogueRole_1);
  var _docErrataRole = _interopRequireDefault(docErrataRole_1);
  var _docExampleRole = _interopRequireDefault(docExampleRole_1);
  var _docFootnoteRole = _interopRequireDefault(docFootnoteRole_1);
  var _docForewordRole = _interopRequireDefault(docForewordRole_1);
  var _docGlossaryRole = _interopRequireDefault(docGlossaryRole_1);
  var _docGlossrefRole = _interopRequireDefault(docGlossrefRole_1);
  var _docIndexRole = _interopRequireDefault(docIndexRole_1);
  var _docIntroductionRole = _interopRequireDefault(docIntroductionRole_1);
  var _docNoterefRole = _interopRequireDefault(docNoterefRole_1);
  var _docNoticeRole = _interopRequireDefault(docNoticeRole_1);
  var _docPagebreakRole = _interopRequireDefault(docPagebreakRole_1);
  var _docPagelistRole = _interopRequireDefault(docPagelistRole_1);
  var _docPartRole = _interopRequireDefault(docPartRole_1);
  var _docPrefaceRole = _interopRequireDefault(docPrefaceRole_1);
  var _docPrologueRole = _interopRequireDefault(docPrologueRole_1);
  var _docPullquoteRole = _interopRequireDefault(docPullquoteRole_1);
  var _docQnaRole = _interopRequireDefault(docQnaRole_1);
  var _docSubtitleRole = _interopRequireDefault(docSubtitleRole_1);
  var _docTipRole = _interopRequireDefault(docTipRole_1);
  var _docTocRole = _interopRequireDefault(docTocRole_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
  var _default = ariaDpubRoles;
  exports.default = _default;
});
unwrapExports(ariaDpubRoles_1);
var graphicsDocumentRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var graphicsDocumentRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      module: "GRAPHICS",
      concept: {
        name: "graphics-object"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "img"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "article"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "document"]]
  };
  var _default = graphicsDocumentRole;
  exports.default = _default;
});
unwrapExports(graphicsDocumentRole_1);
var graphicsObjectRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var graphicsObjectRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      module: "GRAPHICS",
      concept: {
        name: "graphics-document"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "group"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "img"
      }
    }, {
      module: "GRAPHICS",
      concept: {
        name: "graphics-symbol"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"]]
  };
  var _default = graphicsObjectRole;
  exports.default = _default;
});
unwrapExports(graphicsObjectRole_1);
var graphicsSymbolRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var graphicsSymbolRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "img"]]
  };
  var _default = graphicsSymbolRole;
  exports.default = _default;
});
unwrapExports(graphicsSymbolRole_1);
var ariaGraphicsRoles_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _graphicsDocumentRole = _interopRequireDefault(graphicsDocumentRole_1);
  var _graphicsObjectRole = _interopRequireDefault(graphicsObjectRole_1);
  var _graphicsSymbolRole = _interopRequireDefault(graphicsSymbolRole_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]];
  var _default = ariaGraphicsRoles;
  exports.default = _default;
});
unwrapExports(ariaGraphicsRoles_1);
var rolesMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _ariaAbstractRoles = _interopRequireDefault(ariaAbstractRoles_1);
  var _ariaLiteralRoles = _interopRequireDefault(ariaLiteralRoles_1);
  var _ariaDpubRoles = _interopRequireDefault(ariaDpubRoles_1);
  var _ariaGraphicsRoles = _interopRequireDefault(ariaGraphicsRoles_1);
  var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it3 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it3) {
      if (Array.isArray(o) || (it3 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it3)
          o = it3;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it3 = it3.call(o);
    }, n: function n() {
      var step = it3.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it3.return != null)
          it3.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _iterableToArrayLimit(arr, i) {
    var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i2 == null)
      return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _s2, _e2;
    try {
      for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
        _arr.push(_s2.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i2["return"] != null)
          _i2["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  var roles = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
  roles.forEach(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
    var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var superClassIter = _step.value;
        var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
        try {
          var _loop = function _loop2() {
            var superClassName = _step2.value;
            var superClassRoleTuple = roles.find(function(_ref3) {
              var _ref4 = _slicedToArray(_ref3, 1), name3 = _ref4[0];
              return name3 === superClassName;
            });
            if (superClassRoleTuple) {
              var superClassDefinition = superClassRoleTuple[1];
              for (var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++) {
                var prop2 = _Object$keys[_i2];
                if (
                  // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                  !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop2)
                ) {
                  Object.assign(roleDefinition.props, _defineProperty({}, prop2, superClassDefinition.props[prop2]));
                }
              }
            }
          };
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            _loop();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  });
  var rolesMap = {
    entries: function entries() {
      return roles;
    },
    forEach: function forEach3(fn2) {
      var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var _iterator3 = _createForOfIteratorHelper(roles), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var _step3$value = _slicedToArray(_step3.value, 2), key = _step3$value[0], values2 = _step3$value[1];
          fn2.call(thisArg, values2, key, roles);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    },
    get: function get(key) {
      var item = roles.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has(key) {
      return !!rolesMap.get(key);
    },
    keys: function keys3() {
      return roles.map(function(_ref5) {
        var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
        return key;
      });
    },
    values: function values2() {
      return roles.map(function(_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2), values3 = _ref8[1];
        return values3;
      });
    }
  };
  var _default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
  exports.default = _default;
});
unwrapExports(rolesMap_1);
var toStr = Object.prototype.toString;
var isArguments = function isArguments2(value) {
  var str2 = toStr.call(value);
  var isArgs = str2 === "[object Arguments]";
  if (!isArgs) {
    isArgs = str2 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
  }
  return isArgs;
};
var keysShim;
if (!Object.keys) {
  has = Object.prototype.hasOwnProperty;
  toStr$1 = Object.prototype.toString;
  isArgs = isArguments;
  isEnumerable = Object.prototype.propertyIsEnumerable;
  hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
  hasProtoEnumBug = isEnumerable.call(function() {
  }, "prototype");
  dontEnums = [
    "toString",
    "toLocaleString",
    "valueOf",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "constructor"
  ];
  equalsConstructorPrototype = function(o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };
  excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };
  hasAutomationEqualityBug = function() {
    if (typeof window === "undefined") {
      return false;
    }
    for (var k2 in window) {
      try {
        if (!excludedKeys["$" + k2] && has.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
          try {
            equalsConstructorPrototype(window[k2]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }
    return false;
  }();
  equalsConstructorPrototypeIfNotBuggy = function(o) {
    if (typeof window === "undefined" || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }
    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };
  keysShim = function keys3(object) {
    var isObject2 = object !== null && typeof object === "object";
    var isFunction3 = toStr$1.call(object) === "[object Function]";
    var isArguments5 = isArgs(object);
    var isString3 = isObject2 && toStr$1.call(object) === "[object String]";
    var theKeys = [];
    if (!isObject2 && !isFunction3 && !isArguments5) {
      throw new TypeError("Object.keys called on a non-object");
    }
    var skipProto = hasProtoEnumBug && isFunction3;
    if (isString3 && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }
    if (isArguments5 && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name3 in object) {
        if (!(skipProto && name3 === "prototype") && has.call(object, name3)) {
          theKeys.push(String(name3));
        }
      }
    }
    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
      for (var k2 = 0; k2 < dontEnums.length; ++k2) {
        if (!(skipConstructor && dontEnums[k2] === "constructor") && has.call(object, dontEnums[k2])) {
          theKeys.push(dontEnums[k2]);
        }
      }
    }
    return theKeys;
  };
}
var has;
var toStr$1;
var isArgs;
var isEnumerable;
var hasDontEnumBug;
var hasProtoEnumBug;
var dontEnums;
var equalsConstructorPrototype;
var excludedKeys;
var hasAutomationEqualityBug;
var equalsConstructorPrototypeIfNotBuggy;
var implementation = keysShim;
var slice = Array.prototype.slice;
var origKeys = Object.keys;
var keysShim$1 = origKeys ? function keys(o) {
  return origKeys(o);
} : implementation;
var originalKeys = Object.keys;
keysShim$1.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys3(object) {
        if (isArguments(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim$1;
  }
  return Object.keys || keysShim$1;
};
var objectKeys = keysShim$1;
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var shams$1 = function hasToStringTagShams() {
  return shams() && !!Symbol.toStringTag;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbols2 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return shams();
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice$1 = Array.prototype.slice;
var toStr$2 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind(that) {
  var target2 = this;
  if (typeof target2 !== "function" || toStr$2.call(target2) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target2);
  }
  var args = slice$1.call(arguments, 1);
  var bound2;
  var binder = function() {
    if (this instanceof bound2) {
      var result = target2.apply(
        this,
        args.concat(slice$1.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target2.apply(
        that,
        args.concat(slice$1.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target2.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound2 = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target2.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target2.prototype;
    bound2.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound2;
};
var functionBind = Function.prototype.bind || implementation$1;
var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$1 = hasSymbols2();
var getProto = Object.getPrototypeOf || function(x2) {
  return x2.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name3) {
  var value;
  if (name3 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name3 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name3 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name3 === "%AsyncGenerator%") {
    var fn2 = doEval2("%AsyncGeneratorFunction%");
    if (fn2) {
      value = fn2.prototype;
    }
  } else if (name3 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name3] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var $concat = functionBind.call(Function.call, Array.prototype.concat);
var $spliceApply = functionBind.call(Function.apply, Array.prototype.splice);
var $replace = functionBind.call(Function.call, String.prototype.replace);
var $strSlice = functionBind.call(Function.call, String.prototype.slice);
var $exec = functionBind.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first2 = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first2 === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match, number2, quote2, subString) {
    result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number2 || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name3, allowMissing) {
  var intrinsicName = name3;
  var alias;
  if (src(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (src(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError("intrinsic " + name3 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name3 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name3, allowMissing) {
  if (typeof name3 !== "string" || name3.length === 0) {
    throw new $TypeError("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name3) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name3);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part2 = parts[i];
    var first2 = $strSlice(part2, 0, 1);
    var last = $strSlice(part2, -1);
    if ((first2 === '"' || first2 === "'" || first2 === "`" || (last === '"' || last === "'" || last === "`")) && first2 !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part2 === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part2;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (src(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part2 in value)) {
        if (!allowMissing) {
          throw new $TypeError("base intrinsic for " + name3 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part2);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part2];
        }
      } else {
        isOwn = src(value, part2);
        value = value[part2];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind = createCommonjsModule(function(module) {
  var $apply = getIntrinsic("%Function.prototype.apply%");
  var $call = getIntrinsic("%Function.prototype.call%");
  var $reflectApply = getIntrinsic("%Reflect.apply%", true) || functionBind.call($call, $apply);
  var $gOPD2 = getIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty2 = getIntrinsic("%Object.defineProperty%", true);
  var $max = getIntrinsic("%Math.max%");
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty2 = null;
    }
  }
  module.exports = function callBind2(originalFunction) {
    var func = $reflectApply(functionBind, $call, arguments);
    if ($gOPD2 && $defineProperty2) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty2(
          func,
          "length",
          { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(functionBind, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
});
var callBind_1 = callBind.apply;
var $indexOf = callBind(getIntrinsic("String.prototype.indexOf"));
var callBound = function callBoundIntrinsic(name3, allowMissing) {
  var intrinsic = getIntrinsic(name3, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name3, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
var hasToStringTag = shams$1();
var $toString = callBound("Object.prototype.toString");
var isStandardArguments = function isArguments3(value) {
  if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return $toString(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments4(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var $defineProperty = getIntrinsic("%Object.defineProperty%", true);
var hasPropertyDescriptors = function hasPropertyDescriptors2() {
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
      return true;
    } catch (e) {
      return false;
    }
  }
  return false;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!hasPropertyDescriptors()) {
    return null;
  }
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch (e) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors;
var hasSymbols$2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$3 = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction = function(fn2) {
  return typeof fn2 === "function" && toStr$3.call(fn2) === "[object Function]";
};
var hasPropertyDescriptors$1 = hasPropertyDescriptors_1();
var supportsDescriptors = origDefineProperty && hasPropertyDescriptors$1;
var defineProperty = function(object, name3, value, predicate) {
  if (name3 in object && (!isFunction(predicate) || !predicate())) {
    return;
  }
  if (supportsDescriptors) {
    origDefineProperty(object, name3, {
      configurable: true,
      enumerable: false,
      value,
      writable: true
    });
  } else {
    object[name3] = value;
  }
};
var defineProperties = function(object, map2) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = objectKeys(map2);
  if (hasSymbols$2) {
    props = concat.call(props, Object.getOwnPropertySymbols(map2));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map2[props[i]], predicates[props[i]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
var defineProperties_1 = defineProperties;
var numberIsNaN = function(value) {
  return value !== value;
};
var implementation$2 = function is2(a, b) {
  if (a === 0 && b === 0) {
    return 1 / a === 1 / b;
  }
  if (a === b) {
    return true;
  }
  if (numberIsNaN(a) && numberIsNaN(b)) {
    return true;
  }
  return false;
};
var polyfill = function getPolyfill() {
  return typeof Object.is === "function" ? Object.is : implementation$2;
};
var shim = function shimObjectIs() {
  var polyfill$12 = polyfill();
  defineProperties_1(Object, { is: polyfill$12 }, {
    is: function testObjectIs() {
      return Object.is !== polyfill$12;
    }
  });
  return polyfill$12;
};
var polyfill$1 = callBind(polyfill(), Object);
defineProperties_1(polyfill$1, {
  getPolyfill: polyfill,
  implementation: implementation$2,
  shim
});
var objectIs = polyfill$1;
var hasToStringTag$1 = shams$1();
var has$1;
var $exec$1;
var isRegexMarker;
var badStringifier;
if (hasToStringTag$1) {
  has$1 = callBound("Object.prototype.hasOwnProperty");
  $exec$1 = callBound("RegExp.prototype.exec");
  isRegexMarker = {};
  throwRegexMarker = function() {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === "symbol") {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var throwRegexMarker;
var $toString$1 = callBound("Object.prototype.toString");
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
var isRegex = hasToStringTag$1 ? function isRegex2(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  var descriptor = gOPD(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor && has$1(descriptor, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    $exec$1(value, badStringifier);
  } catch (e) {
    return e === isRegexMarker;
  }
} : function isRegex3(value) {
  if (!value || typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return $toString$1(value) === regexClass;
};
var functionsHaveNames = function functionsHaveNames2() {
  return typeof function f() {
  }.name === "string";
};
var gOPD$1 = Object.getOwnPropertyDescriptor;
if (gOPD$1) {
  try {
    gOPD$1([], "length");
  } catch (e) {
    gOPD$1 = null;
  }
}
functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
  if (!functionsHaveNames() || !gOPD$1) {
    return false;
  }
  var desc = gOPD$1(function() {
  }, "name");
  return !!desc && !!desc.configurable;
};
var $bind = Function.prototype.bind;
functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
  return functionsHaveNames() && typeof $bind === "function" && function f() {
  }.bind().name !== "";
};
var functionsHaveNames_1 = functionsHaveNames;
var implementation$3 = createCommonjsModule(function(module) {
  var functionsHaveConfigurableNames2 = functionsHaveNames_1.functionsHaveConfigurableNames();
  var $Object = Object;
  var $TypeError2 = TypeError;
  module.exports = function flags() {
    if (this != null && this !== $Object(this)) {
      throw new $TypeError2("RegExp.prototype.flags getter called on non-object");
    }
    var result = "";
    if (this.hasIndices) {
      result += "d";
    }
    if (this.global) {
      result += "g";
    }
    if (this.ignoreCase) {
      result += "i";
    }
    if (this.multiline) {
      result += "m";
    }
    if (this.dotAll) {
      result += "s";
    }
    if (this.unicode) {
      result += "u";
    }
    if (this.sticky) {
      result += "y";
    }
    return result;
  };
  if (functionsHaveConfigurableNames2 && Object.defineProperty) {
    Object.defineProperty(module.exports, "name", { value: "get flags" });
  }
});
var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
var $gOPD$1 = Object.getOwnPropertyDescriptor;
var polyfill$2 = function getPolyfill2() {
  if (supportsDescriptors$1 && /a/mig.flags === "gim") {
    var descriptor = $gOPD$1(RegExp.prototype, "flags");
    if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
      var calls = "";
      var o = {};
      Object.defineProperty(o, "hasIndices", {
        get: function() {
          calls += "d";
        }
      });
      Object.defineProperty(o, "sticky", {
        get: function() {
          calls += "y";
        }
      });
      if (calls === "dy") {
        return descriptor.get;
      }
    }
  }
  return implementation$3;
};
var supportsDescriptors$2 = defineProperties_1.supportsDescriptors;
var gOPD$2 = Object.getOwnPropertyDescriptor;
var defineProperty$1 = Object.defineProperty;
var TypeErr = TypeError;
var getProto$1 = Object.getPrototypeOf;
var regex = /a/;
var shim$1 = function shimFlags() {
  if (!supportsDescriptors$2 || !getProto$1) {
    throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  var polyfill2 = polyfill$2();
  var proto2 = getProto$1(regex);
  var descriptor = gOPD$2(proto2, "flags");
  if (!descriptor || descriptor.get !== polyfill2) {
    defineProperty$1(proto2, "flags", {
      configurable: true,
      enumerable: false,
      get: polyfill2
    });
  }
  return polyfill2;
};
var flagsBound = callBind(polyfill$2());
defineProperties_1(flagsBound, {
  getPolyfill: polyfill$2,
  implementation: implementation$3,
  shim: shim$1
});
var regexp_prototype_flags = flagsBound;
var toString$1 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$1.call(arr) == "[object Array]";
};
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$4 = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag$2 = shams$1();
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag$2 ? tryDateObject(value) : toStr$4.call(value) === dateClass;
};
var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject2(value) {
  try {
    strValue.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$5 = Object.prototype.toString;
var strClass = "[object String]";
var hasToStringTag$3 = shams$1();
var isString = function isString2(value) {
  if (typeof value === "string") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$3 ? tryStringObject(value) : toStr$5.call(value) === strClass;
};
var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject2(value) {
  try {
    numToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$6 = Object.prototype.toString;
var numClass = "[object Number]";
var hasToStringTag$4 = shams$1();
var isNumberObject = function isNumberObject2(value) {
  if (typeof value === "number") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$4 ? tryNumberObject(value) : toStr$6.call(value) === numClass;
};
var $boolToStr = callBound("Boolean.prototype.toString");
var $toString$2 = callBound("Object.prototype.toString");
var tryBooleanObject = function booleanBrandCheck(value) {
  try {
    $boolToStr(value);
    return true;
  } catch (e) {
    return false;
  }
};
var boolClass = "[object Boolean]";
var hasToStringTag$5 = shams$1();
var isBooleanObject = function isBoolean(value) {
  if (typeof value === "boolean") {
    return true;
  }
  if (value === null || typeof value !== "object") {
    return false;
  }
  return hasToStringTag$5 && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString$2(value) === boolClass;
};
var isSymbol = createCommonjsModule(function(module) {
  var toStr3 = Object.prototype.toString;
  var hasSymbols$12 = hasSymbols2();
  if (hasSymbols$12) {
    var symToStr = Symbol.prototype.toString;
    var symStringRegex = /^Symbol\(.*\)$/;
    var isSymbolObject = function isRealSymbolObject(value) {
      if (typeof value.valueOf() !== "symbol") {
        return false;
      }
      return symStringRegex.test(symToStr.call(value));
    };
    module.exports = function isSymbol2(value) {
      if (typeof value === "symbol") {
        return true;
      }
      if (toStr3.call(value) !== "[object Symbol]") {
        return false;
      }
      try {
        return isSymbolObject(value);
      } catch (e) {
        return false;
      }
    };
  } else {
    module.exports = function isSymbol2(value) {
      return false;
    };
  }
});
var $BigInt = typeof BigInt !== "undefined" && BigInt;
var hasBigints = function hasNativeBigInts() {
  return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
};
var isBigint = createCommonjsModule(function(module) {
  var hasBigInts = hasBigints();
  if (hasBigInts) {
    var bigIntValueOf2 = BigInt.prototype.valueOf;
    var tryBigInt = function tryBigIntObject(value) {
      try {
        bigIntValueOf2.call(value);
        return true;
      } catch (e) {
      }
      return false;
    };
    module.exports = function isBigInt2(value) {
      if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
        return false;
      }
      if (typeof value === "bigint") {
        return true;
      }
      return tryBigInt(value);
    };
  } else {
    module.exports = function isBigInt2(value) {
      return false;
    };
  }
});
var whichBoxedPrimitive = function whichBoxedPrimitive2(value) {
  if (value == null || typeof value !== "object" && typeof value !== "function") {
    return null;
  }
  if (isString(value)) {
    return "String";
  }
  if (isNumberObject(value)) {
    return "Number";
  }
  if (isBooleanObject(value)) {
    return "Boolean";
  }
  if (isSymbol(value)) {
    return "Symbol";
  }
  if (isBigint(value)) {
    return "BigInt";
  }
};
var $Map = typeof Map === "function" && Map.prototype ? Map : null;
var $Set = typeof Set === "function" && Set.prototype ? Set : null;
var exported;
if (!$Map) {
  exported = function isMap3(x2) {
    return false;
  };
}
var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$mapHas) {
  exported = function isMap3(x2) {
    return false;
  };
}
var isMap = exported || function isMap2(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $mapHas.call(x2);
    if ($setHas) {
      try {
        $setHas.call(x2);
      } catch (e) {
        return true;
      }
    }
    return x2 instanceof $Map;
  } catch (e) {
  }
  return false;
};
var $Map$1 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$1 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$1;
if (!$Set$1) {
  exported$1 = function isSet3(x2) {
    return false;
  };
}
var $mapHas$1 = $Map$1 ? Map.prototype.has : null;
var $setHas$1 = $Set$1 ? Set.prototype.has : null;
if (!exported$1 && !$setHas$1) {
  exported$1 = function isSet3(x2) {
    return false;
  };
}
var isSet = exported$1 || function isSet2(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $setHas$1.call(x2);
    if ($mapHas$1) {
      try {
        $mapHas$1.call(x2);
      } catch (e) {
        return true;
      }
    }
    return x2 instanceof $Set$1;
  } catch (e) {
  }
  return false;
};
var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
var exported$2;
if (!$WeakMap) {
  exported$2 = function isWeakMap3(x2) {
    return false;
  };
}
var $mapHas$2 = $WeakMap ? $WeakMap.prototype.has : null;
var $setHas$2 = $WeakSet ? $WeakSet.prototype.has : null;
if (!exported$2 && !$mapHas$2) {
  exported$2 = function isWeakMap3(x2) {
    return false;
  };
}
var isWeakmap = exported$2 || function isWeakMap(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $mapHas$2.call(x2, $mapHas$2);
    if ($setHas$2) {
      try {
        $setHas$2.call(x2, $setHas$2);
      } catch (e) {
        return true;
      }
    }
    return x2 instanceof $WeakMap;
  } catch (e) {
  }
  return false;
};
var isWeakset = createCommonjsModule(function(module) {
  var $WeakSet2 = getIntrinsic("%WeakSet%", true);
  var $setHas2 = callBound("WeakSet.prototype.has", true);
  if ($setHas2) {
    var $mapHas2 = callBound("WeakMap.prototype.has", true);
    module.exports = function isWeakSet2(x2) {
      if (!x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        $setHas2(x2, $setHas2);
        if ($mapHas2) {
          try {
            $mapHas2(x2, $mapHas2);
          } catch (e) {
            return true;
          }
        }
        return x2 instanceof $WeakSet2;
      } catch (e) {
      }
      return false;
    };
  } else {
    module.exports = function isWeakSet2(x2) {
      return false;
    };
  }
});
var whichCollection = function whichCollection2(value) {
  if (value && typeof value === "object") {
    if (isMap(value)) {
      return "Map";
    }
    if (isSet(value)) {
      return "Set";
    }
    if (isWeakmap(value)) {
      return "WeakMap";
    }
    if (isWeakset(value)) {
      return "WeakSet";
    }
  }
  return false;
};
var $iterator = Symbol.iterator;
function getIterator(iterable) {
  if (iterable != null && iterable[$iterator] !== void 0) {
    return iterable[$iterator]();
  }
}
var node$1 = Object.freeze({
  __proto__: null,
  "default": getIterator
});
var toStr$7 = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag$6 = shams$1();
var getProto$2 = Object.getPrototypeOf;
var getGeneratorFunc = function() {
  if (!hasToStringTag$6) {
    return false;
  }
  try {
    return Function("return function*() {}")();
  } catch (e) {
  }
};
var GeneratorFunction;
var isGeneratorFunction = function isGeneratorFunction2(fn2) {
  if (typeof fn2 !== "function") {
    return false;
  }
  if (isFnRegex.test(fnToStr.call(fn2))) {
    return true;
  }
  if (!hasToStringTag$6) {
    var str2 = toStr$7.call(fn2);
    return str2 === "[object GeneratorFunction]";
  }
  if (!getProto$2) {
    return false;
  }
  if (typeof GeneratorFunction === "undefined") {
    var generatorFunc = getGeneratorFunc();
    GeneratorFunction = generatorFunc ? getProto$2(generatorFunc) : false;
  }
  return getProto$2(fn2) === GeneratorFunction;
};
var fnToStr$1 = Function.prototype.toString;
var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {};
    reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (_2) {
    if (_2 !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr$1.call(value);
    return constructorRegex.test(fnStr);
  } catch (e) {
    return false;
  }
};
var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }
    fnToStr$1.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$8 = Object.prototype.toString;
var objectClass = "[object Object]";
var fnClass = "[object Function]";
var genClass = "[object GeneratorFunction]";
var ddaClass = "[object HTMLAllCollection]";
var ddaClass2 = "[object HTML document.all class]";
var ddaClass3 = "[object HTMLCollection]";
var hasToStringTag$7 = typeof Symbol === "function" && !!Symbol.toStringTag;
var isIE68 = !(0 in [,]);
var isDDA = function isDocumentDotAll() {
  return false;
};
if (typeof document === "object") {
  all2 = document.all;
  if (toStr$8.call(all2) === toStr$8.call(document.all)) {
    isDDA = function isDocumentDotAll2(value) {
      if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
        try {
          var str2 = toStr$8.call(value);
          return (str2 === ddaClass || str2 === ddaClass2 || str2 === ddaClass3 || str2 === objectClass) && value("") == null;
        } catch (e) {
        }
      }
      return false;
    };
  }
}
var all2;
var isCallable = reflectApply ? function isCallable2(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  try {
    reflectApply(value, null, badArrayLike);
  } catch (e) {
    if (e !== isCallableMarker) {
      return false;
    }
  }
  return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable3(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  if (hasToStringTag$7) {
    return tryFunctionObject(value);
  }
  if (isES6ClassFn(value)) {
    return false;
  }
  var strClass2 = toStr$8.call(value);
  if (strClass2 !== fnClass && strClass2 !== genClass && !/^\[object HTML/.test(strClass2)) {
    return false;
  }
  return tryFunctionObject(value);
};
var toStr$9 = Object.prototype.toString;
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray2(array, iterator, receiver) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (hasOwnProperty$2.call(array, i)) {
      if (receiver == null) {
        iterator(array[i], i, array);
      } else {
        iterator.call(receiver, array[i], i, array);
      }
    }
  }
};
var forEachString = function forEachString2(string, iterator, receiver) {
  for (var i = 0, len = string.length; i < len; i++) {
    if (receiver == null) {
      iterator(string.charAt(i), i, string);
    } else {
      iterator.call(receiver, string.charAt(i), i, string);
    }
  }
};
var forEachObject = function forEachObject2(object, iterator, receiver) {
  for (var k2 in object) {
    if (hasOwnProperty$2.call(object, k2)) {
      if (receiver == null) {
        iterator(object[k2], k2, object);
      } else {
        iterator.call(receiver, object[k2], k2, object);
      }
    }
  }
};
var forEach = function forEach2(list2, iterator, thisArg) {
  if (!isCallable(iterator)) {
    throw new TypeError("iterator must be a function");
  }
  var receiver;
  if (arguments.length >= 3) {
    receiver = thisArg;
  }
  if (toStr$9.call(list2) === "[object Array]") {
    forEachArray(list2, iterator, receiver);
  } else if (typeof list2 === "string") {
    forEachString(list2, iterator, receiver);
  } else {
    forEachObject(list2, iterator, receiver);
  }
};
var forEach_1 = forEach;
var possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
];
var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var availableTypedArrays = function availableTypedArrays2() {
  var out = [];
  for (var i = 0; i < possibleNames.length; i++) {
    if (typeof g$1[possibleNames[i]] === "function") {
      out[out.length] = possibleNames[i];
    }
  }
  return out;
};
var $gOPD$2 = getIntrinsic("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD$2) {
  try {
    $gOPD$2([], "length");
  } catch (e) {
    $gOPD$2 = null;
  }
}
var getOwnPropertyDescriptor = $gOPD$2;
var $toString$3 = callBound("Object.prototype.toString");
var hasToStringTag$8 = shams$1();
var g$2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays = availableTypedArrays();
var $indexOf$1 = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
};
var $slice = callBound("String.prototype.slice");
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf;
if (hasToStringTag$8 && getOwnPropertyDescriptor && getPrototypeOf) {
  forEach_1(typedArrays, function(typedArray) {
    var arr = new g$2[typedArray]();
    if (Symbol.toStringTag in arr) {
      var proto2 = getPrototypeOf(arr);
      var descriptor = getOwnPropertyDescriptor(proto2, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf(proto2);
        descriptor = getOwnPropertyDescriptor(superProto, Symbol.toStringTag);
      }
      toStrTags[typedArray] = descriptor.get;
    }
  });
}
var tryTypedArrays = function tryAllTypedArrays(value) {
  var anyTrue = false;
  forEach_1(toStrTags, function(getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value) === typedArray;
      } catch (e) {
      }
    }
  });
  return anyTrue;
};
var isTypedArray = function isTypedArray2(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (!hasToStringTag$8 || !(Symbol.toStringTag in value)) {
    var tag3 = $slice($toString$3(value), 8, -1);
    return $indexOf$1(typedArrays, tag3) > -1;
  }
  if (!getOwnPropertyDescriptor) {
    return false;
  }
  return tryTypedArrays(value);
};
var $toString$4 = callBound("Object.prototype.toString");
var hasToStringTag$9 = shams$1();
var g$3 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays$1 = availableTypedArrays();
var $slice$1 = callBound("String.prototype.slice");
var toStrTags$1 = {};
var getPrototypeOf$1 = Object.getPrototypeOf;
if (hasToStringTag$9 && getOwnPropertyDescriptor && getPrototypeOf$1) {
  forEach_1(typedArrays$1, function(typedArray) {
    if (typeof g$3[typedArray] === "function") {
      var arr = new g$3[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto2 = getPrototypeOf$1(arr);
        var descriptor = getOwnPropertyDescriptor(proto2, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf$1(proto2);
          descriptor = getOwnPropertyDescriptor(superProto, Symbol.toStringTag);
        }
        toStrTags$1[typedArray] = descriptor.get;
      }
    }
  });
}
var tryTypedArrays$1 = function tryAllTypedArrays2(value) {
  var foundName = false;
  forEach_1(toStrTags$1, function(getter, typedArray) {
    if (!foundName) {
      try {
        var name3 = getter.call(value);
        if (name3 === typedArray) {
          foundName = name3;
        }
      } catch (e) {
      }
    }
  });
  return foundName;
};
var whichTypedArray = function whichTypedArray2(value) {
  if (!isTypedArray(value)) {
    return false;
  }
  if (!hasToStringTag$9 || !(Symbol.toStringTag in value)) {
    return $slice$1($toString$4(value), 8, -1);
  }
  return tryTypedArrays$1(value);
};
var types$2 = createCommonjsModule(function(module, exports) {
  function uncurryThis(f) {
    return f.call.bind(f);
  }
  var BigIntSupported = typeof BigInt !== "undefined";
  var SymbolSupported = typeof Symbol !== "undefined";
  var ObjectToString = uncurryThis(Object.prototype.toString);
  var numberValue = uncurryThis(Number.prototype.valueOf);
  var stringValue = uncurryThis(String.prototype.valueOf);
  var booleanValue = uncurryThis(Boolean.prototype.valueOf);
  if (BigIntSupported) {
    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
  }
  if (SymbolSupported) {
    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
  }
  function checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== "object") {
      return false;
    }
    try {
      prototypeValueOf(value);
      return true;
    } catch (e) {
      return false;
    }
  }
  exports.isArgumentsObject = isArguments$1;
  exports.isGeneratorFunction = isGeneratorFunction;
  exports.isTypedArray = isTypedArray;
  function isPromise(input) {
    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
  }
  exports.isPromise = isPromise;
  function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      return ArrayBuffer.isView(value);
    }
    return isTypedArray(value) || isDataView(value);
  }
  exports.isArrayBufferView = isArrayBufferView;
  function isUint8Array(value) {
    return whichTypedArray(value) === "Uint8Array";
  }
  exports.isUint8Array = isUint8Array;
  function isUint8ClampedArray(value) {
    return whichTypedArray(value) === "Uint8ClampedArray";
  }
  exports.isUint8ClampedArray = isUint8ClampedArray;
  function isUint16Array(value) {
    return whichTypedArray(value) === "Uint16Array";
  }
  exports.isUint16Array = isUint16Array;
  function isUint32Array(value) {
    return whichTypedArray(value) === "Uint32Array";
  }
  exports.isUint32Array = isUint32Array;
  function isInt8Array(value) {
    return whichTypedArray(value) === "Int8Array";
  }
  exports.isInt8Array = isInt8Array;
  function isInt16Array(value) {
    return whichTypedArray(value) === "Int16Array";
  }
  exports.isInt16Array = isInt16Array;
  function isInt32Array(value) {
    return whichTypedArray(value) === "Int32Array";
  }
  exports.isInt32Array = isInt32Array;
  function isFloat32Array(value) {
    return whichTypedArray(value) === "Float32Array";
  }
  exports.isFloat32Array = isFloat32Array;
  function isFloat64Array(value) {
    return whichTypedArray(value) === "Float64Array";
  }
  exports.isFloat64Array = isFloat64Array;
  function isBigInt64Array(value) {
    return whichTypedArray(value) === "BigInt64Array";
  }
  exports.isBigInt64Array = isBigInt64Array;
  function isBigUint64Array(value) {
    return whichTypedArray(value) === "BigUint64Array";
  }
  exports.isBigUint64Array = isBigUint64Array;
  function isMapToString(value) {
    return ObjectToString(value) === "[object Map]";
  }
  isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
  function isMap3(value) {
    if (typeof Map === "undefined") {
      return false;
    }
    return isMapToString.working ? isMapToString(value) : value instanceof Map;
  }
  exports.isMap = isMap3;
  function isSetToString(value) {
    return ObjectToString(value) === "[object Set]";
  }
  isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
  function isSet3(value) {
    if (typeof Set === "undefined") {
      return false;
    }
    return isSetToString.working ? isSetToString(value) : value instanceof Set;
  }
  exports.isSet = isSet3;
  function isWeakMapToString(value) {
    return ObjectToString(value) === "[object WeakMap]";
  }
  isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
  function isWeakMap3(value) {
    if (typeof WeakMap === "undefined") {
      return false;
    }
    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
  }
  exports.isWeakMap = isWeakMap3;
  function isWeakSetToString(value) {
    return ObjectToString(value) === "[object WeakSet]";
  }
  isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
  function isWeakSet2(value) {
    return isWeakSetToString(value);
  }
  exports.isWeakSet = isWeakSet2;
  function isArrayBufferToString(value) {
    return ObjectToString(value) === "[object ArrayBuffer]";
  }
  isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
  function isArrayBuffer(value) {
    if (typeof ArrayBuffer === "undefined") {
      return false;
    }
    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
  }
  exports.isArrayBuffer = isArrayBuffer;
  function isDataViewToString(value) {
    return ObjectToString(value) === "[object DataView]";
  }
  isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
  function isDataView(value) {
    if (typeof DataView === "undefined") {
      return false;
    }
    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
  }
  exports.isDataView = isDataView;
  var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
  function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === "[object SharedArrayBuffer]";
  }
  function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBufferCopy === "undefined") {
      return false;
    }
    if (typeof isSharedArrayBufferToString.working === "undefined") {
      isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    }
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
  }
  exports.isSharedArrayBuffer = isSharedArrayBuffer;
  function isAsyncFunction(value) {
    return ObjectToString(value) === "[object AsyncFunction]";
  }
  exports.isAsyncFunction = isAsyncFunction;
  function isMapIterator(value) {
    return ObjectToString(value) === "[object Map Iterator]";
  }
  exports.isMapIterator = isMapIterator;
  function isSetIterator(value) {
    return ObjectToString(value) === "[object Set Iterator]";
  }
  exports.isSetIterator = isSetIterator;
  function isGeneratorObject(value) {
    return ObjectToString(value) === "[object Generator]";
  }
  exports.isGeneratorObject = isGeneratorObject;
  function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === "[object WebAssembly.Module]";
  }
  exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
  function isNumberObject3(value) {
    return checkBoxedPrimitive(value, numberValue);
  }
  exports.isNumberObject = isNumberObject3;
  function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
  }
  exports.isStringObject = isStringObject;
  function isBooleanObject2(value) {
    return checkBoxedPrimitive(value, booleanValue);
  }
  exports.isBooleanObject = isBooleanObject2;
  function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
  }
  exports.isBigIntObject = isBigIntObject;
  function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
  }
  exports.isSymbolObject = isSymbolObject;
  function isBoxedPrimitive(value) {
    return isNumberObject3(value) || isStringObject(value) || isBooleanObject2(value) || isBigIntObject(value) || isSymbolObject(value);
  }
  exports.isBoxedPrimitive = isBoxedPrimitive;
  function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
  }
  exports.isAnyArrayBuffer = isAnyArrayBuffer;
  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
    Object.defineProperty(exports, method, {
      enumerable: false,
      value: function() {
        throw new Error(method + " is not supported in userland");
      }
    });
  });
});
var types_1 = types$2.isArgumentsObject;
var types_2 = types$2.isGeneratorFunction;
var types_3 = types$2.isTypedArray;
var types_4 = types$2.isPromise;
var types_5 = types$2.isArrayBufferView;
var types_6 = types$2.isUint8Array;
var types_7 = types$2.isUint8ClampedArray;
var types_8 = types$2.isUint16Array;
var types_9 = types$2.isUint32Array;
var types_10 = types$2.isInt8Array;
var types_11 = types$2.isInt16Array;
var types_12 = types$2.isInt32Array;
var types_13 = types$2.isFloat32Array;
var types_14 = types$2.isFloat64Array;
var types_15 = types$2.isBigInt64Array;
var types_16 = types$2.isBigUint64Array;
var types_17 = types$2.isMap;
var types_18 = types$2.isSet;
var types_19 = types$2.isWeakMap;
var types_20 = types$2.isWeakSet;
var types_21 = types$2.isArrayBuffer;
var types_22 = types$2.isDataView;
var types_23 = types$2.isSharedArrayBuffer;
var types_24 = types$2.isAsyncFunction;
var types_25 = types$2.isMapIterator;
var types_26 = types$2.isSetIterator;
var types_27 = types$2.isGeneratorObject;
var types_28 = types$2.isWebAssemblyCompiledModule;
var types_29 = types$2.isNumberObject;
var types_30 = types$2.isStringObject;
var types_31 = types$2.isBooleanObject;
var types_32 = types$2.isBigIntObject;
var types_33 = types$2.isSymbolObject;
var types_34 = types$2.isBoxedPrimitive;
var types_35 = types$2.isAnyArrayBuffer;
var isBuffer = function isBuffer2(arg) {
  return arg instanceof Buffer;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits3(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits3(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var inherits = createCommonjsModule(function(module) {
  try {
    var util$1 = util;
    if (typeof util$1.inherits !== "function")
      throw "";
    module.exports = util$1.inherits;
  } catch (e) {
    module.exports = inherits_browser;
  }
});
var util = createCommonjsModule(function(module, exports) {
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
    var keys3 = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys3.length; i++) {
      descriptors[keys3[i]] = Object.getOwnPropertyDescriptor(obj, keys3[i]);
    }
    return descriptors;
  };
  var formatRegExp = /%[sdj%]/g;
  exports.format = function(f) {
    if (!isString3(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str2 = String(f).replace(formatRegExp, function(x3) {
      if (x3 === "%%")
        return "%";
      if (i >= len)
        return x3;
      switch (x3) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_2) {
            return "[Circular]";
          }
        default:
          return x3;
      }
    });
    for (var x2 = args[i]; i < len; x2 = args[++i]) {
      if (isNull2(x2) || !isObject2(x2)) {
        str2 += " " + x2;
      } else {
        str2 += " " + inspect(x2);
      }
    }
    return str2;
  };
  exports.deprecate = function(fn2, msg) {
    if (typeof process !== "undefined" && process.noDeprecation === true) {
      return fn2;
    }
    if (typeof process === "undefined") {
      return function() {
        return exports.deprecate(fn2, msg).apply(this, arguments);
      };
    }
    var warned = false;
    function deprecated2() {
      if (!warned) {
        if (process.throwDeprecation) {
          throw new Error(msg);
        } else if (process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn2.apply(this, arguments);
    }
    return deprecated2;
  };
  var debugs = {};
  var debugEnvRegex = /^$/;
  exports.debuglog = function(set2) {
    set2 = set2.toUpperCase();
    if (!debugs[set2]) {
      if (debugEnvRegex.test(set2)) {
        var pid = process.pid;
        debugs[set2] = function() {
          var msg = exports.format.apply(exports, arguments);
          console.error("%s %d: %s", set2, pid, msg);
        };
      } else {
        debugs[set2] = function() {
        };
      }
    }
    return debugs[set2];
  };
  function inspect(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean4(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      exports._extend(ctx, opts);
    }
    if (isUndefined2(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined2(ctx.depth))
      ctx.depth = 2;
    if (isUndefined2(ctx.colors))
      ctx.colors = false;
    if (isUndefined2(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports.inspect = inspect;
  inspect.colors = {
    "bold": [1, 22],
    "italic": [3, 23],
    "underline": [4, 24],
    "inverse": [7, 27],
    "white": [37, 39],
    "grey": [90, 39],
    "black": [30, 39],
    "blue": [34, 39],
    "cyan": [36, 39],
    "green": [32, 39],
    "magenta": [35, 39],
    "red": [31, 39],
    "yellow": [33, 39]
  };
  inspect.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
  };
  function stylizeWithColor(str2, styleType) {
    var style = inspect.styles[styleType];
    if (style) {
      return "\x1B[" + inspect.colors[style][0] + "m" + str2 + "\x1B[" + inspect.colors[style][1] + "m";
    } else {
      return str2;
    }
  }
  function stylizeNoColor(str2, styleType) {
    return str2;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction3(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString3(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys3 = Object.keys(value);
    var visibleKeys = arrayToHash(keys3);
    if (ctx.showHidden) {
      keys3 = Object.getOwnPropertyNames(value);
    }
    if (isError2(value) && (keys3.indexOf("message") >= 0 || keys3.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys3.length === 0) {
      if (isFunction3(value)) {
        var name3 = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name3 + "]", "special");
      }
      if (isRegExp3(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate2(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError2(value)) {
        return formatError(value);
      }
    }
    var base = "", array = false, braces = ["{", "}"];
    if (isArray4(value)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction3(value)) {
      var n = value.name ? ": " + value.name : "";
      base = " [Function" + n + "]";
    }
    if (isRegExp3(value)) {
      base = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate2(value)) {
      base = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError2(value)) {
      base = " " + formatError(value);
    }
    if (keys3.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp3(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys3);
    } else {
      output = keys3.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined2(value))
      return ctx.stylize("undefined", "undefined");
    if (isString3(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber2(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean4(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull2(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys3) {
    var output = [];
    for (var i = 0, l2 = value.length; i < l2; ++i) {
      if (hasOwnProperty3(value, String(i))) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          String(i),
          true
        ));
      } else {
        output.push("");
      }
    }
    keys3.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key,
          true
        ));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name3, str2, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str2 = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str2 = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str2 = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty3(visibleKeys, key)) {
      name3 = "[" + key + "]";
    }
    if (!str2) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull2(recurseTimes)) {
          str2 = formatValue(ctx, desc.value, null);
        } else {
          str2 = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str2.indexOf("\n") > -1) {
          if (array) {
            str2 = str2.split("\n").map(function(line2) {
              return "  " + line2;
            }).join("\n").slice(2);
          } else {
            str2 = "\n" + str2.split("\n").map(function(line2) {
              return "   " + line2;
            }).join("\n");
          }
        }
      } else {
        str2 = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined2(name3)) {
      if (array && key.match(/^\d+$/)) {
        return str2;
      }
      name3 = JSON.stringify("" + key);
      if (name3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name3 = name3.slice(1, -1);
        name3 = ctx.stylize(name3, "name");
      } else {
        name3 = name3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name3 = ctx.stylize(name3, "string");
      }
    }
    return name3 + ": " + str2;
  }
  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
  }
  exports.types = types$2;
  function isArray4(ar2) {
    return Array.isArray(ar2);
  }
  exports.isArray = isArray4;
  function isBoolean4(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean4;
  function isNull2(arg) {
    return arg === null;
  }
  exports.isNull = isNull2;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber2;
  function isString3(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString3;
  function isSymbol2(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol2;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  exports.isUndefined = isUndefined2;
  function isRegExp3(re3) {
    return isObject2(re3) && objectToString2(re3) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp3;
  exports.types.isRegExp = isRegExp3;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject2;
  function isDate2(d2) {
    return isObject2(d2) && objectToString2(d2) === "[object Date]";
  }
  exports.isDate = isDate2;
  exports.types.isDate = isDate2;
  function isError2(e) {
    return isObject2(e) && (objectToString2(e) === "[object Error]" || e instanceof Error);
  }
  exports.isError = isError2;
  exports.types.isNativeError = isError2;
  function isFunction3(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction3;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = isBuffer;
  function objectToString2(o) {
    return Object.prototype.toString.call(o);
  }
  function pad(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
  }
  var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function timestamp2() {
    var d2 = /* @__PURE__ */ new Date();
    var time2 = [
      pad(d2.getHours()),
      pad(d2.getMinutes()),
      pad(d2.getSeconds())
    ].join(":");
    return [d2.getDate(), months[d2.getMonth()], time2].join(" ");
  }
  exports.log = function() {
    console.log("%s - %s", timestamp2(), exports.format.apply(exports, arguments));
  };
  exports.inherits = inherits;
  exports._extend = function(origin, add) {
    if (!add || !isObject2(add))
      return origin;
    var keys3 = Object.keys(add);
    var i = keys3.length;
    while (i--) {
      origin[keys3[i]] = add[keys3[i]];
    }
    return origin;
  };
  function hasOwnProperty3(obj, prop2) {
    return Object.prototype.hasOwnProperty.call(obj, prop2);
  }
  var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
  exports.promisify = function promisify(original) {
    if (typeof original !== "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn2 = original[kCustomPromisifiedSymbol];
      if (typeof fn2 !== "function") {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }
      Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
        value: fn2,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return fn2;
    }
    function fn2() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function(resolve, reject) {
        promiseResolve = resolve;
        promiseReject = reject;
      });
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      args.push(function(err, value) {
        if (err) {
          promiseReject(err);
        } else {
          promiseResolve(value);
        }
      });
      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }
      return promise;
    }
    Object.setPrototypeOf(fn2, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol)
      Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
        value: fn2,
        enumerable: false,
        writable: false,
        configurable: true
      });
    return Object.defineProperties(
      fn2,
      getOwnPropertyDescriptors(original)
    );
  };
  exports.promisify.custom = kCustomPromisifiedSymbol;
  function callbackifyOnRejected(reason, cb) {
    if (!reason) {
      var newReason = new Error("Promise was rejected with a falsy value");
      newReason.reason = reason;
      reason = newReason;
    }
    return cb(reason);
  }
  function callbackify(original) {
    if (typeof original !== "function") {
      throw new TypeError('The "original" argument must be of type Function');
    }
    function callbackified() {
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      var maybeCb = args.pop();
      if (typeof maybeCb !== "function") {
        throw new TypeError("The last argument must be of type Function");
      }
      var self2 = this;
      var cb = function() {
        return maybeCb.apply(self2, arguments);
      };
      original.apply(this, args).then(
        function(ret) {
          process.nextTick(cb.bind(null, null, ret));
        },
        function(rej) {
          process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        }
      );
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(
      callbackified,
      getOwnPropertyDescriptors(original)
    );
    return callbackified;
  }
  exports.callbackify = callbackify;
});
var util_1 = util.format;
var util_2 = util.deprecate;
var util_3 = util.debuglog;
var util_4 = util.inspect;
var util_5 = util.types;
var util_6 = util.isArray;
var util_7 = util.isBoolean;
var util_8 = util.isNull;
var util_9 = util.isNullOrUndefined;
var util_10 = util.isNumber;
var util_11 = util.isString;
var util_12 = util.isSymbol;
var util_13 = util.isUndefined;
var util_14 = util.isRegExp;
var util_15 = util.isObject;
var util_16 = util.isDate;
var util_17 = util.isError;
var util_18 = util.isFunction;
var util_19 = util.isPrimitive;
var util_20 = util.isBuffer;
var util_21 = util.log;
var util_22 = util.inherits;
var util_23 = util._extend;
var util_24 = util.promisify;
var util_25 = util.callbackify;
var util_inspect = util.inspect;
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice$2 = String.prototype.slice;
var $replace$1 = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat$1 = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable$1 = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
  return O2.__proto__;
} : null);
function addNumericSeparator(num2, str2) {
  if (num2 === Infinity || num2 === -Infinity || num2 !== num2 || num2 && num2 > -1e3 && num2 < 1e3 || $test.call(/e/, str2)) {
    return str2;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num2 === "number") {
    var int2 = num2 < 0 ? -$floor(-num2) : $floor(num2);
    if (int2 !== num2) {
      var intStr = String(int2);
      var dec = $slice$2.call(str2, intStr.length + 1);
      return $replace$1.call(intStr, sepRegex, "$&_") + "." + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace$1.call(str2, sepRegex, "$&_");
}
var inspectCustom = util_inspect.custom;
var inspectSymbol = isSymbol$1(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options2, depth, seen) {
  var opts = options2 || {};
  if (has$2(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$2(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$2(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str2 = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str2) : str2;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$1(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf$1(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$2(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function" && !isRegExp(obj)) {
    var name3 = nameOf(obj);
    var keys3 = arrObjKeys(obj, inspect);
    return "[Function" + (name3 ? ": " + name3 : " (anonymous)") + "]" + (keys3.length > 0 ? " { " + $join.call(keys3, ", ") + " }" : "");
  }
  if (isSymbol$1(obj)) {
    var symString = hasShammedSymbols ? $replace$1.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement$1(obj)) {
    var s = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs2 = obj.attributes || [];
    for (var i = 0; i < attrs2.length; i++) {
      s += " " + attrs2[i].name + "=" + wrapQuotes(quote(attrs2[i].value), "double", opts);
    }
    s += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s += "...";
    }
    s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s;
  }
  if (isArray$1(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs2 = arrObjKeys(obj, inspect);
    if (indent && !singleLineValues(xs2)) {
      return "[" + indentedJoin(xs2, indent) + "]";
    }
    return "[ " + $join.call(xs2, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable$1.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat$1.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && util_inspect) {
      return util_inspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap$1(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function(value, key) {
      mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
    });
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet$1(obj)) {
    var setParts = [];
    setForEach.call(obj, function(value) {
      setParts.push(inspect(value, obj));
    });
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap2(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect(bigIntValueOf.call(obj)));
  }
  if (isBoolean2(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString$1(obj)) {
    return markBoxed(inspect(String(obj)));
  }
  if (!isDate(obj) && !isRegExp(obj)) {
    var ys2 = arrObjKeys(obj, inspect);
    var isPlainObject3 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject3 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice$2.call(toStr$a(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject3 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag3 = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat$1.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys2.length === 0) {
      return tag3 + "{}";
    }
    if (indent) {
      return tag3 + "{" + indentedJoin(ys2, indent) + "}";
    }
    return tag3 + "{ " + $join.call(ys2, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return $replace$1.call(String(s), /"/g, "&quot;");
}
function isArray$1(obj) {
  return toStr$a(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
  return toStr$a(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp(obj) {
  return toStr$a(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr$a(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString$1(obj) {
  return toStr$a(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr$a(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean2(obj) {
  return toStr$a(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol$1(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn$1 = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$2(obj, key) {
  return hasOwn$1.call(obj, key);
}
function toStr$a(obj) {
  return objectToString.call(obj);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m) {
    return m[1];
  }
  return null;
}
function indexOf$1(xs2, x2) {
  if (xs2.indexOf) {
    return xs2.indexOf(x2);
  }
  for (var i = 0, l2 = xs2.length; i < l2; i++) {
    if (xs2[i] === x2) {
      return i;
    }
  }
  return -1;
}
function isMap$1(x2) {
  if (!mapSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    mapSize.call(x2);
    try {
      setSize.call(x2);
    } catch (s) {
      return true;
    }
    return x2 instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap2(x2) {
  if (!weakMapHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x2, weakMapHas);
    try {
      weakSetHas.call(x2, weakSetHas);
    } catch (s) {
      return true;
    }
    return x2 instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x2) {
  if (!weakRefDeref || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x2);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet$1(x2) {
  if (!setSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    setSize.call(x2);
    try {
      mapSize.call(x2);
    } catch (m) {
      return true;
    }
    return x2 instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet(x2) {
  if (!weakSetHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x2, weakSetHas);
    try {
      weakMapHas.call(x2, weakMapHas);
    } catch (s) {
      return true;
    }
    return x2 instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement$1(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
    return true;
  }
  return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
}
function inspectString(str2, opts) {
  if (str2.length > opts.maxStringLength) {
    var remaining = str2.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice$2.call(str2, 0, opts.maxStringLength), opts) + trailer;
  }
  var s = $replace$1.call($replace$1.call(str2, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, "single", opts);
}
function lowbyte(c2) {
  var n = c2.charCodeAt(0);
  var x2 = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n];
  if (x2) {
    return "\\" + x2;
  }
  return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
}
function markBoxed(str2) {
  return "Object(" + str2 + ")";
}
function weakCollectionOf(type2) {
  return type2 + " { ? }";
}
function collectionOf(type2, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type2 + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs2) {
  for (var i = 0; i < xs2.length; i++) {
    if (indexOf$1(xs2[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs2, indent) {
  if (xs2.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs2, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect) {
  var isArr = isArray$1(obj);
  var xs2 = [];
  if (isArr) {
    xs2.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs2[i] = has$2(obj, i) ? inspect(obj[i], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k2 = 0; k2 < syms.length; k2++) {
      symMap["$" + syms[k2]] = syms[k2];
    }
  }
  for (var key in obj) {
    if (!has$2(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs2.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
    } else {
      xs2.push(key + ": " + inspect(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable$1.call(obj, syms[j])) {
        xs2.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
      }
    }
  }
  return xs2;
}
var $TypeError$1 = getIntrinsic("%TypeError%");
var $WeakMap$1 = getIntrinsic("%WeakMap%", true);
var $Map$2 = getIntrinsic("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas$3 = callBound("Map.prototype.has", true);
var listGetNode = function(list2, key) {
  for (var prev = list2, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list2.next;
      list2.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node2 = listGetNode(objects, key);
  return node2 && node2.value;
};
var listSet = function(objects, key, value) {
  var node2 = listGetNode(objects, key);
  if (node2) {
    node2.value = value;
  } else {
    objects.next = {
      // eslint-disable-line no-param-reassign
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o2;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError$1("Side channel does not contain " + objectInspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map$2) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o2) {
          return listGet($o2, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map$2) {
        if ($m) {
          return $mapHas$3($m, key);
        }
      } else {
        if ($o2) {
          return listHas($o2, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap$1();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map$2) {
        if (!$m) {
          $m = new $Map$2();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o2) {
          $o2 = { key: {}, next: null };
        }
        listSet($o2, key, value);
      }
    }
  };
  return channel;
};
var hasSymbols$3 = shams();
var toObject = Object;
var $push = callBound("Array.prototype.push");
var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
var originalGetSymbols = hasSymbols$3 ? Object.getOwnPropertySymbols : null;
var implementation$4 = function assign(target2, source1) {
  if (target2 == null) {
    throw new TypeError("target must be an object");
  }
  var to2 = toObject(target2);
  if (arguments.length === 1) {
    return to2;
  }
  for (var s = 1; s < arguments.length; ++s) {
    var from = toObject(arguments[s]);
    var keys3 = objectKeys(from);
    var getSymbols = hasSymbols$3 && (Object.getOwnPropertySymbols || originalGetSymbols);
    if (getSymbols) {
      var syms = getSymbols(from);
      for (var j = 0; j < syms.length; ++j) {
        var key = syms[j];
        if ($propIsEnumerable(from, key)) {
          $push(keys3, key);
        }
      }
    }
    for (var i = 0; i < keys3.length; ++i) {
      var nextKey = keys3[i];
      if ($propIsEnumerable(from, nextKey)) {
        var propValue = from[nextKey];
        to2[nextKey] = propValue;
      }
    }
  }
  return to2;
};
var lacksProperEnumerationOrder = function() {
  if (!Object.assign) {
    return false;
  }
  var str2 = "abcdefghijklmnopqrst";
  var letters = str2.split("");
  var map2 = {};
  for (var i = 0; i < letters.length; ++i) {
    map2[letters[i]] = letters[i];
  }
  var obj = Object.assign({}, map2);
  var actual = "";
  for (var k2 in obj) {
    actual += k2;
  }
  return str2 !== actual;
};
var assignHasPendingExceptions = function() {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  var thrower = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(thrower, "xy");
  } catch (e) {
    return thrower[1] === "y";
  }
  return false;
};
var polyfill$3 = function getPolyfill3() {
  if (!Object.assign) {
    return implementation$4;
  }
  if (lacksProperEnumerationOrder()) {
    return implementation$4;
  }
  if (assignHasPendingExceptions()) {
    return implementation$4;
  }
  return Object.assign;
};
var shim$2 = function shimAssign() {
  var polyfill2 = polyfill$3();
  defineProperties_1(
    Object,
    { assign: polyfill2 },
    { assign: function() {
      return Object.assign !== polyfill2;
    } }
  );
  return polyfill2;
};
var polyfill$4 = callBind.apply(polyfill$3());
var bound = function assign2(target2, source1) {
  return polyfill$4(Object, arguments);
};
defineProperties_1(bound, {
  getPolyfill: polyfill$3,
  implementation: implementation$4,
  shim: shim$2
});
var object_assign = bound;
var getIterator$1 = getCjsExportFromNamespace(node$1);
var $getTime = callBound("Date.prototype.getTime");
var gPO$1 = Object.getPrototypeOf;
var $objToString = callBound("Object.prototype.toString");
var $Set$2 = getIntrinsic("%Set%", true);
var $mapHas$4 = callBound("Map.prototype.has", true);
var $mapGet$1 = callBound("Map.prototype.get", true);
var $mapSize = callBound("Map.prototype.size", true);
var $setAdd = callBound("Set.prototype.add", true);
var $setDelete = callBound("Set.prototype.delete", true);
var $setHas$3 = callBound("Set.prototype.has", true);
var $setSize = callBound("Set.prototype.size", true);
function setHasEqualElement(set2, val1, opts, channel) {
  var i = getIterator$1(set2);
  var result;
  while ((result = i.next()) && !result.done) {
    if (internalDeepEqual(val1, result.value, opts, channel)) {
      $setDelete(set2, result.value);
      return true;
    }
  }
  return false;
}
function findLooseMatchingPrimitives(prim) {
  if (typeof prim === "undefined") {
    return null;
  }
  if (typeof prim === "object") {
    return void 0;
  }
  if (typeof prim === "symbol") {
    return false;
  }
  if (typeof prim === "string" || typeof prim === "number") {
    return +prim === +prim;
  }
  return true;
}
function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = $mapGet$1(b, altValue);
  var looseOpts = object_assign({}, opts, { strict: false });
  if (typeof curB === "undefined" && !$mapHas$4(b, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) {
    return false;
  }
  return !$mapHas$4(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
}
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  return $setHas$3(b, altValue) && !$setHas$3(a, altValue);
}
function mapHasEqualEntry(set2, map2, key1, item1, opts, channel) {
  var i = getIterator$1(set2);
  var result;
  var key2;
  while ((result = i.next()) && !result.done) {
    key2 = result.value;
    if (
      // eslint-disable-next-line no-use-before-define
      internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet$1(map2, key2), opts, channel)
    ) {
      $setDelete(set2, key2);
      return true;
    }
  }
  return false;
}
function internalDeepEqual(actual, expected, options2, channel) {
  var opts = options2 || {};
  if (opts.strict ? objectIs(actual, expected) : actual === expected) {
    return true;
  }
  var actualBoxed = whichBoxedPrimitive(actual);
  var expectedBoxed = whichBoxedPrimitive(expected);
  if (actualBoxed !== expectedBoxed) {
    return false;
  }
  if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
    return opts.strict ? objectIs(actual, expected) : actual == expected;
  }
  var hasActual = channel.has(actual);
  var hasExpected = channel.has(expected);
  var sentinel;
  if (hasActual && hasExpected) {
    if (channel.get(actual) === channel.get(expected)) {
      return true;
    }
  } else {
    sentinel = {};
  }
  if (!hasActual) {
    channel.set(actual, sentinel);
  }
  if (!hasExpected) {
    channel.set(expected, sentinel);
  }
  return objEquiv(actual, expected, opts, channel);
}
function isBuffer$1(x2) {
  if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
    return false;
  }
  if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
    return false;
  }
  if (x2.length > 0 && typeof x2[0] !== "number") {
    return false;
  }
  return !!(x2.constructor && x2.constructor.isBuffer && x2.constructor.isBuffer(x2));
}
function setEquiv(a, b, opts, channel) {
  if ($setSize(a) !== $setSize(b)) {
    return false;
  }
  var iA = getIterator$1(a);
  var iB = getIterator$1(b);
  var resultA;
  var resultB;
  var set2;
  while ((resultA = iA.next()) && !resultA.done) {
    if (resultA.value && typeof resultA.value === "object") {
      if (!set2) {
        set2 = new $Set$2();
      }
      $setAdd(set2, resultA.value);
    } else if (!$setHas$3(b, resultA.value)) {
      if (opts.strict) {
        return false;
      }
      if (!setMightHaveLoosePrim(a, b, resultA.value)) {
        return false;
      }
      if (!set2) {
        set2 = new $Set$2();
      }
      $setAdd(set2, resultA.value);
    }
  }
  if (set2) {
    while ((resultB = iB.next()) && !resultB.done) {
      if (resultB.value && typeof resultB.value === "object") {
        if (!setHasEqualElement(set2, resultB.value, opts.strict, channel)) {
          return false;
        }
      } else if (!opts.strict && !$setHas$3(a, resultB.value) && !setHasEqualElement(set2, resultB.value, opts.strict, channel)) {
        return false;
      }
    }
    return $setSize(set2) === 0;
  }
  return true;
}
function mapEquiv(a, b, opts, channel) {
  if ($mapSize(a) !== $mapSize(b)) {
    return false;
  }
  var iA = getIterator$1(a);
  var iB = getIterator$1(b);
  var resultA;
  var resultB;
  var set2;
  var key;
  var item1;
  var item2;
  while ((resultA = iA.next()) && !resultA.done) {
    key = resultA.value[0];
    item1 = resultA.value[1];
    if (key && typeof key === "object") {
      if (!set2) {
        set2 = new $Set$2();
      }
      $setAdd(set2, key);
    } else {
      item2 = $mapGet$1(b, key);
      if (typeof item2 === "undefined" && !$mapHas$4(b, key) || !internalDeepEqual(item1, item2, opts, channel)) {
        if (opts.strict) {
          return false;
        }
        if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {
          return false;
        }
        if (!set2) {
          set2 = new $Set$2();
        }
        $setAdd(set2, key);
      }
    }
  }
  if (set2) {
    while ((resultB = iB.next()) && !resultB.done) {
      key = resultB.value[0];
      item2 = resultB.value[1];
      if (key && typeof key === "object") {
        if (!mapHasEqualEntry(set2, a, key, item2, opts, channel)) {
          return false;
        }
      } else if (!opts.strict && (!a.has(key) || !internalDeepEqual($mapGet$1(a, key), item2, opts, channel)) && !mapHasEqualEntry(set2, a, key, item2, object_assign({}, opts, { strict: false }), channel)) {
        return false;
      }
    }
    return $setSize(set2) === 0;
  }
  return true;
}
function objEquiv(a, b, opts, channel) {
  var i, key;
  if (typeof a !== typeof b) {
    return false;
  }
  if (a == null || b == null) {
    return false;
  }
  if ($objToString(a) !== $objToString(b)) {
    return false;
  }
  if (isArguments$1(a) !== isArguments$1(b)) {
    return false;
  }
  var aIsArray = isarray(a);
  var bIsArray = isarray(b);
  if (aIsArray !== bIsArray) {
    return false;
  }
  var aIsError = a instanceof Error;
  var bIsError = b instanceof Error;
  if (aIsError !== bIsError) {
    return false;
  }
  if (aIsError || bIsError) {
    if (a.name !== b.name || a.message !== b.message) {
      return false;
    }
  }
  var aIsRegex = isRegex(a);
  var bIsRegex = isRegex(b);
  if (aIsRegex !== bIsRegex) {
    return false;
  }
  if ((aIsRegex || bIsRegex) && (a.source !== b.source || regexp_prototype_flags(a) !== regexp_prototype_flags(b))) {
    return false;
  }
  var aIsDate = isDateObject(a);
  var bIsDate = isDateObject(b);
  if (aIsDate !== bIsDate) {
    return false;
  }
  if (aIsDate || bIsDate) {
    if ($getTime(a) !== $getTime(b)) {
      return false;
    }
  }
  if (opts.strict && gPO$1 && gPO$1(a) !== gPO$1(b)) {
    return false;
  }
  if (whichTypedArray(a) !== whichTypedArray(b)) {
    return false;
  }
  var aIsBuffer = isBuffer$1(a);
  var bIsBuffer = isBuffer$1(b);
  if (aIsBuffer !== bIsBuffer) {
    return false;
  }
  if (aIsBuffer || bIsBuffer) {
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  var ka2 = objectKeys(a);
  var kb2 = objectKeys(b);
  if (ka2.length !== kb2.length) {
    return false;
  }
  ka2.sort();
  kb2.sort();
  for (i = ka2.length - 1; i >= 0; i--) {
    if (ka2[i] != kb2[i]) {
      return false;
    }
  }
  for (i = ka2.length - 1; i >= 0; i--) {
    key = ka2[i];
    if (!internalDeepEqual(a[key], b[key], opts, channel)) {
      return false;
    }
  }
  var aCollection = whichCollection(a);
  var bCollection = whichCollection(b);
  if (aCollection !== bCollection) {
    return false;
  }
  if (aCollection === "Set" || bCollection === "Set") {
    return setEquiv(a, b, opts, channel);
  }
  if (aCollection === "Map") {
    return mapEquiv(a, b, opts, channel);
  }
  return true;
}
var deepEqual = function deepEqual2(a, b, opts) {
  return internalDeepEqual(a, b, opts, sideChannel());
};
var elementRoleMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _deepEqual = _interopRequireDefault(deepEqual);
  var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
  var _rolesMap = _interopRequireDefault(rolesMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i2) {
    var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i2 == null)
      return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _s2, _e2;
    try {
      for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
        _arr.push(_s2.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i2["return"] != null)
          _i2["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it3 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it3) {
      if (Array.isArray(o) || (it3 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it3)
          o = it3;
        var i2 = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n() {
          if (i2 >= o.length)
            return { done: true };
          return { done: false, value: o[i2++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it3 = it3.call(o);
    }, n: function n() {
      var step = it3.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it3.return != null)
          it3.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  var elementRoles = [];
  var keys3 = _rolesMap.default.keys();
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    var role = _rolesMap.default.get(key);
    if (role) {
      var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
      for (var k2 = 0; k2 < concepts.length; k2++) {
        var relation = concepts[k2];
        if (relation.module === "HTML") {
          var concept = relation.concept;
          if (concept) {
            (function() {
              var conceptStr = JSON.stringify(concept);
              var elementRoleRelation = elementRoles.find(function(relation2) {
                return JSON.stringify(relation2[0]) === conceptStr;
              });
              var roles = void 0;
              if (elementRoleRelation) {
                roles = elementRoleRelation[1];
              } else {
                roles = [];
              }
              var isUnique = true;
              for (var _i2 = 0; _i2 < roles.length; _i2++) {
                if (roles[_i2] === key) {
                  isUnique = false;
                  break;
                }
              }
              if (isUnique) {
                roles.push(key);
              }
              elementRoles.push([concept, roles]);
            })();
          }
        }
      }
    }
  }
  var elementRoleMap = {
    entries: function entries() {
      return elementRoles;
    },
    forEach: function forEach3(fn2) {
      var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var _iterator = _createForOfIteratorHelper(elementRoles), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values2 = _step$value[1];
          fn2.call(thisArg, values2, _key, elementRoles);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    get: function get(key2) {
      var item = elementRoles.find(function(tuple) {
        return (0, _deepEqual.default)(key2, tuple[0]);
      });
      return item && item[1];
    },
    has: function has(key2) {
      return !!elementRoleMap.get(key2);
    },
    keys: function keys4() {
      return elementRoles.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
        return key2;
      });
    },
    values: function values2() {
      return elementRoles.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
  exports.default = _default;
});
unwrapExports(elementRoleMap_1);
var roleElementMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
  var _rolesMap = _interopRequireDefault(rolesMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i2) {
    var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i2 == null)
      return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _s2, _e2;
    try {
      for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
        _arr.push(_s2.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i2["return"] != null)
          _i2["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it3 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it3) {
      if (Array.isArray(o) || (it3 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it3)
          o = it3;
        var i2 = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n() {
          if (i2 >= o.length)
            return { done: true };
          return { done: false, value: o[i2++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it3 = it3.call(o);
    }, n: function n() {
      var step = it3.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it3.return != null)
          it3.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  var roleElement = [];
  var keys3 = _rolesMap.default.keys();
  var _loop = function _loop2(i2) {
    var key = keys3[i2];
    var role = _rolesMap.default.get(key);
    if (role) {
      var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
      for (var k2 = 0; k2 < concepts.length; k2++) {
        var relation = concepts[k2];
        if (relation.module === "HTML") {
          var concept = relation.concept;
          if (concept) {
            var roleElementRelation = roleElement.find(function(item) {
              return item[0] === key;
            });
            var relationConcepts = void 0;
            if (roleElementRelation) {
              relationConcepts = roleElementRelation[1];
            } else {
              relationConcepts = [];
            }
            relationConcepts.push(concept);
            roleElement.push([key, relationConcepts]);
          }
        }
      }
    }
  };
  for (var i = 0; i < keys3.length; i++) {
    _loop(i);
  }
  var roleElementMap = {
    entries: function entries() {
      return roleElement;
    },
    forEach: function forEach3(fn2) {
      var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var _iterator = _createForOfIteratorHelper(roleElement), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values2 = _step$value[1];
          fn2.call(thisArg, values2, key, roleElement);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    get: function get(key) {
      var item = roleElement.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has(key) {
      return !!roleElementMap.get(key);
    },
    keys: function keys4() {
      return roleElement.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return roleElement.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
  exports.default = _default;
});
unwrapExports(roleElementMap_1);
var lib = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
  var _ariaPropsMap = _interopRequireDefault(ariaPropsMap_1);
  var _domMap = _interopRequireDefault(domMap_1);
  var _rolesMap = _interopRequireDefault(rolesMap_1);
  var _elementRoleMap = _interopRequireDefault(elementRoleMap_1);
  var _roleElementMap = _interopRequireDefault(roleElementMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var aria2 = _ariaPropsMap.default;
  exports.aria = aria2;
  var dom = _domMap.default;
  exports.dom = dom;
  var roles = _rolesMap.default;
  exports.roles = roles;
  var elementRoles = _elementRoleMap.default;
  exports.elementRoles = elementRoles;
  var roleElements = _roleElementMap.default;
  exports.roleElements = roleElements;
});
unwrapExports(lib);
var lib_1 = lib.roles;
var lib_2 = lib.roleElements;
var lib_3 = lib.elementRoles;
var lib_4 = lib.dom;
var lib_5 = lib.aria;
var iteratorProxy_1$1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  function iteratorProxy() {
    var values2 = this;
    var index2 = 0;
    var iter = {
      "@@iterator": function iterator() {
        return iter;
      },
      next: function next() {
        if (index2 < values2.length) {
          var value = values2[index2];
          index2 = index2 + 1;
          return {
            done: false,
            value
          };
        } else {
          return {
            done: true
          };
        }
      }
    };
    return iter;
  }
  var _default = iteratorProxy;
  exports.default = _default;
});
unwrapExports(iteratorProxy_1$1);
var iterationDecorator_1$1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = iterationDecorator;
  var _iteratorProxy = _interopRequireDefault(iteratorProxy_1$1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function iterationDecorator(collection, entries) {
    if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
      Object.defineProperty(collection, Symbol.iterator, {
        value: _iteratorProxy.default.bind(entries)
      });
    }
    return collection;
  }
});
unwrapExports(iterationDecorator_1$1);
var AbbrRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var AbbrRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "abbr"
      }
    }],
    type: "structure"
  };
  var _default = AbbrRole;
  exports.default = _default;
});
unwrapExports(AbbrRole_1);
var AlertDialogRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var AlertDialogRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "alertdialog"
      }
    }],
    type: "window"
  };
  var _default = AlertDialogRole;
  exports.default = _default;
});
unwrapExports(AlertDialogRole_1);
var AlertRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var AlertRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "alert"
      }
    }],
    type: "structure"
  };
  var _default = AlertRole;
  exports.default = _default;
});
unwrapExports(AlertRole_1);
var AnnotationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var AnnotationRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = AnnotationRole;
  exports.default = _default;
});
unwrapExports(AnnotationRole_1);
var ApplicationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ApplicationRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "application"
      }
    }],
    type: "window"
  };
  var _default = ApplicationRole;
  exports.default = _default;
});
unwrapExports(ApplicationRole_1);
var ArticleRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ArticleRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "article"
      }
    }, {
      module: "HTML",
      concept: {
        name: "article"
      }
    }],
    type: "structure"
  };
  var _default = ArticleRole;
  exports.default = _default;
});
unwrapExports(ArticleRole_1);
var AudioRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var AudioRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "audio"
      }
    }],
    type: "widget"
  };
  var _default = AudioRole;
  exports.default = _default;
});
unwrapExports(AudioRole_1);
var BannerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var BannerRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "banner"
      }
    }],
    type: "structure"
  };
  var _default = BannerRole;
  exports.default = _default;
});
unwrapExports(BannerRole_1);
var BlockquoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var BlockquoteRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "blockquote"
      }
    }],
    type: "structure"
  };
  var _default = BlockquoteRole;
  exports.default = _default;
});
unwrapExports(BlockquoteRole_1);
var BusyIndicatorRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var BusyIndicatorRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        attributes: [{
          name: "aria-busy",
          value: "true"
        }]
      }
    }],
    type: "widget"
  };
  var _default = BusyIndicatorRole;
  exports.default = _default;
});
unwrapExports(BusyIndicatorRole_1);
var ButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ButtonRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "button"
      }
    }, {
      module: "HTML",
      concept: {
        name: "button"
      }
    }],
    type: "widget"
  };
  var _default = ButtonRole;
  exports.default = _default;
});
unwrapExports(ButtonRole_1);
var CanvasRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var CanvasRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "canvas"
      }
    }],
    type: "widget"
  };
  var _default = CanvasRole;
  exports.default = _default;
});
unwrapExports(CanvasRole_1);
var CaptionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var CaptionRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "caption"
      }
    }],
    type: "structure"
  };
  var _default = CaptionRole;
  exports.default = _default;
});
unwrapExports(CaptionRole_1);
var CellRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var CellRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "cell"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "gridcell"
      }
    }, {
      module: "HTML",
      concept: {
        name: "td"
      }
    }],
    type: "widget"
  };
  var _default = CellRole;
  exports.default = _default;
});
unwrapExports(CellRole_1);
var CheckBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var CheckBoxRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "checkbox"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "checkbox"
        }]
      }
    }],
    type: "widget"
  };
  var _default = CheckBoxRole;
  exports.default = _default;
});
unwrapExports(CheckBoxRole_1);
var ColorWellRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ColorWellRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "color"
        }]
      }
    }],
    type: "widget"
  };
  var _default = ColorWellRole;
  exports.default = _default;
});
unwrapExports(ColorWellRole_1);
var ColumnHeaderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ColumnHeaderRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "columnheader"
      }
    }, {
      module: "HTML",
      concept: {
        name: "th"
      }
    }],
    type: "widget"
  };
  var _default = ColumnHeaderRole;
  exports.default = _default;
});
unwrapExports(ColumnHeaderRole_1);
var ColumnRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ColumnRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = ColumnRole;
  exports.default = _default;
});
unwrapExports(ColumnRole_1);
var ComboBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ComboBoxRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "combobox"
      }
    }, {
      module: "HTML",
      concept: {
        name: "select"
      }
    }],
    type: "widget"
  };
  var _default = ComboBoxRole;
  exports.default = _default;
});
unwrapExports(ComboBoxRole_1);
var ComplementaryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ComplementaryRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "complementary"
      }
    }],
    type: "structure"
  };
  var _default = ComplementaryRole;
  exports.default = _default;
});
unwrapExports(ComplementaryRole_1);
var ContentInfoRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ContentInfoRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "structureinfo"
      }
    }],
    type: "structure"
  };
  var _default = ContentInfoRole;
  exports.default = _default;
});
unwrapExports(ContentInfoRole_1);
var DateRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DateRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "date"
        }]
      }
    }],
    type: "widget"
  };
  var _default = DateRole;
  exports.default = _default;
});
unwrapExports(DateRole_1);
var DateTimeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DateTimeRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "datetime"
        }]
      }
    }],
    type: "widget"
  };
  var _default = DateTimeRole;
  exports.default = _default;
});
unwrapExports(DateTimeRole_1);
var DefinitionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DefinitionRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "dfn"
      }
    }],
    type: "structure"
  };
  var _default = DefinitionRole;
  exports.default = _default;
});
unwrapExports(DefinitionRole_1);
var DescriptionListDetailRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DescriptionListDetailRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "dd"
      }
    }],
    type: "structure"
  };
  var _default = DescriptionListDetailRole;
  exports.default = _default;
});
unwrapExports(DescriptionListDetailRole_1);
var DescriptionListRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DescriptionListRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "dl"
      }
    }],
    type: "structure"
  };
  var _default = DescriptionListRole;
  exports.default = _default;
});
unwrapExports(DescriptionListRole_1);
var DescriptionListTermRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DescriptionListTermRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "dt"
      }
    }],
    type: "structure"
  };
  var _default = DescriptionListTermRole;
  exports.default = _default;
});
unwrapExports(DescriptionListTermRole_1);
var DetailsRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DetailsRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "details"
      }
    }],
    type: "structure"
  };
  var _default = DetailsRole;
  exports.default = _default;
});
unwrapExports(DetailsRole_1);
var DialogRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DialogRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "dialog"
      }
    }, {
      module: "HTML",
      concept: {
        name: "dialog"
      }
    }],
    type: "window"
  };
  var _default = DialogRole;
  exports.default = _default;
});
unwrapExports(DialogRole_1);
var DirectoryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DirectoryRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "directory"
      }
    }, {
      module: "HTML",
      concept: {
        name: "dir"
      }
    }],
    type: "structure"
  };
  var _default = DirectoryRole;
  exports.default = _default;
});
unwrapExports(DirectoryRole_1);
var DisclosureTriangleRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DisclosureTriangleRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "summary"
      }
    }],
    type: "widget"
  };
  var _default = DisclosureTriangleRole;
  exports.default = _default;
});
unwrapExports(DisclosureTriangleRole_1);
var DivRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DivRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "div"
      }
    }],
    type: "generic"
  };
  var _default = DivRole;
  exports.default = _default;
});
unwrapExports(DivRole_1);
var DocumentRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DocumentRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "document"
      }
    }],
    type: "structure"
  };
  var _default = DocumentRole;
  exports.default = _default;
});
unwrapExports(DocumentRole_1);
var EmbeddedObjectRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var EmbeddedObjectRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "embed"
      }
    }],
    type: "widget"
  };
  var _default = EmbeddedObjectRole;
  exports.default = _default;
});
unwrapExports(EmbeddedObjectRole_1);
var FeedRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var FeedRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "feed"
      }
    }],
    type: "structure"
  };
  var _default = FeedRole;
  exports.default = _default;
});
unwrapExports(FeedRole_1);
var FigcaptionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var FigcaptionRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "figcaption"
      }
    }],
    type: "structure"
  };
  var _default = FigcaptionRole;
  exports.default = _default;
});
unwrapExports(FigcaptionRole_1);
var FigureRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var FigureRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "figure"
      }
    }, {
      module: "HTML",
      concept: {
        name: "figure"
      }
    }],
    type: "structure"
  };
  var _default = FigureRole;
  exports.default = _default;
});
unwrapExports(FigureRole_1);
var FooterRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var FooterRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "footer"
      }
    }],
    type: "structure"
  };
  var _default = FooterRole;
  exports.default = _default;
});
unwrapExports(FooterRole_1);
var FormRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var FormRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "form"
      }
    }, {
      module: "HTML",
      concept: {
        name: "form"
      }
    }],
    type: "structure"
  };
  var _default = FormRole;
  exports.default = _default;
});
unwrapExports(FormRole_1);
var GridRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var GridRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "grid"
      }
    }],
    type: "widget"
  };
  var _default = GridRole;
  exports.default = _default;
});
unwrapExports(GridRole_1);
var GroupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var GroupRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "group"
      }
    }],
    type: "structure"
  };
  var _default = GroupRole;
  exports.default = _default;
});
unwrapExports(GroupRole_1);
var HeadingRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var HeadingRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "heading"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h1"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h2"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h3"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h4"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h5"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h6"
      }
    }],
    type: "structure"
  };
  var _default = HeadingRole;
  exports.default = _default;
});
unwrapExports(HeadingRole_1);
var IframePresentationalRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var IframePresentationalRole = {
    relatedConcepts: [],
    type: "window"
  };
  var _default = IframePresentationalRole;
  exports.default = _default;
});
unwrapExports(IframePresentationalRole_1);
var IframeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var IframeRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "iframe"
      }
    }],
    type: "window"
  };
  var _default = IframeRole;
  exports.default = _default;
});
unwrapExports(IframeRole_1);
var IgnoredRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var IgnoredRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = IgnoredRole;
  exports.default = _default;
});
unwrapExports(IgnoredRole_1);
var ImageMapLinkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ImageMapLinkRole = {
    relatedConcepts: [],
    type: "widget"
  };
  var _default = ImageMapLinkRole;
  exports.default = _default;
});
unwrapExports(ImageMapLinkRole_1);
var ImageMapRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ImageMapRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "img",
        attributes: [{
          name: "usemap"
        }]
      }
    }],
    type: "structure"
  };
  var _default = ImageMapRole;
  exports.default = _default;
});
unwrapExports(ImageMapRole_1);
var ImageRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ImageRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "img"
      }
    }, {
      module: "HTML",
      concept: {
        name: "img"
      }
    }],
    type: "structure"
  };
  var _default = ImageRole;
  exports.default = _default;
});
unwrapExports(ImageRole_1);
var InlineTextBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var InlineTextBoxRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "input"
      }
    }],
    type: "widget"
  };
  var _default = InlineTextBoxRole;
  exports.default = _default;
});
unwrapExports(InlineTextBoxRole_1);
var InputTimeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var InputTimeRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "time"
        }]
      }
    }],
    type: "widget"
  };
  var _default = InputTimeRole;
  exports.default = _default;
});
unwrapExports(InputTimeRole_1);
var LabelRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var LabelRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "label"
      }
    }],
    type: "structure"
  };
  var _default = LabelRole;
  exports.default = _default;
});
unwrapExports(LabelRole_1);
var LegendRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var LegendRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "legend"
      }
    }],
    type: "structure"
  };
  var _default = LegendRole;
  exports.default = _default;
});
unwrapExports(LegendRole_1);
var LineBreakRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var LineBreakRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "br"
      }
    }],
    type: "structure"
  };
  var _default = LineBreakRole;
  exports.default = _default;
});
unwrapExports(LineBreakRole_1);
var LinkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var LinkRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "link"
      }
    }, {
      module: "HTML",
      concept: {
        name: "a",
        attributes: [{
          name: "href"
        }]
      }
    }],
    type: "widget"
  };
  var _default = LinkRole;
  exports.default = _default;
});
unwrapExports(LinkRole_1);
var ListBoxOptionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ListBoxOptionRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "option"
      }
    }, {
      module: "HTML",
      concept: {
        name: "option"
      }
    }],
    type: "widget"
  };
  var _default = ListBoxOptionRole;
  exports.default = _default;
});
unwrapExports(ListBoxOptionRole_1);
var ListBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ListBoxRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "listbox"
      }
    }, {
      module: "HTML",
      concept: {
        name: "datalist"
      }
    }, {
      module: "HTML",
      concept: {
        name: "select"
      }
    }],
    type: "widget"
  };
  var _default = ListBoxRole;
  exports.default = _default;
});
unwrapExports(ListBoxRole_1);
var ListItemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ListItemRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "listitem"
      }
    }, {
      module: "HTML",
      concept: {
        name: "li"
      }
    }],
    type: "structure"
  };
  var _default = ListItemRole;
  exports.default = _default;
});
unwrapExports(ListItemRole_1);
var ListMarkerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ListMarkerRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = ListMarkerRole;
  exports.default = _default;
});
unwrapExports(ListMarkerRole_1);
var ListRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ListRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "list"
      }
    }, {
      module: "HTML",
      concept: {
        name: "ul"
      }
    }, {
      module: "HTML",
      concept: {
        name: "ol"
      }
    }],
    type: "structure"
  };
  var _default = ListRole;
  exports.default = _default;
});
unwrapExports(ListRole_1);
var LogRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var LogRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "log"
      }
    }],
    type: "structure"
  };
  var _default = LogRole;
  exports.default = _default;
});
unwrapExports(LogRole_1);
var MainRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MainRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "main"
      }
    }, {
      module: "HTML",
      concept: {
        name: "main"
      }
    }],
    type: "structure"
  };
  var _default = MainRole;
  exports.default = _default;
});
unwrapExports(MainRole_1);
var MarkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MarkRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "mark"
      }
    }],
    type: "structure"
  };
  var _default = MarkRole;
  exports.default = _default;
});
unwrapExports(MarkRole_1);
var MarqueeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MarqueeRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "marquee"
      }
    }, {
      module: "HTML",
      concept: {
        name: "marquee"
      }
    }],
    type: "structure"
  };
  var _default = MarqueeRole;
  exports.default = _default;
});
unwrapExports(MarqueeRole_1);
var MathRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MathRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "math"
      }
    }],
    type: "structure"
  };
  var _default = MathRole;
  exports.default = _default;
});
unwrapExports(MathRole_1);
var MenuBarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuBarRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "menubar"
      }
    }],
    type: "structure"
  };
  var _default = MenuBarRole;
  exports.default = _default;
});
unwrapExports(MenuBarRole_1);
var MenuButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuButtonRole = {
    relatedConcepts: [],
    type: "widget"
  };
  var _default = MenuButtonRole;
  exports.default = _default;
});
unwrapExports(MenuButtonRole_1);
var MenuItemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuItemRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "menuitem"
      }
    }, {
      module: "HTML",
      concept: {
        name: "menuitem"
      }
    }],
    type: "widget"
  };
  var _default = MenuItemRole;
  exports.default = _default;
});
unwrapExports(MenuItemRole_1);
var MenuItemCheckBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuItemCheckBoxRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "menuitemcheckbox"
      }
    }],
    type: "widget"
  };
  var _default = MenuItemCheckBoxRole;
  exports.default = _default;
});
unwrapExports(MenuItemCheckBoxRole_1);
var MenuItemRadioRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuItemRadioRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "menuitemradio"
      }
    }],
    type: "widget"
  };
  var _default = MenuItemRadioRole;
  exports.default = _default;
});
unwrapExports(MenuItemRadioRole_1);
var MenuListOptionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuListOptionRole = {
    relatedConcepts: [],
    type: "widget"
  };
  var _default = MenuListOptionRole;
  exports.default = _default;
});
unwrapExports(MenuListOptionRole_1);
var MenuListPopupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuListPopupRole = {
    relatedConcepts: [],
    type: "widget"
  };
  var _default = MenuListPopupRole;
  exports.default = _default;
});
unwrapExports(MenuListPopupRole_1);
var MenuRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "menu"
      }
    }, {
      module: "HTML",
      concept: {
        name: "menu"
      }
    }],
    type: "structure"
  };
  var _default = MenuRole;
  exports.default = _default;
});
unwrapExports(MenuRole_1);
var MeterRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MeterRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "meter"
      }
    }],
    type: "structure"
  };
  var _default = MeterRole;
  exports.default = _default;
});
unwrapExports(MeterRole_1);
var NavigationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var NavigationRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "navigation"
      }
    }, {
      module: "HTML",
      concept: {
        name: "nav"
      }
    }],
    type: "structure"
  };
  var _default = NavigationRole;
  exports.default = _default;
});
unwrapExports(NavigationRole_1);
var NoneRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var NoneRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "none"
      }
    }],
    type: "structure"
  };
  var _default = NoneRole;
  exports.default = _default;
});
unwrapExports(NoneRole_1);
var NoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var NoteRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "note"
      }
    }],
    type: "structure"
  };
  var _default = NoteRole;
  exports.default = _default;
});
unwrapExports(NoteRole_1);
var OutlineRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var OutlineRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = OutlineRole;
  exports.default = _default;
});
unwrapExports(OutlineRole_1);
var ParagraphRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ParagraphRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "p"
      }
    }],
    type: "structure"
  };
  var _default = ParagraphRole;
  exports.default = _default;
});
unwrapExports(ParagraphRole_1);
var PopUpButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var PopUpButtonRole = {
    relatedConcepts: [],
    type: "widget"
  };
  var _default = PopUpButtonRole;
  exports.default = _default;
});
unwrapExports(PopUpButtonRole_1);
var PreRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var PreRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "pre"
      }
    }],
    type: "structure"
  };
  var _default = PreRole;
  exports.default = _default;
});
unwrapExports(PreRole_1);
var PresentationalRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var PresentationalRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "presentation"
      }
    }],
    type: "structure"
  };
  var _default = PresentationalRole;
  exports.default = _default;
});
unwrapExports(PresentationalRole_1);
var ProgressIndicatorRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ProgressIndicatorRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "progressbar"
      }
    }, {
      module: "HTML",
      concept: {
        name: "progress"
      }
    }],
    type: "structure"
  };
  var _default = ProgressIndicatorRole;
  exports.default = _default;
});
unwrapExports(ProgressIndicatorRole_1);
var RadioButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RadioButtonRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "radio"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "radio"
        }]
      }
    }],
    type: "widget"
  };
  var _default = RadioButtonRole;
  exports.default = _default;
});
unwrapExports(RadioButtonRole_1);
var RadioGroupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RadioGroupRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "radiogroup"
      }
    }],
    type: "structure"
  };
  var _default = RadioGroupRole;
  exports.default = _default;
});
unwrapExports(RadioGroupRole_1);
var RegionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RegionRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "region"
      }
    }],
    type: "structure"
  };
  var _default = RegionRole;
  exports.default = _default;
});
unwrapExports(RegionRole_1);
var RootWebAreaRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RootWebAreaRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = RootWebAreaRole;
  exports.default = _default;
});
unwrapExports(RootWebAreaRole_1);
var RowHeaderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RowHeaderRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "rowheader"
      }
    }, {
      module: "HTML",
      concept: {
        name: "th",
        attributes: [{
          name: "scope",
          value: "row"
        }]
      }
    }],
    type: "widget"
  };
  var _default = RowHeaderRole;
  exports.default = _default;
});
unwrapExports(RowHeaderRole_1);
var RowRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RowRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "row"
      }
    }, {
      module: "HTML",
      concept: {
        name: "tr"
      }
    }],
    type: "structure"
  };
  var _default = RowRole;
  exports.default = _default;
});
unwrapExports(RowRole_1);
var RubyRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RubyRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "ruby"
      }
    }],
    type: "structure"
  };
  var _default = RubyRole;
  exports.default = _default;
});
unwrapExports(RubyRole_1);
var RulerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RulerRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = RulerRole;
  exports.default = _default;
});
unwrapExports(RulerRole_1);
var ScrollAreaRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ScrollAreaRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = ScrollAreaRole;
  exports.default = _default;
});
unwrapExports(ScrollAreaRole_1);
var ScrollBarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ScrollBarRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "scrollbar"
      }
    }],
    type: "widget"
  };
  var _default = ScrollBarRole;
  exports.default = _default;
});
unwrapExports(ScrollBarRole_1);
var SeamlessWebAreaRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SeamlessWebAreaRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = SeamlessWebAreaRole;
  exports.default = _default;
});
unwrapExports(SeamlessWebAreaRole_1);
var SearchRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SearchRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "search"
      }
    }],
    type: "structure"
  };
  var _default = SearchRole;
  exports.default = _default;
});
unwrapExports(SearchRole_1);
var SearchBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SearchBoxRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "searchbox"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "search"
        }]
      }
    }],
    type: "widget"
  };
  var _default = SearchBoxRole;
  exports.default = _default;
});
unwrapExports(SearchBoxRole_1);
var SliderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SliderRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "slider"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "range"
        }]
      }
    }],
    type: "widget"
  };
  var _default = SliderRole;
  exports.default = _default;
});
unwrapExports(SliderRole_1);
var SliderThumbRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SliderThumbRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = SliderThumbRole;
  exports.default = _default;
});
unwrapExports(SliderThumbRole_1);
var SpinButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SpinButtonRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "spinbutton"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "number"
        }]
      }
    }],
    type: "widget"
  };
  var _default = SpinButtonRole;
  exports.default = _default;
});
unwrapExports(SpinButtonRole_1);
var SpinButtonPartRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SpinButtonPartRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = SpinButtonPartRole;
  exports.default = _default;
});
unwrapExports(SpinButtonPartRole_1);
var SplitterRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SplitterRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "separator"
      }
    }],
    type: "widget"
  };
  var _default = SplitterRole;
  exports.default = _default;
});
unwrapExports(SplitterRole_1);
var StaticTextRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var StaticTextRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = StaticTextRole;
  exports.default = _default;
});
unwrapExports(StaticTextRole_1);
var StatusRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var StatusRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "status"
      }
    }],
    type: "structure"
  };
  var _default = StatusRole;
  exports.default = _default;
});
unwrapExports(StatusRole_1);
var SVGRootRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SVGRootRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = SVGRootRole;
  exports.default = _default;
});
unwrapExports(SVGRootRole_1);
var SwitchRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SwitchRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "switch"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "checkbox"
        }]
      }
    }],
    type: "widget"
  };
  var _default = SwitchRole;
  exports.default = _default;
});
unwrapExports(SwitchRole_1);
var TabGroupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TabGroupRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tablist"
      }
    }],
    type: "structure"
  };
  var _default = TabGroupRole;
  exports.default = _default;
});
unwrapExports(TabGroupRole_1);
var TabRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TabRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tab"
      }
    }],
    type: "widget"
  };
  var _default = TabRole;
  exports.default = _default;
});
unwrapExports(TabRole_1);
var TableHeaderContainerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TableHeaderContainerRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = TableHeaderContainerRole;
  exports.default = _default;
});
unwrapExports(TableHeaderContainerRole_1);
var TableRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TableRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "table"
      }
    }, {
      module: "HTML",
      concept: {
        name: "table"
      }
    }],
    type: "structure"
  };
  var _default = TableRole;
  exports.default = _default;
});
unwrapExports(TableRole_1);
var TabListRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TabListRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tablist"
      }
    }],
    type: "structure"
  };
  var _default = TabListRole;
  exports.default = _default;
});
unwrapExports(TabListRole_1);
var TabPanelRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TabPanelRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tabpanel"
      }
    }],
    type: "structure"
  };
  var _default = TabPanelRole;
  exports.default = _default;
});
unwrapExports(TabPanelRole_1);
var TermRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TermRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "term"
      }
    }],
    type: "structure"
  };
  var _default = TermRole;
  exports.default = _default;
});
unwrapExports(TermRole_1);
var TextFieldRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TextFieldRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "textbox"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "text"
        }]
      }
    }],
    type: "widget"
  };
  var _default = TextFieldRole;
  exports.default = _default;
});
unwrapExports(TextFieldRole_1);
var TimeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TimeRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "time"
      }
    }],
    type: "structure"
  };
  var _default = TimeRole;
  exports.default = _default;
});
unwrapExports(TimeRole_1);
var TimerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TimerRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "timer"
      }
    }],
    type: "structure"
  };
  var _default = TimerRole;
  exports.default = _default;
});
unwrapExports(TimerRole_1);
var ToggleButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ToggleButtonRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        attributes: [{
          name: "aria-pressed"
        }]
      }
    }],
    type: "widget"
  };
  var _default = ToggleButtonRole;
  exports.default = _default;
});
unwrapExports(ToggleButtonRole_1);
var ToolbarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ToolbarRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "toolbar"
      }
    }],
    type: "structure"
  };
  var _default = ToolbarRole;
  exports.default = _default;
});
unwrapExports(ToolbarRole_1);
var TreeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TreeRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tree"
      }
    }],
    type: "widget"
  };
  var _default = TreeRole;
  exports.default = _default;
});
unwrapExports(TreeRole_1);
var TreeGridRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TreeGridRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "treegrid"
      }
    }],
    type: "widget"
  };
  var _default = TreeGridRole;
  exports.default = _default;
});
unwrapExports(TreeGridRole_1);
var TreeItemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TreeItemRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "treeitem"
      }
    }],
    type: "widget"
  };
  var _default = TreeItemRole;
  exports.default = _default;
});
unwrapExports(TreeItemRole_1);
var UserInterfaceTooltipRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var UserInterfaceTooltipRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tooltip"
      }
    }],
    type: "structure"
  };
  var _default = UserInterfaceTooltipRole;
  exports.default = _default;
});
unwrapExports(UserInterfaceTooltipRole_1);
var VideoRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var VideoRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "video"
      }
    }],
    type: "widget"
  };
  var _default = VideoRole;
  exports.default = _default;
});
unwrapExports(VideoRole_1);
var WebAreaRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var WebAreaRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default = WebAreaRole;
  exports.default = _default;
});
unwrapExports(WebAreaRole_1);
var WindowRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var WindowRole = {
    relatedConcepts: [],
    type: "window"
  };
  var _default = WindowRole;
  exports.default = _default;
});
unwrapExports(WindowRole_1);
var AXObjectsMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
  var _AbbrRole = _interopRequireDefault(AbbrRole_1);
  var _AlertDialogRole = _interopRequireDefault(AlertDialogRole_1);
  var _AlertRole = _interopRequireDefault(AlertRole_1);
  var _AnnotationRole = _interopRequireDefault(AnnotationRole_1);
  var _ApplicationRole = _interopRequireDefault(ApplicationRole_1);
  var _ArticleRole = _interopRequireDefault(ArticleRole_1);
  var _AudioRole = _interopRequireDefault(AudioRole_1);
  var _BannerRole = _interopRequireDefault(BannerRole_1);
  var _BlockquoteRole = _interopRequireDefault(BlockquoteRole_1);
  var _BusyIndicatorRole = _interopRequireDefault(BusyIndicatorRole_1);
  var _ButtonRole = _interopRequireDefault(ButtonRole_1);
  var _CanvasRole = _interopRequireDefault(CanvasRole_1);
  var _CaptionRole = _interopRequireDefault(CaptionRole_1);
  var _CellRole = _interopRequireDefault(CellRole_1);
  var _CheckBoxRole = _interopRequireDefault(CheckBoxRole_1);
  var _ColorWellRole = _interopRequireDefault(ColorWellRole_1);
  var _ColumnHeaderRole = _interopRequireDefault(ColumnHeaderRole_1);
  var _ColumnRole = _interopRequireDefault(ColumnRole_1);
  var _ComboBoxRole = _interopRequireDefault(ComboBoxRole_1);
  var _ComplementaryRole = _interopRequireDefault(ComplementaryRole_1);
  var _ContentInfoRole = _interopRequireDefault(ContentInfoRole_1);
  var _DateRole = _interopRequireDefault(DateRole_1);
  var _DateTimeRole = _interopRequireDefault(DateTimeRole_1);
  var _DefinitionRole = _interopRequireDefault(DefinitionRole_1);
  var _DescriptionListDetailRole = _interopRequireDefault(DescriptionListDetailRole_1);
  var _DescriptionListRole = _interopRequireDefault(DescriptionListRole_1);
  var _DescriptionListTermRole = _interopRequireDefault(DescriptionListTermRole_1);
  var _DetailsRole = _interopRequireDefault(DetailsRole_1);
  var _DialogRole = _interopRequireDefault(DialogRole_1);
  var _DirectoryRole = _interopRequireDefault(DirectoryRole_1);
  var _DisclosureTriangleRole = _interopRequireDefault(DisclosureTriangleRole_1);
  var _DivRole = _interopRequireDefault(DivRole_1);
  var _DocumentRole = _interopRequireDefault(DocumentRole_1);
  var _EmbeddedObjectRole = _interopRequireDefault(EmbeddedObjectRole_1);
  var _FeedRole = _interopRequireDefault(FeedRole_1);
  var _FigcaptionRole = _interopRequireDefault(FigcaptionRole_1);
  var _FigureRole = _interopRequireDefault(FigureRole_1);
  var _FooterRole = _interopRequireDefault(FooterRole_1);
  var _FormRole = _interopRequireDefault(FormRole_1);
  var _GridRole = _interopRequireDefault(GridRole_1);
  var _GroupRole = _interopRequireDefault(GroupRole_1);
  var _HeadingRole = _interopRequireDefault(HeadingRole_1);
  var _IframePresentationalRole = _interopRequireDefault(IframePresentationalRole_1);
  var _IframeRole = _interopRequireDefault(IframeRole_1);
  var _IgnoredRole = _interopRequireDefault(IgnoredRole_1);
  var _ImageMapLinkRole = _interopRequireDefault(ImageMapLinkRole_1);
  var _ImageMapRole = _interopRequireDefault(ImageMapRole_1);
  var _ImageRole = _interopRequireDefault(ImageRole_1);
  var _InlineTextBoxRole = _interopRequireDefault(InlineTextBoxRole_1);
  var _InputTimeRole = _interopRequireDefault(InputTimeRole_1);
  var _LabelRole = _interopRequireDefault(LabelRole_1);
  var _LegendRole = _interopRequireDefault(LegendRole_1);
  var _LineBreakRole = _interopRequireDefault(LineBreakRole_1);
  var _LinkRole = _interopRequireDefault(LinkRole_1);
  var _ListBoxOptionRole = _interopRequireDefault(ListBoxOptionRole_1);
  var _ListBoxRole = _interopRequireDefault(ListBoxRole_1);
  var _ListItemRole = _interopRequireDefault(ListItemRole_1);
  var _ListMarkerRole = _interopRequireDefault(ListMarkerRole_1);
  var _ListRole = _interopRequireDefault(ListRole_1);
  var _LogRole = _interopRequireDefault(LogRole_1);
  var _MainRole = _interopRequireDefault(MainRole_1);
  var _MarkRole = _interopRequireDefault(MarkRole_1);
  var _MarqueeRole = _interopRequireDefault(MarqueeRole_1);
  var _MathRole = _interopRequireDefault(MathRole_1);
  var _MenuBarRole = _interopRequireDefault(MenuBarRole_1);
  var _MenuButtonRole = _interopRequireDefault(MenuButtonRole_1);
  var _MenuItemRole = _interopRequireDefault(MenuItemRole_1);
  var _MenuItemCheckBoxRole = _interopRequireDefault(MenuItemCheckBoxRole_1);
  var _MenuItemRadioRole = _interopRequireDefault(MenuItemRadioRole_1);
  var _MenuListOptionRole = _interopRequireDefault(MenuListOptionRole_1);
  var _MenuListPopupRole = _interopRequireDefault(MenuListPopupRole_1);
  var _MenuRole = _interopRequireDefault(MenuRole_1);
  var _MeterRole = _interopRequireDefault(MeterRole_1);
  var _NavigationRole = _interopRequireDefault(NavigationRole_1);
  var _NoneRole = _interopRequireDefault(NoneRole_1);
  var _NoteRole = _interopRequireDefault(NoteRole_1);
  var _OutlineRole = _interopRequireDefault(OutlineRole_1);
  var _ParagraphRole = _interopRequireDefault(ParagraphRole_1);
  var _PopUpButtonRole = _interopRequireDefault(PopUpButtonRole_1);
  var _PreRole = _interopRequireDefault(PreRole_1);
  var _PresentationalRole = _interopRequireDefault(PresentationalRole_1);
  var _ProgressIndicatorRole = _interopRequireDefault(ProgressIndicatorRole_1);
  var _RadioButtonRole = _interopRequireDefault(RadioButtonRole_1);
  var _RadioGroupRole = _interopRequireDefault(RadioGroupRole_1);
  var _RegionRole = _interopRequireDefault(RegionRole_1);
  var _RootWebAreaRole = _interopRequireDefault(RootWebAreaRole_1);
  var _RowHeaderRole = _interopRequireDefault(RowHeaderRole_1);
  var _RowRole = _interopRequireDefault(RowRole_1);
  var _RubyRole = _interopRequireDefault(RubyRole_1);
  var _RulerRole = _interopRequireDefault(RulerRole_1);
  var _ScrollAreaRole = _interopRequireDefault(ScrollAreaRole_1);
  var _ScrollBarRole = _interopRequireDefault(ScrollBarRole_1);
  var _SeamlessWebAreaRole = _interopRequireDefault(SeamlessWebAreaRole_1);
  var _SearchRole = _interopRequireDefault(SearchRole_1);
  var _SearchBoxRole = _interopRequireDefault(SearchBoxRole_1);
  var _SliderRole = _interopRequireDefault(SliderRole_1);
  var _SliderThumbRole = _interopRequireDefault(SliderThumbRole_1);
  var _SpinButtonRole = _interopRequireDefault(SpinButtonRole_1);
  var _SpinButtonPartRole = _interopRequireDefault(SpinButtonPartRole_1);
  var _SplitterRole = _interopRequireDefault(SplitterRole_1);
  var _StaticTextRole = _interopRequireDefault(StaticTextRole_1);
  var _StatusRole = _interopRequireDefault(StatusRole_1);
  var _SVGRootRole = _interopRequireDefault(SVGRootRole_1);
  var _SwitchRole = _interopRequireDefault(SwitchRole_1);
  var _TabGroupRole = _interopRequireDefault(TabGroupRole_1);
  var _TabRole = _interopRequireDefault(TabRole_1);
  var _TableHeaderContainerRole = _interopRequireDefault(TableHeaderContainerRole_1);
  var _TableRole = _interopRequireDefault(TableRole_1);
  var _TabListRole = _interopRequireDefault(TabListRole_1);
  var _TabPanelRole = _interopRequireDefault(TabPanelRole_1);
  var _TermRole = _interopRequireDefault(TermRole_1);
  var _TextFieldRole = _interopRequireDefault(TextFieldRole_1);
  var _TimeRole = _interopRequireDefault(TimeRole_1);
  var _TimerRole = _interopRequireDefault(TimerRole_1);
  var _ToggleButtonRole = _interopRequireDefault(ToggleButtonRole_1);
  var _ToolbarRole = _interopRequireDefault(ToolbarRole_1);
  var _TreeRole = _interopRequireDefault(TreeRole_1);
  var _TreeGridRole = _interopRequireDefault(TreeGridRole_1);
  var _TreeItemRole = _interopRequireDefault(TreeItemRole_1);
  var _UserInterfaceTooltipRole = _interopRequireDefault(UserInterfaceTooltipRole_1);
  var _VideoRole = _interopRequireDefault(VideoRole_1);
  var _WebAreaRole = _interopRequireDefault(WebAreaRole_1);
  var _WindowRole = _interopRequireDefault(WindowRole_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i) {
    var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i2 == null)
      return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _s2, _e2;
    try {
      for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
        _arr.push(_s2.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i2["return"] != null)
          _i2["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it3 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it3) {
      if (Array.isArray(o) || (it3 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it3)
          o = it3;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it3 = it3.call(o);
    }, n: function n() {
      var step = it3.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it3.return != null)
          it3.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var AXObjects = [["AbbrRole", _AbbrRole.default], ["AlertDialogRole", _AlertDialogRole.default], ["AlertRole", _AlertRole.default], ["AnnotationRole", _AnnotationRole.default], ["ApplicationRole", _ApplicationRole.default], ["ArticleRole", _ArticleRole.default], ["AudioRole", _AudioRole.default], ["BannerRole", _BannerRole.default], ["BlockquoteRole", _BlockquoteRole.default], ["BusyIndicatorRole", _BusyIndicatorRole.default], ["ButtonRole", _ButtonRole.default], ["CanvasRole", _CanvasRole.default], ["CaptionRole", _CaptionRole.default], ["CellRole", _CellRole.default], ["CheckBoxRole", _CheckBoxRole.default], ["ColorWellRole", _ColorWellRole.default], ["ColumnHeaderRole", _ColumnHeaderRole.default], ["ColumnRole", _ColumnRole.default], ["ComboBoxRole", _ComboBoxRole.default], ["ComplementaryRole", _ComplementaryRole.default], ["ContentInfoRole", _ContentInfoRole.default], ["DateRole", _DateRole.default], ["DateTimeRole", _DateTimeRole.default], ["DefinitionRole", _DefinitionRole.default], ["DescriptionListDetailRole", _DescriptionListDetailRole.default], ["DescriptionListRole", _DescriptionListRole.default], ["DescriptionListTermRole", _DescriptionListTermRole.default], ["DetailsRole", _DetailsRole.default], ["DialogRole", _DialogRole.default], ["DirectoryRole", _DirectoryRole.default], ["DisclosureTriangleRole", _DisclosureTriangleRole.default], ["DivRole", _DivRole.default], ["DocumentRole", _DocumentRole.default], ["EmbeddedObjectRole", _EmbeddedObjectRole.default], ["FeedRole", _FeedRole.default], ["FigcaptionRole", _FigcaptionRole.default], ["FigureRole", _FigureRole.default], ["FooterRole", _FooterRole.default], ["FormRole", _FormRole.default], ["GridRole", _GridRole.default], ["GroupRole", _GroupRole.default], ["HeadingRole", _HeadingRole.default], ["IframePresentationalRole", _IframePresentationalRole.default], ["IframeRole", _IframeRole.default], ["IgnoredRole", _IgnoredRole.default], ["ImageMapLinkRole", _ImageMapLinkRole.default], ["ImageMapRole", _ImageMapRole.default], ["ImageRole", _ImageRole.default], ["InlineTextBoxRole", _InlineTextBoxRole.default], ["InputTimeRole", _InputTimeRole.default], ["LabelRole", _LabelRole.default], ["LegendRole", _LegendRole.default], ["LineBreakRole", _LineBreakRole.default], ["LinkRole", _LinkRole.default], ["ListBoxOptionRole", _ListBoxOptionRole.default], ["ListBoxRole", _ListBoxRole.default], ["ListItemRole", _ListItemRole.default], ["ListMarkerRole", _ListMarkerRole.default], ["ListRole", _ListRole.default], ["LogRole", _LogRole.default], ["MainRole", _MainRole.default], ["MarkRole", _MarkRole.default], ["MarqueeRole", _MarqueeRole.default], ["MathRole", _MathRole.default], ["MenuBarRole", _MenuBarRole.default], ["MenuButtonRole", _MenuButtonRole.default], ["MenuItemRole", _MenuItemRole.default], ["MenuItemCheckBoxRole", _MenuItemCheckBoxRole.default], ["MenuItemRadioRole", _MenuItemRadioRole.default], ["MenuListOptionRole", _MenuListOptionRole.default], ["MenuListPopupRole", _MenuListPopupRole.default], ["MenuRole", _MenuRole.default], ["MeterRole", _MeterRole.default], ["NavigationRole", _NavigationRole.default], ["NoneRole", _NoneRole.default], ["NoteRole", _NoteRole.default], ["OutlineRole", _OutlineRole.default], ["ParagraphRole", _ParagraphRole.default], ["PopUpButtonRole", _PopUpButtonRole.default], ["PreRole", _PreRole.default], ["PresentationalRole", _PresentationalRole.default], ["ProgressIndicatorRole", _ProgressIndicatorRole.default], ["RadioButtonRole", _RadioButtonRole.default], ["RadioGroupRole", _RadioGroupRole.default], ["RegionRole", _RegionRole.default], ["RootWebAreaRole", _RootWebAreaRole.default], ["RowHeaderRole", _RowHeaderRole.default], ["RowRole", _RowRole.default], ["RubyRole", _RubyRole.default], ["RulerRole", _RulerRole.default], ["ScrollAreaRole", _ScrollAreaRole.default], ["ScrollBarRole", _ScrollBarRole.default], ["SeamlessWebAreaRole", _SeamlessWebAreaRole.default], ["SearchRole", _SearchRole.default], ["SearchBoxRole", _SearchBoxRole.default], ["SliderRole", _SliderRole.default], ["SliderThumbRole", _SliderThumbRole.default], ["SpinButtonRole", _SpinButtonRole.default], ["SpinButtonPartRole", _SpinButtonPartRole.default], ["SplitterRole", _SplitterRole.default], ["StaticTextRole", _StaticTextRole.default], ["StatusRole", _StatusRole.default], ["SVGRootRole", _SVGRootRole.default], ["SwitchRole", _SwitchRole.default], ["TabGroupRole", _TabGroupRole.default], ["TabRole", _TabRole.default], ["TableHeaderContainerRole", _TableHeaderContainerRole.default], ["TableRole", _TableRole.default], ["TabListRole", _TabListRole.default], ["TabPanelRole", _TabPanelRole.default], ["TermRole", _TermRole.default], ["TextFieldRole", _TextFieldRole.default], ["TimeRole", _TimeRole.default], ["TimerRole", _TimerRole.default], ["ToggleButtonRole", _ToggleButtonRole.default], ["ToolbarRole", _ToolbarRole.default], ["TreeRole", _TreeRole.default], ["TreeGridRole", _TreeGridRole.default], ["TreeItemRole", _TreeItemRole.default], ["UserInterfaceTooltipRole", _UserInterfaceTooltipRole.default], ["VideoRole", _VideoRole.default], ["WebAreaRole", _WebAreaRole.default], ["WindowRole", _WindowRole.default]];
  var AXObjectsMap = {
    entries: function entries() {
      return AXObjects;
    },
    forEach: function forEach3(fn2) {
      var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var _iterator = _createForOfIteratorHelper(AXObjects), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values2 = _step$value[1];
          fn2.call(thisArg, values2, key, AXObjects);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    get: function get(key) {
      var item = AXObjects.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has(key) {
      return !!this.get(key);
    },
    keys: function keys3() {
      return AXObjects.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return AXObjects.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default = (0, _iterationDecorator.default)(AXObjectsMap, AXObjectsMap.entries());
  exports.default = _default;
});
unwrapExports(AXObjectsMap_1);
var AXObjectElementMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
  var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i) {
    var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i2 == null)
      return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _s2, _e2;
    try {
      for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
        _arr.push(_s2.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i2["return"] != null)
          _i2["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it3 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it3) {
      if (Array.isArray(o) || (it3 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it3)
          o = it3;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it3 = it3.call(o);
    }, n: function n() {
      var step = it3.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it3.return != null)
          it3.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var AXObjectElements = [];
  var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
  try {
    var _loop = function _loop2() {
      var _step$value = _slicedToArray(_step.value, 2), name3 = _step$value[0], def = _step$value[1];
      var relatedConcepts = def.relatedConcepts;
      if (Array.isArray(relatedConcepts)) {
        relatedConcepts.forEach(function(relation) {
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept) {
              var index2 = AXObjectElements.findIndex(function(_ref5) {
                var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                return key === name3;
              });
              if (index2 === -1) {
                AXObjectElements.push([name3, []]);
                index2 = AXObjectElements.length - 1;
              }
              AXObjectElements[index2][1].push(concept);
            }
          }
        });
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var AXObjectElementMap = {
    entries: function entries() {
      return AXObjectElements;
    },
    forEach: function forEach3(fn2) {
      var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var _iterator2 = _createForOfIteratorHelper(AXObjectElements), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values2 = _step2$value[1];
          fn2.call(thisArg, values2, key, AXObjectElements);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    get: function get(key) {
      var item = AXObjectElements.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has(key) {
      return !!this.get(key);
    },
    keys: function keys3() {
      return AXObjectElements.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return AXObjectElements.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default = (0, _iterationDecorator.default)(AXObjectElementMap, AXObjectElementMap.entries());
  exports.default = _default;
});
unwrapExports(AXObjectElementMap_1);
var AXObjectRoleMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
  var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i) {
    var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i2 == null)
      return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _s2, _e2;
    try {
      for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
        _arr.push(_s2.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i2["return"] != null)
          _i2["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it3 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it3) {
      if (Array.isArray(o) || (it3 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it3)
          o = it3;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it3 = it3.call(o);
    }, n: function n() {
      var step = it3.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it3.return != null)
          it3.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var AXObjectRoleElements = [];
  var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
  try {
    var _loop = function _loop2() {
      var _step$value = _slicedToArray(_step.value, 2), name3 = _step$value[0], def = _step$value[1];
      var relatedConcepts = def.relatedConcepts;
      if (Array.isArray(relatedConcepts)) {
        relatedConcepts.forEach(function(relation) {
          if (relation.module === "ARIA") {
            var concept = relation.concept;
            if (concept) {
              var index2 = AXObjectRoleElements.findIndex(function(_ref5) {
                var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                return key === name3;
              });
              if (index2 === -1) {
                AXObjectRoleElements.push([name3, []]);
                index2 = AXObjectRoleElements.length - 1;
              }
              AXObjectRoleElements[index2][1].push(concept);
            }
          }
        });
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var AXObjectRoleMap = {
    entries: function entries() {
      return AXObjectRoleElements;
    },
    forEach: function forEach3(fn2) {
      var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var _iterator2 = _createForOfIteratorHelper(AXObjectRoleElements), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values2 = _step2$value[1];
          fn2.call(thisArg, values2, key, AXObjectRoleElements);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    get: function get(key) {
      var item = AXObjectRoleElements.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has(key) {
      return !!this.get(key);
    },
    keys: function keys3() {
      return AXObjectRoleElements.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return AXObjectRoleElements.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default = (0, _iterationDecorator.default)(AXObjectRoleMap, AXObjectRoleMap.entries());
  exports.default = _default;
});
unwrapExports(AXObjectRoleMap_1);
var elementAXObjectMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
  var _deepEqual = _interopRequireDefault(deepEqual);
  var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i) {
    var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i2 == null)
      return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _s2, _e2;
    try {
      for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
        _arr.push(_s2.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i2["return"] != null)
          _i2["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it3 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it3) {
      if (Array.isArray(o) || (it3 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it3)
          o = it3;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it3 = it3.call(o);
    }, n: function n() {
      var step = it3.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it3.return != null)
          it3.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var elementAXObjects = [];
  var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
  try {
    var _loop = function _loop2() {
      var _step$value = _slicedToArray(_step.value, 2), name3 = _step$value[0], def = _step$value[1];
      var relatedConcepts = def.relatedConcepts;
      if (Array.isArray(relatedConcepts)) {
        relatedConcepts.forEach(function(relation) {
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept != null) {
              var conceptStr = JSON.stringify(concept);
              var axObjects;
              var index2 = 0;
              for (; index2 < elementAXObjects.length; index2++) {
                var key = elementAXObjects[index2][0];
                if (JSON.stringify(key) === conceptStr) {
                  axObjects = elementAXObjects[index2][1];
                  break;
                }
              }
              if (!Array.isArray(axObjects)) {
                axObjects = [];
              }
              var loc = axObjects.findIndex(function(item) {
                return item === name3;
              });
              if (loc === -1) {
                axObjects.push(name3);
              }
              if (index2 < elementAXObjects.length) {
                elementAXObjects.splice(index2, 1, [concept, axObjects]);
              } else {
                elementAXObjects.push([concept, axObjects]);
              }
            }
          }
        });
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var elementAXObjectMap = {
    entries: function entries() {
      return elementAXObjects;
    },
    forEach: function forEach3(fn2) {
      var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var _iterator2 = _createForOfIteratorHelper(elementAXObjects), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values2 = _step2$value[1];
          fn2.call(thisArg, values2, key, elementAXObjects);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    get: function get(key) {
      var item = elementAXObjects.find(function(tuple) {
        return (0, _deepEqual.default)(key, tuple[0]) ? true : false;
      });
      return item && item[1];
    },
    has: function has(key) {
      return !!this.get(key);
    },
    keys: function keys3() {
      return elementAXObjects.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return elementAXObjects.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default = (0, _iterationDecorator.default)(elementAXObjectMap, elementAXObjectMap.entries());
  exports.default = _default;
});
unwrapExports(elementAXObjectMap_1);
var lib$1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.elementAXObjects = exports.AXObjects = exports.AXObjectRoles = exports.AXObjectElements = void 0;
  var _AXObjectElementMap = _interopRequireDefault(AXObjectElementMap_1);
  var _AXObjectRoleMap = _interopRequireDefault(AXObjectRoleMap_1);
  var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
  var _elementAXObjectMap = _interopRequireDefault(elementAXObjectMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var AXObjectElements = _AXObjectElementMap.default;
  exports.AXObjectElements = AXObjectElements;
  var AXObjectRoles = _AXObjectRoleMap.default;
  exports.AXObjectRoles = AXObjectRoles;
  var AXObjects = _AXObjectsMap.default;
  exports.AXObjects = AXObjects;
  var elementAXObjects = _elementAXObjectMap.default;
  exports.elementAXObjects = elementAXObjects;
});
unwrapExports(lib$1);
var lib_1$1 = lib$1.elementAXObjects;
var lib_2$1 = lib$1.AXObjects;
var lib_3$1 = lib$1.AXObjectRoles;
var lib_4$1 = lib$1.AXObjectElements;
var aria_roles = lib_1.keys();
var abstract_roles = new Set(aria_roles.filter((role) => lib_1.get(role).abstract));
var non_abstract_roles = aria_roles.filter((name3) => !abstract_roles.has(name3));
var non_interactive_roles = new Set(non_abstract_roles.filter((name3) => {
  const role = lib_1.get(name3);
  return (
    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
    !["toolbar", "tabpanel"].includes(name3) && !role.superClass.some((classes) => classes.includes("widget"))
  );
}).concat(
  // The `progressbar` is descended from `widget`, but in practice, its
  // value is always `readonly`, so we treat it as a non-interactive role.
  "progressbar"
));
var interactive_roles = new Set(non_abstract_roles.filter((name3) => !non_interactive_roles.has(name3)));
var non_interactive_element_role_schemas = [];
lib_3.entries().forEach(([schema2, roles]) => {
  if ([...roles].every((role) => role !== "generic" && non_interactive_roles.has(role))) {
    non_interactive_element_role_schemas.push(schema2);
  }
});
var interactive_element_role_schemas = [];
lib_3.entries().forEach(([schema2, roles]) => {
  if ([...roles].every((role) => interactive_roles.has(role))) {
    interactive_element_role_schemas.push(schema2);
  }
});
var interactive_ax_objects = new Set([...lib_2$1.keys()].filter((name3) => lib_2$1.get(name3).type === "widget"));
var non_interactive_ax_objects = new Set([...lib_2$1.keys()].filter((name3) => ["windows", "structure"].includes(lib_2$1.get(name3).type)));
var interactive_element_ax_object_schemas = [];
lib_1$1.entries().forEach(([schema2, ax_object]) => {
  if ([...ax_object].every((role) => interactive_ax_objects.has(role))) {
    interactive_element_ax_object_schemas.push(schema2);
  }
});
var non_interactive_element_ax_object_schemas = [];
lib_1$1.entries().forEach(([schema2, ax_object]) => {
  if ([...ax_object].every((role) => non_interactive_ax_objects.has(role))) {
    non_interactive_element_ax_object_schemas.push(schema2);
  }
});
var ElementInteractivity;
(function(ElementInteractivity2) {
  ElementInteractivity2["Interactive"] = "interactive";
  ElementInteractivity2["NonInteractive"] = "non-interactive";
  ElementInteractivity2["Static"] = "static";
})(ElementInteractivity || (ElementInteractivity = {}));
var aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(" ");
var aria_attribute_set = new Set(aria_attributes);
var aria_roles$1 = lib_1.keys();
var aria_role_set = new Set(aria_roles$1);
var TRUE = x`true`;
var FALSE = x`false`;
var svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(" ");
var svg_attribute_lookup = /* @__PURE__ */ new Map();
svg_attributes.forEach((name3) => {
  svg_attribute_lookup.set(name3.toLowerCase(), name3);
});
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
var attribute_lookup = {
  allowfullscreen: { property_name: "allowFullscreen", applies_to: ["iframe"] },
  allowpaymentrequest: { property_name: "allowPaymentRequest", applies_to: ["iframe"] },
  async: { applies_to: ["script"] },
  autofocus: { applies_to: ["button", "input", "keygen", "select", "textarea"] },
  autoplay: { applies_to: ["audio", "video"] },
  checked: { applies_to: ["input"] },
  controls: { applies_to: ["audio", "video"] },
  default: { applies_to: ["track"] },
  defer: { applies_to: ["script"] },
  disabled: {
    applies_to: [
      "button",
      "fieldset",
      "input",
      "keygen",
      "optgroup",
      "option",
      "select",
      "textarea"
    ]
  },
  formnovalidate: { property_name: "formNoValidate", applies_to: ["button", "input"] },
  hidden: {},
  indeterminate: { applies_to: ["input"] },
  inert: {},
  ismap: { property_name: "isMap", applies_to: ["img"] },
  loop: { applies_to: ["audio", "bgsound", "video"] },
  multiple: { applies_to: ["input", "select"] },
  muted: { applies_to: ["audio", "video"] },
  nomodule: { property_name: "noModule", applies_to: ["script"] },
  novalidate: { property_name: "noValidate", applies_to: ["form"] },
  open: { applies_to: ["details", "dialog"] },
  playsinline: { property_name: "playsInline", applies_to: ["video"] },
  readonly: { property_name: "readOnly", applies_to: ["input", "textarea"] },
  required: { applies_to: ["input", "select", "textarea"] },
  reversed: { applies_to: ["ol"] },
  selected: { applies_to: ["option"] },
  value: {
    applies_to: [
      "button",
      "option",
      "input",
      "li",
      "meter",
      "progress",
      "param",
      "select",
      "textarea"
    ]
  }
};
Object.keys(attribute_lookup).forEach((name3) => {
  const metadata = attribute_lookup[name3];
  if (!metadata.property_name)
    metadata.property_name = name3;
});
var charToInteger = {};
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
for (i$1 = 0; i$1 < chars$1.length; i$1++) {
  charToInteger[chars$1.charCodeAt(i$1)] = i$1;
}
var i$1;
var Url = typeof URL !== "undefined" ? URL : require_url().URL;
function getBtoa() {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return (str2) => window.btoa(unescape(encodeURIComponent(str2)));
  } else if (typeof Buffer === "function") {
    return (str2) => Buffer.from(str2, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa$2 = getBtoa();
var BlockAppliesToNode;
(function(BlockAppliesToNode2) {
  BlockAppliesToNode2[BlockAppliesToNode2["NotPossible"] = 0] = "NotPossible";
  BlockAppliesToNode2[BlockAppliesToNode2["Possible"] = 1] = "Possible";
  BlockAppliesToNode2[BlockAppliesToNode2["UnknownSelectorType"] = 2] = "UnknownSelectorType";
})(BlockAppliesToNode || (BlockAppliesToNode = {}));
var NodeExist;
(function(NodeExist2) {
  NodeExist2[NodeExist2["Probably"] = 1] = "Probably";
  NodeExist2[NodeExist2["Definitely"] = 2] = "Definitely";
})(NodeExist || (NodeExist = {}));
var test = typeof process !== "undefined" && process.env.TEST;

// node_modules/.pnpm/mdsvex@0.10.6_svelte@3.59.1/node_modules/mdsvex/dist/main.es.js
var import_util = __toESM(require_util());
var defineConfig = (config) => config;
var bail_1 = bail;
function bail(err) {
  if (err) {
    throw err;
  }
}
var isBuffer3 = function isBuffer4(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
var hasOwn2 = Object.prototype.hasOwnProperty;
var toStr2 = Object.prototype.toString;
var defineProperty2 = Object.defineProperty;
var gOPD2 = Object.getOwnPropertyDescriptor;
var isArray2 = function isArray3(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr2.call(arr) === "[object Array]";
};
var isPlainObject = function isPlainObject2(obj) {
  if (!obj || toStr2.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn2.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn2.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key;
  for (key in obj) {
  }
  return typeof key === "undefined" || hasOwn2.call(obj, key);
};
var setProperty = function setProperty2(target2, options2) {
  if (defineProperty2 && options2.name === "__proto__") {
    defineProperty2(target2, options2.name, {
      enumerable: true,
      configurable: true,
      value: options2.newValue,
      writable: true
    });
  } else {
    target2[options2.name] = options2.newValue;
  }
};
var getProperty = function getProperty2(obj, name3) {
  if (name3 === "__proto__") {
    if (!hasOwn2.call(obj, name3)) {
      return void 0;
    } else if (gOPD2) {
      return gOPD2(obj, name3).value;
    }
  }
  return obj[name3];
};
var extend$2 = function extend2() {
  var options2, name3, src2, copy2, copyIsArray, clone;
  var target2 = arguments[0];
  var i = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target2 === "boolean") {
    deep = target2;
    target2 = arguments[1] || {};
    i = 2;
  }
  if (target2 == null || typeof target2 !== "object" && typeof target2 !== "function") {
    target2 = {};
  }
  for (; i < length; ++i) {
    options2 = arguments[i];
    if (options2 != null) {
      for (name3 in options2) {
        src2 = getProperty(target2, name3);
        copy2 = getProperty(options2, name3);
        if (target2 !== copy2) {
          if (deep && copy2 && (isPlainObject(copy2) || (copyIsArray = isArray2(copy2)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src2 && isArray2(src2) ? src2 : [];
            } else {
              clone = src2 && isPlainObject(src2) ? src2 : {};
            }
            setProperty(target2, { name: name3, newValue: extend2(deep, clone, copy2) });
          } else if (typeof copy2 !== "undefined") {
            setProperty(target2, { name: name3, newValue: copy2 });
          }
        }
      }
    }
  }
  return target2;
};
var isPlainObj = (value) => {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
};
var slice$3 = [].slice;
var wrap_1$1 = wrap$2;
function wrap$2(fn2, callback) {
  var invoked;
  return wrapped;
  function wrapped() {
    var params = slice$3.call(arguments, 0);
    var callback2 = fn2.length > params.length;
    var result;
    if (callback2) {
      params.push(done);
    }
    try {
      result = fn2.apply(null, params);
    } catch (error2) {
      if (callback2 && invoked) {
        throw error2;
      }
      return done(error2);
    }
    if (!callback2) {
      if (result && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done() {
    if (!invoked) {
      invoked = true;
      callback.apply(null, arguments);
    }
  }
  function then(value) {
    done(null, value);
  }
}
var trough_1 = trough;
trough.wrap = wrap_1$1;
var slice$2 = [].slice;
function trough() {
  var fns = [];
  var middleware = {};
  middleware.run = run2;
  middleware.use = use;
  return middleware;
  function run2() {
    var index2 = -1;
    var input = slice$2.call(arguments, 0, -1);
    var done = arguments[arguments.length - 1];
    if (typeof done !== "function") {
      throw new Error("Expected function as last argument, not " + done);
    }
    next.apply(null, [null].concat(input));
    function next(err) {
      var fn2 = fns[++index2];
      var params = slice$2.call(arguments, 0);
      var values2 = params.slice(1);
      var length = input.length;
      var pos = -1;
      if (err) {
        done(err);
        return;
      }
      while (++pos < length) {
        if (values2[pos] === null || values2[pos] === void 0) {
          values2[pos] = input[pos];
        }
      }
      input = values2;
      if (fn2) {
        wrap_1$1(fn2, next).apply(null, input);
      } else {
        done.apply(null, [null].concat(input));
      }
    }
  }
  function use(fn2) {
    if (typeof fn2 !== "function") {
      throw new Error("Expected `fn` to be a function, not " + fn2);
    }
    fns.push(fn2);
    return middleware;
  }
}
var own$f = {}.hasOwnProperty;
var unistUtilStringifyPosition = stringify$4;
function stringify$4(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if (own$f.call(value, "position") || own$f.call(value, "type")) {
    return position$1(value.position);
  }
  if (own$f.call(value, "start") || own$f.call(value, "end")) {
    return position$1(value);
  }
  if (own$f.call(value, "line") || own$f.call(value, "column")) {
    return point(value);
  }
  return "";
}
function point(point2) {
  if (!point2 || typeof point2 !== "object") {
    point2 = {};
  }
  return index$6(point2.line) + ":" + index$6(point2.column);
}
function position$1(pos) {
  if (!pos || typeof pos !== "object") {
    pos = {};
  }
  return point(pos.start) + "-" + point(pos.end);
}
function index$6(value) {
  return value && typeof value === "number" ? value : 1;
}
var vfileMessage = VMessage;
function VMessagePrototype() {
}
VMessagePrototype.prototype = Error.prototype;
VMessage.prototype = new VMessagePrototype();
var proto$6 = VMessage.prototype;
proto$6.file = "";
proto$6.name = "";
proto$6.reason = "";
proto$6.message = "";
proto$6.stack = "";
proto$6.fatal = null;
proto$6.column = null;
proto$6.line = null;
function VMessage(reason, position2, origin) {
  var parts;
  var range2;
  var location;
  if (typeof position2 === "string") {
    origin = position2;
    position2 = null;
  }
  parts = parseOrigin(origin);
  range2 = unistUtilStringifyPosition(position2) || "1:1";
  location = {
    start: { line: null, column: null },
    end: { line: null, column: null }
  };
  if (position2 && position2.position) {
    position2 = position2.position;
  }
  if (position2) {
    if (position2.start) {
      location = position2;
      position2 = position2.start;
    } else {
      location.start = position2;
    }
  }
  if (reason.stack) {
    this.stack = reason.stack;
    reason = reason.message;
  }
  this.message = reason;
  this.name = range2;
  this.reason = reason;
  this.line = position2 ? position2.line : null;
  this.column = position2 ? position2.column : null;
  this.location = location;
  this.source = parts[0];
  this.ruleId = parts[1];
}
function parseOrigin(origin) {
  var result = [null, null];
  var index2;
  if (typeof origin === "string") {
    index2 = origin.indexOf(":");
    if (index2 === -1) {
      result[1] = origin;
    } else {
      result[0] = origin.slice(0, index2);
      result[1] = origin.slice(index2 + 1);
    }
  }
  return result;
}
function replaceExt(npath, ext) {
  if (typeof npath !== "string") {
    return npath;
  }
  if (npath.length === 0) {
    return npath;
  }
  var nFileName = import_path.default.basename(npath, import_path.default.extname(npath)) + ext;
  return import_path.default.join(import_path.default.dirname(npath), nFileName);
}
var replaceExt_1 = replaceExt;
var core$1 = VFile;
var own$e = {}.hasOwnProperty;
var proto$5 = VFile.prototype;
var order$1 = ["history", "path", "basename", "stem", "extname", "dirname"];
proto$5.toString = toString2;
Object.defineProperty(proto$5, "path", { get: getPath, set: setPath });
Object.defineProperty(proto$5, "dirname", { get: getDirname, set: setDirname });
Object.defineProperty(proto$5, "basename", { get: getBasename, set: setBasename });
Object.defineProperty(proto$5, "extname", { get: getExtname, set: setExtname });
Object.defineProperty(proto$5, "stem", { get: getStem, set: setStem });
function VFile(options2) {
  var prop2;
  var index2;
  var length;
  if (!options2) {
    options2 = {};
  } else if (typeof options2 === "string" || isBuffer3(options2)) {
    options2 = { contents: options2 };
  } else if ("message" in options2 && "messages" in options2) {
    return options2;
  }
  if (!(this instanceof VFile)) {
    return new VFile(options2);
  }
  this.data = {};
  this.messages = [];
  this.history = [];
  this.cwd = process.cwd();
  index2 = -1;
  length = order$1.length;
  while (++index2 < length) {
    prop2 = order$1[index2];
    if (own$e.call(options2, prop2)) {
      this[prop2] = options2[prop2];
    }
  }
  for (prop2 in options2) {
    if (order$1.indexOf(prop2) === -1) {
      this[prop2] = options2[prop2];
    }
  }
}
function getPath() {
  return this.history[this.history.length - 1];
}
function setPath(path2) {
  assertNonEmpty(path2, "path");
  if (path2 !== this.path) {
    this.history.push(path2);
  }
}
function getDirname() {
  return typeof this.path === "string" ? import_path.default.dirname(this.path) : void 0;
}
function setDirname(dirname) {
  assertPath(this.path, "dirname");
  this.path = import_path.default.join(dirname || "", this.basename);
}
function getBasename() {
  return typeof this.path === "string" ? import_path.default.basename(this.path) : void 0;
}
function setBasename(basename) {
  assertNonEmpty(basename, "basename");
  assertPart(basename, "basename");
  this.path = import_path.default.join(this.dirname || "", basename);
}
function getExtname() {
  return typeof this.path === "string" ? import_path.default.extname(this.path) : void 0;
}
function setExtname(extname) {
  var ext = extname || "";
  assertPart(ext, "extname");
  assertPath(this.path, "extname");
  if (ext) {
    if (ext.charAt(0) !== ".") {
      throw new Error("`extname` must start with `.`");
    }
    if (ext.indexOf(".", 1) !== -1) {
      throw new Error("`extname` cannot contain multiple dots");
    }
  }
  this.path = replaceExt_1(this.path, ext);
}
function getStem() {
  return typeof this.path === "string" ? import_path.default.basename(this.path, this.extname) : void 0;
}
function setStem(stem) {
  assertNonEmpty(stem, "stem");
  assertPart(stem, "stem");
  this.path = import_path.default.join(this.dirname || "", stem + (this.extname || ""));
}
function toString2(encoding) {
  var value = this.contents || "";
  return isBuffer3(value) ? value.toString(encoding) : String(value);
}
function assertPart(part2, name3) {
  if (part2.indexOf(import_path.default.sep) !== -1) {
    throw new Error(
      "`" + name3 + "` cannot be a path: did not expect `" + import_path.default.sep + "`"
    );
  }
}
function assertNonEmpty(part2, name3) {
  if (!part2) {
    throw new Error("`" + name3 + "` cannot be empty");
  }
}
function assertPath(path2, name3) {
  if (!path2) {
    throw new Error("Setting `" + name3 + "` requires `path` to be set too");
  }
}
var vfile = core$1;
var proto$4 = core$1.prototype;
proto$4.message = message;
proto$4.info = info$1;
proto$4.fail = fail;
function message(reason, position2, origin) {
  var filePath = this.path;
  var message2 = new vfileMessage(reason, position2, origin);
  if (filePath) {
    message2.name = filePath + ":" + message2.name;
    message2.file = filePath;
  }
  message2.fatal = false;
  this.messages.push(message2);
  return message2;
}
function fail() {
  var message2 = this.message.apply(this, arguments);
  message2.fatal = true;
  throw message2;
}
function info$1() {
  var message2 = this.message.apply(this, arguments);
  message2.fatal = null;
  return message2;
}
var unified_1$1 = unified$1().freeze();
var slice$12 = [].slice;
var own$d = {}.hasOwnProperty;
var pipeline$1 = trough_1().use(pipelineParse$1).use(pipelineRun$1).use(pipelineStringify$1);
function pipelineParse$1(p2, ctx) {
  ctx.tree = p2.parse(ctx.file);
}
function pipelineRun$1(p2, ctx, next) {
  p2.run(ctx.tree, ctx.file, done);
  function done(err, tree, file) {
    if (err) {
      next(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}
function pipelineStringify$1(p2, ctx) {
  var result = p2.stringify(ctx.tree, ctx.file);
  var file = ctx.file;
  if (result === void 0 || result === null)
    ;
  else if (typeof result === "string" || isBuffer3(result)) {
    file.contents = result;
  } else {
    file.result = result;
  }
}
function unified$1() {
  var attachers = [];
  var transformers = trough_1();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;
  processor.data = data3;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse5;
  processor.stringify = stringify2;
  processor.run = run2;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = unified$1();
    var length = attachers.length;
    var index2 = -1;
    while (++index2 < length) {
      destination.use.apply(null, attachers[index2]);
    }
    destination.data(extend$2(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values2;
    var plugin;
    var options2;
    var transformer;
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      values2 = attachers[freezeIndex];
      plugin = values2[0];
      options2 = values2[1];
      transformer = null;
      if (options2 === false) {
        continue;
      }
      if (options2 === true) {
        values2[1] = void 0;
      }
      transformer = plugin.apply(processor, values2.slice(1));
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data3(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen$1("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return own$d.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen$1("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function use(value) {
    var settings;
    assertUnfrozen$1("use", frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function") {
      addPlugin.apply(null, arguments);
    } else if (typeof value === "object") {
      if ("length" in value) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new Error("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = extend$2(namespace.settings || {}, settings);
    }
    return processor;
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = extend$2(settings || {}, result.settings);
      }
    }
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if ("length" in value2) {
          addPlugin.apply(null, value2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new Error("Expected usable value, not `" + value2 + "`");
      }
    }
    function addList(plugins) {
      var length;
      var index2;
      if (plugins === null || plugins === void 0)
        ;
      else if (typeof plugins === "object" && "length" in plugins) {
        length = plugins.length;
        index2 = -1;
        while (++index2 < length) {
          add(plugins[index2]);
        }
      } else {
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      var entry = find2(plugin);
      if (entry) {
        if (isPlainObj(entry[1]) && isPlainObj(value2)) {
          value2 = extend$2(entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push(slice$12.call(arguments));
      }
    }
  }
  function find2(plugin) {
    var length = attachers.length;
    var index2 = -1;
    var entry;
    while (++index2 < length) {
      entry = attachers[index2];
      if (entry[0] === plugin) {
        return entry;
      }
    }
  }
  function parse5(doc) {
    var file = vfile(doc);
    var Parser4;
    freeze();
    Parser4 = processor.Parser;
    assertParser$1("parse", Parser4);
    if (newable$1(Parser4, "parse")) {
      return new Parser4(String(file), file).parse();
    }
    return Parser4(String(file), file);
  }
  function run2(node2, file, cb) {
    assertNode$1(node2);
    freeze();
    if (!cb && typeof file === "function") {
      cb = file;
      file = null;
    }
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(file), done);
      function done(err, tree, file2) {
        tree = tree || node2;
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file2);
        }
      }
    }
  }
  function runSync(node2, file) {
    var complete = false;
    var result;
    run2(node2, file, done);
    assertDone$1("runSync", "run", complete);
    return result;
    function done(err, tree) {
      complete = true;
      bail_1(err);
      result = tree;
    }
  }
  function stringify2(node2, doc) {
    var file = vfile(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    assertCompiler$1("stringify", Compiler);
    assertNode$1(node2);
    if (newable$1(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function process2(doc, cb) {
    freeze();
    assertParser$1("process", processor.Parser);
    assertCompiler$1("process", processor.Compiler);
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      var file = vfile(doc);
      pipeline$1.run(processor, { file }, done);
      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }
  function processSync(doc) {
    var complete = false;
    var file;
    freeze();
    assertParser$1("processSync", processor.Parser);
    assertCompiler$1("processSync", processor.Compiler);
    file = vfile(doc);
    process2(file, done);
    assertDone$1("processSync", "process", complete);
    return file;
    function done(err) {
      complete = true;
      bail_1(err);
    }
  }
}
function newable$1(value, name3) {
  return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  (keys$2(value.prototype) || name3 in value.prototype);
}
function keys$2(value) {
  var key;
  for (key in value) {
    return true;
  }
  return false;
}
function assertParser$1(name3, Parser4) {
  if (typeof Parser4 !== "function") {
    throw new Error("Cannot `" + name3 + "` without `Parser`");
  }
}
function assertCompiler$1(name3, Compiler) {
  if (typeof Compiler !== "function") {
    throw new Error("Cannot `" + name3 + "` without `Compiler`");
  }
}
function assertUnfrozen$1(name3, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot invoke `" + name3 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode$1(node2) {
  if (!node2 || typeof node2.type !== "string") {
    throw new Error("Expected node, got `" + node2 + "`");
  }
}
function assertDone$1(name3, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name3 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
var immutable = extend$1;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
function extend$1() {
  var target2 = {};
  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (hasOwnProperty2.call(source, key)) {
        target2[key] = source[key];
      }
    }
  }
  return target2;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
}
function createCommonjsModule2(fn2, module) {
  return module = { exports: {} }, fn2(module, module.exports), module.exports;
}
function getCjsExportFromNamespace2(n) {
  return n && n["default"] || n;
}
var inherits_browser2 = createCommonjsModule2(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits3(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits3(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var inherits2 = createCommonjsModule2(function(module) {
  try {
    var util$1 = import_util.default;
    if (typeof util$1.inherits !== "function")
      throw "";
    module.exports = util$1.inherits;
  } catch (e) {
    module.exports = inherits_browser2;
  }
});
var unherit_1 = unherit;
function unherit(Super) {
  var result;
  var key;
  var value;
  inherits2(Of, Super);
  inherits2(From, Of);
  result = Of.prototype;
  for (key in result) {
    value = result[key];
    if (value && typeof value === "object") {
      result[key] = "concat" in value ? value.concat() : immutable(value);
    }
  }
  return Of;
  function From(parameters) {
    return Super.apply(this, parameters);
  }
  function Of() {
    if (!(this instanceof Of)) {
      return new From(arguments);
    }
    return Super.apply(this, arguments);
  }
}
var stateToggle = factory$6;
function factory$6(key, state, ctx) {
  return enter;
  function enter() {
    var context2 = ctx || this;
    var current2 = context2[key];
    context2[key] = !state;
    return exit;
    function exit() {
      context2[key] = current2;
    }
  }
}
var vfileLocation = factory$5;
function factory$5(file) {
  var contents = indices(String(file));
  return {
    toPosition: offsetToPositionFactory(contents),
    toOffset: positionToOffsetFactory(contents)
  };
}
function offsetToPositionFactory(indices2) {
  return offsetToPosition;
  function offsetToPosition(offset2) {
    var index2 = -1;
    var length = indices2.length;
    if (offset2 < 0) {
      return {};
    }
    while (++index2 < length) {
      if (indices2[index2] > offset2) {
        return {
          line: index2 + 1,
          column: offset2 - (indices2[index2 - 1] || 0) + 1,
          offset: offset2
        };
      }
    }
    return {};
  }
}
function positionToOffsetFactory(indices2) {
  return positionToOffset;
  function positionToOffset(position2) {
    var line2 = position2 && position2.line;
    var column = position2 && position2.column;
    if (!isNaN(line2) && !isNaN(column) && line2 - 1 in indices2) {
      return (indices2[line2 - 2] || 0) + column - 1 || 0;
    }
    return -1;
  }
}
function indices(value) {
  var result = [];
  var index2 = value.indexOf("\n");
  while (index2 !== -1) {
    result.push(index2 + 1);
    index2 = value.indexOf("\n", index2 + 1);
  }
  result.push(value.length + 1);
  return result;
}
var _unescape = factory$4;
var backslash$7 = "\\";
function factory$4(ctx, key) {
  return unescape2;
  function unescape2(value) {
    var previous = 0;
    var index2 = value.indexOf(backslash$7);
    var escape2 = ctx[key];
    var queue = [];
    var character;
    while (index2 !== -1) {
      queue.push(value.slice(previous, index2));
      previous = index2 + 1;
      character = value.charAt(previous);
      if (!character || escape2.indexOf(character) === -1) {
        queue.push(backslash$7);
      }
      index2 = value.indexOf(backslash$7, previous + 1);
    }
    queue.push(value.slice(previous));
    return queue.join("");
  }
}
var AElig$2 = "Æ";
var AMP$2 = "&";
var Aacute$2 = "Á";
var Acirc$2 = "Â";
var Agrave$2 = "À";
var Aring$2 = "Å";
var Atilde$2 = "Ã";
var Auml$2 = "Ä";
var COPY$1 = "©";
var Ccedil$2 = "Ç";
var ETH$2 = "Ð";
var Eacute$2 = "É";
var Ecirc$2 = "Ê";
var Egrave$2 = "È";
var Euml$2 = "Ë";
var GT$2 = ">";
var Iacute$2 = "Í";
var Icirc$2 = "Î";
var Igrave$2 = "Ì";
var Iuml$2 = "Ï";
var LT$2 = "<";
var Ntilde$2 = "Ñ";
var Oacute$2 = "Ó";
var Ocirc$2 = "Ô";
var Ograve$2 = "Ò";
var Oslash$2 = "Ø";
var Otilde$2 = "Õ";
var Ouml$2 = "Ö";
var QUOT$1 = '"';
var REG$1 = "®";
var THORN$2 = "Þ";
var Uacute$2 = "Ú";
var Ucirc$2 = "Û";
var Ugrave$2 = "Ù";
var Uuml$2 = "Ü";
var Yacute$2 = "Ý";
var aacute$2 = "á";
var acirc$2 = "â";
var acute$2 = "´";
var aelig$2 = "æ";
var agrave$2 = "à";
var amp$2 = "&";
var aring$2 = "å";
var atilde$2 = "ã";
var auml$2 = "ä";
var brvbar$2 = "¦";
var ccedil$2 = "ç";
var cedil$2 = "¸";
var cent$2 = "¢";
var copy$2 = "©";
var curren$2 = "¤";
var deg$2 = "°";
var divide$2 = "÷";
var eacute$2 = "é";
var ecirc$2 = "ê";
var egrave$2 = "è";
var eth$2 = "ð";
var euml$2 = "ë";
var frac12$2 = "½";
var frac14$2 = "¼";
var frac34$2 = "¾";
var gt$2 = ">";
var iacute$2 = "í";
var icirc$2 = "î";
var iexcl$2 = "¡";
var igrave$2 = "ì";
var iquest$2 = "¿";
var iuml$2 = "ï";
var laquo$2 = "«";
var lt$2 = "<";
var macr$2 = "¯";
var micro$2 = "µ";
var middot$2 = "·";
var nbsp$2 = " ";
var not$2 = "¬";
var ntilde$2 = "ñ";
var oacute$2 = "ó";
var ocirc$2 = "ô";
var ograve$2 = "ò";
var ordf$2 = "ª";
var ordm$2 = "º";
var oslash$2 = "ø";
var otilde$2 = "õ";
var ouml$2 = "ö";
var para$2 = "¶";
var plusmn$2 = "±";
var pound$2 = "£";
var quot$2 = '"';
var raquo$2 = "»";
var reg$2 = "®";
var sect$2 = "§";
var shy$2 = "­";
var sup1$2 = "¹";
var sup2$2 = "²";
var sup3$2 = "³";
var szlig$2 = "ß";
var thorn$2 = "þ";
var times$2 = "×";
var uacute$2 = "ú";
var ucirc$2 = "û";
var ugrave$2 = "ù";
var uml$2 = "¨";
var uuml$2 = "ü";
var yacute$2 = "ý";
var yen$2 = "¥";
var yuml$2 = "ÿ";
var index$5 = {
  AElig: AElig$2,
  AMP: AMP$2,
  Aacute: Aacute$2,
  Acirc: Acirc$2,
  Agrave: Agrave$2,
  Aring: Aring$2,
  Atilde: Atilde$2,
  Auml: Auml$2,
  COPY: COPY$1,
  Ccedil: Ccedil$2,
  ETH: ETH$2,
  Eacute: Eacute$2,
  Ecirc: Ecirc$2,
  Egrave: Egrave$2,
  Euml: Euml$2,
  GT: GT$2,
  Iacute: Iacute$2,
  Icirc: Icirc$2,
  Igrave: Igrave$2,
  Iuml: Iuml$2,
  LT: LT$2,
  Ntilde: Ntilde$2,
  Oacute: Oacute$2,
  Ocirc: Ocirc$2,
  Ograve: Ograve$2,
  Oslash: Oslash$2,
  Otilde: Otilde$2,
  Ouml: Ouml$2,
  QUOT: QUOT$1,
  REG: REG$1,
  THORN: THORN$2,
  Uacute: Uacute$2,
  Ucirc: Ucirc$2,
  Ugrave: Ugrave$2,
  Uuml: Uuml$2,
  Yacute: Yacute$2,
  aacute: aacute$2,
  acirc: acirc$2,
  acute: acute$2,
  aelig: aelig$2,
  agrave: agrave$2,
  amp: amp$2,
  aring: aring$2,
  atilde: atilde$2,
  auml: auml$2,
  brvbar: brvbar$2,
  ccedil: ccedil$2,
  cedil: cedil$2,
  cent: cent$2,
  copy: copy$2,
  curren: curren$2,
  deg: deg$2,
  divide: divide$2,
  eacute: eacute$2,
  ecirc: ecirc$2,
  egrave: egrave$2,
  eth: eth$2,
  euml: euml$2,
  frac12: frac12$2,
  frac14: frac14$2,
  frac34: frac34$2,
  gt: gt$2,
  iacute: iacute$2,
  icirc: icirc$2,
  iexcl: iexcl$2,
  igrave: igrave$2,
  iquest: iquest$2,
  iuml: iuml$2,
  laquo: laquo$2,
  lt: lt$2,
  macr: macr$2,
  micro: micro$2,
  middot: middot$2,
  nbsp: nbsp$2,
  not: not$2,
  ntilde: ntilde$2,
  oacute: oacute$2,
  ocirc: ocirc$2,
  ograve: ograve$2,
  ordf: ordf$2,
  ordm: ordm$2,
  oslash: oslash$2,
  otilde: otilde$2,
  ouml: ouml$2,
  para: para$2,
  plusmn: plusmn$2,
  pound: pound$2,
  quot: quot$2,
  raquo: raquo$2,
  reg: reg$2,
  sect: sect$2,
  shy: shy$2,
  sup1: sup1$2,
  sup2: sup2$2,
  sup3: sup3$2,
  szlig: szlig$2,
  thorn: thorn$2,
  times: times$2,
  uacute: uacute$2,
  ucirc: ucirc$2,
  ugrave: ugrave$2,
  uml: uml$2,
  uuml: uuml$2,
  yacute: yacute$2,
  yen: yen$2,
  yuml: yuml$2
};
var characterEntitiesLegacy = Object.freeze({
  __proto__: null,
  AElig: AElig$2,
  AMP: AMP$2,
  Aacute: Aacute$2,
  Acirc: Acirc$2,
  Agrave: Agrave$2,
  Aring: Aring$2,
  Atilde: Atilde$2,
  Auml: Auml$2,
  COPY: COPY$1,
  Ccedil: Ccedil$2,
  ETH: ETH$2,
  Eacute: Eacute$2,
  Ecirc: Ecirc$2,
  Egrave: Egrave$2,
  Euml: Euml$2,
  GT: GT$2,
  Iacute: Iacute$2,
  Icirc: Icirc$2,
  Igrave: Igrave$2,
  Iuml: Iuml$2,
  LT: LT$2,
  Ntilde: Ntilde$2,
  Oacute: Oacute$2,
  Ocirc: Ocirc$2,
  Ograve: Ograve$2,
  Oslash: Oslash$2,
  Otilde: Otilde$2,
  Ouml: Ouml$2,
  QUOT: QUOT$1,
  REG: REG$1,
  THORN: THORN$2,
  Uacute: Uacute$2,
  Ucirc: Ucirc$2,
  Ugrave: Ugrave$2,
  Uuml: Uuml$2,
  Yacute: Yacute$2,
  aacute: aacute$2,
  acirc: acirc$2,
  acute: acute$2,
  aelig: aelig$2,
  agrave: agrave$2,
  amp: amp$2,
  aring: aring$2,
  atilde: atilde$2,
  auml: auml$2,
  brvbar: brvbar$2,
  ccedil: ccedil$2,
  cedil: cedil$2,
  cent: cent$2,
  copy: copy$2,
  curren: curren$2,
  deg: deg$2,
  divide: divide$2,
  eacute: eacute$2,
  ecirc: ecirc$2,
  egrave: egrave$2,
  eth: eth$2,
  euml: euml$2,
  frac12: frac12$2,
  frac14: frac14$2,
  frac34: frac34$2,
  gt: gt$2,
  iacute: iacute$2,
  icirc: icirc$2,
  iexcl: iexcl$2,
  igrave: igrave$2,
  iquest: iquest$2,
  iuml: iuml$2,
  laquo: laquo$2,
  lt: lt$2,
  macr: macr$2,
  micro: micro$2,
  middot: middot$2,
  nbsp: nbsp$2,
  not: not$2,
  ntilde: ntilde$2,
  oacute: oacute$2,
  ocirc: ocirc$2,
  ograve: ograve$2,
  ordf: ordf$2,
  ordm: ordm$2,
  oslash: oslash$2,
  otilde: otilde$2,
  ouml: ouml$2,
  para: para$2,
  plusmn: plusmn$2,
  pound: pound$2,
  quot: quot$2,
  raquo: raquo$2,
  reg: reg$2,
  sect: sect$2,
  shy: shy$2,
  sup1: sup1$2,
  sup2: sup2$2,
  sup3: sup3$2,
  szlig: szlig$2,
  thorn: thorn$2,
  times: times$2,
  uacute: uacute$2,
  ucirc: ucirc$2,
  ugrave: ugrave$2,
  uml: uml$2,
  uuml: uuml$2,
  yacute: yacute$2,
  yen: yen$2,
  yuml: yuml$2,
  "default": index$5
});
var index$4 = {
  "0": "�",
  "128": "€",
  "130": "‚",
  "131": "ƒ",
  "132": "„",
  "133": "…",
  "134": "†",
  "135": "‡",
  "136": "ˆ",
  "137": "‰",
  "138": "Š",
  "139": "‹",
  "140": "Œ",
  "142": "Ž",
  "145": "‘",
  "146": "’",
  "147": "“",
  "148": "”",
  "149": "•",
  "150": "–",
  "151": "—",
  "152": "˜",
  "153": "™",
  "154": "š",
  "155": "›",
  "156": "œ",
  "158": "ž",
  "159": "Ÿ"
};
var characterReferenceInvalid = Object.freeze({
  __proto__: null,
  "default": index$4
});
var isDecimal = decimal$1;
function decimal$1(character) {
  var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 48 && code2 <= 57;
}
var isHexadecimal = hexadecimal;
function hexadecimal(character) {
  var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 97 && code2 <= 102 || code2 >= 65 && code2 <= 70 || code2 >= 48 && code2 <= 57;
}
var isAlphabetical = alphabetical;
function alphabetical(character) {
  var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
}
var isAlphanumerical = alphanumerical;
function alphanumerical(character) {
  return isAlphabetical(character) || isDecimal(character);
}
var AEli = "Æ";
var AElig$1 = "Æ";
var AM = "&";
var AMP$1 = "&";
var Aacut = "Á";
var Aacute$1 = "Á";
var Abreve = "Ă";
var Acir = "Â";
var Acirc$1 = "Â";
var Acy = "А";
var Afr = "𝔄";
var Agrav = "À";
var Agrave$1 = "À";
var Alpha$1 = "Α";
var Amacr = "Ā";
var And = "⩓";
var Aogon = "Ą";
var Aopf = "𝔸";
var ApplyFunction = "⁡";
var Arin = "Å";
var Aring$1 = "Å";
var Ascr = "𝒜";
var Assign = "≔";
var Atild = "Ã";
var Atilde$1 = "Ã";
var Aum = "Ä";
var Auml$1 = "Ä";
var Backslash = "∖";
var Barv = "⫧";
var Barwed = "⌆";
var Bcy = "Б";
var Because = "∵";
var Bernoullis = "ℬ";
var Beta$1 = "Β";
var Bfr = "𝔅";
var Bopf = "𝔹";
var Breve = "˘";
var Bscr = "ℬ";
var Bumpeq = "≎";
var CHcy = "Ч";
var COP = "©";
var COPY = "©";
var Cacute = "Ć";
var Cap = "⋒";
var CapitalDifferentialD = "ⅅ";
var Cayleys = "ℭ";
var Ccaron = "Č";
var Ccedi = "Ç";
var Ccedil$1 = "Ç";
var Ccirc = "Ĉ";
var Cconint = "∰";
var Cdot = "Ċ";
var Cedilla = "¸";
var CenterDot = "·";
var Cfr = "ℭ";
var Chi$1 = "Χ";
var CircleDot = "⊙";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var Colon2 = "∷";
var Colone = "⩴";
var Congruent = "≡";
var Conint = "∯";
var ContourIntegral = "∮";
var Copf = "ℂ";
var Coproduct = "∐";
var CounterClockwiseContourIntegral = "∳";
var Cross = "⨯";
var Cscr = "𝒞";
var Cup = "⋓";
var CupCap = "≍";
var DD = "ⅅ";
var DDotrahd = "⤑";
var DJcy = "Ђ";
var DScy = "Ѕ";
var DZcy = "Џ";
var Dagger$1 = "‡";
var Darr = "↡";
var Dashv = "⫤";
var Dcaron = "Ď";
var Dcy = "Д";
var Del = "∇";
var Delta$1 = "Δ";
var Dfr = "𝔇";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var Diamond = "⋄";
var DifferentialD = "ⅆ";
var Dopf = "𝔻";
var Dot = "¨";
var DotDot = "⃜";
var DotEqual = "≐";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrow = "↓";
var DownArrowBar = "⤓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVector = "↽";
var DownLeftVectorBar = "⥖";
var DownRightTeeVector = "⥟";
var DownRightVector = "⇁";
var DownRightVectorBar = "⥗";
var DownTee = "⊤";
var DownTeeArrow = "↧";
var Downarrow = "⇓";
var Dscr = "𝒟";
var Dstrok = "Đ";
var ENG = "Ŋ";
var ET = "Ð";
var ETH$1 = "Ð";
var Eacut = "É";
var Eacute$1 = "É";
var Ecaron = "Ě";
var Ecir = "Ê";
var Ecirc$1 = "Ê";
var Ecy = "Э";
var Edot = "Ė";
var Efr = "𝔈";
var Egrav = "È";
var Egrave$1 = "È";
var Element = "∈";
var Emacr = "Ē";
var EmptySmallSquare = "◻";
var EmptyVerySmallSquare = "▫";
var Eogon = "Ę";
var Eopf = "𝔼";
var Epsilon$1 = "Ε";
var Equal = "⩵";
var EqualTilde = "≂";
var Equilibrium = "⇌";
var Escr = "ℰ";
var Esim = "⩳";
var Eta$1 = "Η";
var Eum = "Ë";
var Euml$1 = "Ë";
var Exists = "∃";
var ExponentialE = "ⅇ";
var Fcy = "Ф";
var Ffr = "𝔉";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var Fopf = "𝔽";
var ForAll = "∀";
var Fouriertrf = "ℱ";
var Fscr = "ℱ";
var GJcy = "Ѓ";
var G2 = ">";
var GT$1 = ">";
var Gamma$1 = "Γ";
var Gammad = "Ϝ";
var Gbreve = "Ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var Gcy = "Г";
var Gdot = "Ġ";
var Gfr = "𝔊";
var Gg = "⋙";
var Gopf = "𝔾";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var Gt2 = "≫";
var HARDcy = "Ъ";
var Hacek = "ˇ";
var Hat = "^";
var Hcirc = "Ĥ";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var Hopf = "ℍ";
var HorizontalLine = "─";
var Hscr = "ℋ";
var Hstrok = "Ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var IEcy = "Е";
var IJlig = "Ĳ";
var IOcy = "Ё";
var Iacut = "Í";
var Iacute$1 = "Í";
var Icir = "Î";
var Icirc$1 = "Î";
var Icy = "И";
var Idot = "İ";
var Ifr = "ℑ";
var Igrav = "Ì";
var Igrave$1 = "Ì";
var Im = "ℑ";
var Imacr = "Ī";
var ImaginaryI = "ⅈ";
var Implies = "⇒";
var Int = "∬";
var Integral = "∫";
var Intersection = "⋂";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var Iogon = "Į";
var Iopf = "𝕀";
var Iota$1 = "Ι";
var Iscr = "ℐ";
var Itilde = "Ĩ";
var Iukcy = "І";
var Ium = "Ï";
var Iuml$1 = "Ï";
var Jcirc = "Ĵ";
var Jcy = "Й";
var Jfr = "𝔍";
var Jopf = "𝕁";
var Jscr = "𝒥";
var Jsercy = "Ј";
var Jukcy = "Є";
var KHcy = "Х";
var KJcy = "Ќ";
var Kappa$1 = "Κ";
var Kcedil = "Ķ";
var Kcy = "К";
var Kfr = "𝔎";
var Kopf = "𝕂";
var Kscr = "𝒦";
var LJcy = "Љ";
var L2 = "<";
var LT$1 = "<";
var Lacute = "Ĺ";
var Lambda$1 = "Λ";
var Lang = "⟪";
var Laplacetrf = "ℒ";
var Larr = "↞";
var Lcaron = "Ľ";
var Lcedil = "Ļ";
var Lcy = "Л";
var LeftAngleBracket = "⟨";
var LeftArrow = "←";
var LeftArrowBar = "⇤";
var LeftArrowRightArrow = "⇆";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVector = "⇃";
var LeftDownVectorBar = "⥙";
var LeftFloor = "⌊";
var LeftRightArrow = "↔";
var LeftRightVector = "⥎";
var LeftTee = "⊣";
var LeftTeeArrow = "↤";
var LeftTeeVector = "⥚";
var LeftTriangle = "⊲";
var LeftTriangleBar = "⧏";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVector = "↿";
var LeftUpVectorBar = "⥘";
var LeftVector = "↼";
var LeftVectorBar = "⥒";
var Leftarrow = "⇐";
var Leftrightarrow = "⇔";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var LessLess = "⪡";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var Lfr = "𝔏";
var Ll2 = "⋘";
var Lleftarrow = "⇚";
var Lmidot = "Ŀ";
var LongLeftArrow = "⟵";
var LongLeftRightArrow = "⟷";
var LongRightArrow = "⟶";
var Longleftarrow = "⟸";
var Longleftrightarrow = "⟺";
var Longrightarrow = "⟹";
var Lopf = "𝕃";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var Lscr = "ℒ";
var Lsh = "↰";
var Lstrok = "Ł";
var Lt = "≪";
var Mcy = "М";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var MinusPlus = "∓";
var Mopf = "𝕄";
var Mscr = "ℳ";
var Mu$1 = "Μ";
var NJcy = "Њ";
var Nacute = "Ń";
var Ncaron = "Ň";
var Ncedil = "Ņ";
var Ncy = "Н";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var Nfr = "𝔑";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var Nopf = "ℕ";
var Not = "⫬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangle = "⋫";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var Nscr = "𝒩";
var Ntild = "Ñ";
var Ntilde$1 = "Ñ";
var Nu$1 = "Ν";
var OElig$1 = "Œ";
var Oacut = "Ó";
var Oacute$1 = "Ó";
var Ocir = "Ô";
var Ocirc$1 = "Ô";
var Ocy = "О";
var Odblac = "Ő";
var Ofr = "𝔒";
var Ograv = "Ò";
var Ograve$1 = "Ò";
var Omacr = "Ō";
var Omega$1 = "Ω";
var Omicron$1 = "Ο";
var Oopf = "𝕆";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var Or2 = "⩔";
var Oscr = "𝒪";
var Oslas = "Ø";
var Oslash$1 = "Ø";
var Otild = "Õ";
var Otilde$1 = "Õ";
var Otimes = "⨷";
var Oum = "Ö";
var Ouml$1 = "Ö";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var PartialD = "∂";
var Pcy = "П";
var Pfr = "𝔓";
var Phi$1 = "Φ";
var Pi$1 = "Π";
var PlusMinus = "±";
var Poincareplane = "ℌ";
var Popf = "ℙ";
var Pr2 = "⪻";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var Prime$1 = "″";
var Product = "∏";
var Proportion = "∷";
var Proportional = "∝";
var Pscr = "𝒫";
var Psi$1 = "Ψ";
var QUO = '"';
var QUOT = '"';
var Qfr = "𝔔";
var Qopf = "ℚ";
var Qscr = "𝒬";
var RBarr = "⤐";
var RE = "®";
var REG = "®";
var Racute = "Ŕ";
var Rang = "⟫";
var Rarr = "↠";
var Rarrtl = "⤖";
var Rcaron = "Ř";
var Rcedil = "Ŗ";
var Rcy = "Р";
var Re2 = "ℜ";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var Rfr = "ℜ";
var Rho$1 = "Ρ";
var RightAngleBracket = "⟩";
var RightArrow = "→";
var RightArrowBar = "⇥";
var RightArrowLeftArrow = "⇄";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVector = "⇂";
var RightDownVectorBar = "⥕";
var RightFloor = "⌋";
var RightTee = "⊢";
var RightTeeArrow = "↦";
var RightTeeVector = "⥛";
var RightTriangle = "⊳";
var RightTriangleBar = "⧐";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVector = "↾";
var RightUpVectorBar = "⥔";
var RightVector = "⇀";
var RightVectorBar = "⥓";
var Rightarrow = "⇒";
var Ropf = "ℝ";
var RoundImplies = "⥰";
var Rrightarrow = "⇛";
var Rscr = "ℛ";
var Rsh = "↱";
var RuleDelayed = "⧴";
var SHCHcy = "Щ";
var SHcy = "Ш";
var SOFTcy = "Ь";
var Sacute = "Ś";
var Sc2 = "⪼";
var Scaron$1 = "Š";
var Scedil = "Ş";
var Scirc = "Ŝ";
var Scy = "С";
var Sfr = "𝔖";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var Sigma$1 = "Σ";
var SmallCircle = "∘";
var Sopf = "𝕊";
var Sqrt = "√";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var Sscr = "𝒮";
var Star = "⋆";
var Sub = "⋐";
var Subset = "⋐";
var SubsetEqual = "⊆";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var SuchThat = "∋";
var Sum = "∑";
var Sup = "⋑";
var Superset = "⊃";
var SupersetEqual = "⊇";
var Supset = "⋑";
var THOR = "Þ";
var THORN$1 = "Þ";
var TRADE = "™";
var TSHcy = "Ћ";
var TScy = "Ц";
var Tab = "	";
var Tau$1 = "Τ";
var Tcaron = "Ť";
var Tcedil = "Ţ";
var Tcy = "Т";
var Tfr = "𝔗";
var Therefore = "∴";
var Theta$1 = "Θ";
var ThickSpace = "  ";
var ThinSpace = " ";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var Topf = "𝕋";
var TripleDot = "⃛";
var Tscr = "𝒯";
var Tstrok = "Ŧ";
var Uacut = "Ú";
var Uacute$1 = "Ú";
var Uarr = "↟";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var Ubreve = "Ŭ";
var Ucir = "Û";
var Ucirc$1 = "Û";
var Ucy = "У";
var Udblac = "Ű";
var Ufr = "𝔘";
var Ugrav = "Ù";
var Ugrave$1 = "Ù";
var Umacr = "Ū";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var Uopf = "𝕌";
var UpArrow = "↑";
var UpArrowBar = "⤒";
var UpArrowDownArrow = "⇅";
var UpDownArrow = "↕";
var UpEquilibrium = "⥮";
var UpTee = "⊥";
var UpTeeArrow = "↥";
var Uparrow = "⇑";
var Updownarrow = "⇕";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var Upsi = "ϒ";
var Upsilon$1 = "Υ";
var Uring = "Ů";
var Uscr = "𝒰";
var Utilde = "Ũ";
var Uum = "Ü";
var Uuml$1 = "Ü";
var VDash = "⊫";
var Vbar = "⫫";
var Vcy = "В";
var Vdash = "⊩";
var Vdashl = "⫦";
var Vee = "⋁";
var Verbar = "‖";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var Vopf = "𝕍";
var Vscr = "𝒱";
var Vvdash = "⊪";
var Wcirc = "Ŵ";
var Wedge = "⋀";
var Wfr = "𝔚";
var Wopf = "𝕎";
var Wscr = "𝒲";
var Xfr = "𝔛";
var Xi$1 = "Ξ";
var Xopf = "𝕏";
var Xscr = "𝒳";
var YAcy = "Я";
var YIcy = "Ї";
var YUcy = "Ю";
var Yacut = "Ý";
var Yacute$1 = "Ý";
var Ycirc = "Ŷ";
var Ycy = "Ы";
var Yfr = "𝔜";
var Yopf = "𝕐";
var Yscr = "𝒴";
var Yuml$1 = "Ÿ";
var ZHcy = "Ж";
var Zacute = "Ź";
var Zcaron = "Ž";
var Zcy = "З";
var Zdot = "Ż";
var ZeroWidthSpace = "​";
var Zeta$1 = "Ζ";
var Zfr = "ℨ";
var Zopf = "ℤ";
var Zscr = "𝒵";
var aacut = "á";
var aacute$1 = "á";
var abreve = "ă";
var ac2 = "∾";
var acE = "∾̳";
var acd = "∿";
var acir = "â";
var acirc$1 = "â";
var acut = "´";
var acute$1 = "´";
var acy = "а";
var aeli = "æ";
var aelig$1 = "æ";
var af = "⁡";
var afr = "𝔞";
var agrav = "à";
var agrave$1 = "à";
var alefsym$1 = "ℵ";
var aleph = "ℵ";
var alpha$1 = "α";
var amacr = "ā";
var amalg = "⨿";
var am = "&";
var amp$1 = "&";
var and$1 = "∧";
var andand = "⩕";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang$1 = "∠";
var ange = "⦤";
var angle = "∠";
var angmsd = "∡";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var aogon = "ą";
var aopf = "𝕒";
var ap2 = "≈";
var apE = "⩰";
var apacir = "⩯";
var ape = "≊";
var apid = "≋";
var apos = "'";
var approx = "≈";
var approxeq = "≊";
var arin = "å";
var aring$1 = "å";
var ascr = "𝒶";
var ast = "*";
var asymp$1 = "≈";
var asympeq = "≍";
var atild = "ã";
var atilde$1 = "ã";
var aum = "ä";
var auml$1 = "ä";
var awconint = "∳";
var awint = "⨑";
var bNot = "⫭";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var barvee = "⊽";
var barwed = "⌅";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var bcy = "б";
var bdquo$1 = "„";
var becaus = "∵";
var because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var beta$1 = "β";
var beth = "ℶ";
var between = "≬";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bnot = "⌐";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxDL = "╗";
var boxDR = "╔";
var boxDl = "╖";
var boxDr = "╓";
var boxH = "═";
var boxHD = "╦";
var boxHU = "╩";
var boxHd = "╤";
var boxHu = "╧";
var boxUL = "╝";
var boxUR = "╚";
var boxUl = "╜";
var boxUr = "╙";
var boxV = "║";
var boxVH = "╬";
var boxVL = "╣";
var boxVR = "╠";
var boxVh = "╫";
var boxVl = "╢";
var boxVr = "╟";
var boxbox = "⧉";
var boxdL = "╕";
var boxdR = "╒";
var boxdl = "┐";
var boxdr = "┌";
var boxh = "─";
var boxhD = "╥";
var boxhU = "╨";
var boxhd = "┬";
var boxhu = "┴";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxuL = "╛";
var boxuR = "╘";
var boxul = "┘";
var boxur = "└";
var boxv = "│";
var boxvH = "╪";
var boxvL = "╡";
var boxvR = "╞";
var boxvh = "┼";
var boxvl = "┤";
var boxvr = "├";
var bprime = "‵";
var breve = "˘";
var brvba = "¦";
var brvbar$1 = "¦";
var bscr = "𝒷";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsol = "\\";
var bsolb = "⧅";
var bsolhsub = "⟈";
var bull$1 = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var bumpeq = "≏";
var cacute = "ć";
var cap$2 = "∩";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var capcup = "⩇";
var capdot = "⩀";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var ccaps = "⩍";
var ccaron = "č";
var ccedi = "ç";
var ccedil$1 = "ç";
var ccirc = "ĉ";
var ccups = "⩌";
var ccupssm = "⩐";
var cdot = "ċ";
var cedi = "¸";
var cedil$1 = "¸";
var cemptyv = "⦲";
var cen = "¢";
var cent$1 = "¢";
var centerdot = "·";
var cfr = "𝔠";
var chcy = "ч";
var check = "✓";
var checkmark = "✓";
var chi$1 = "χ";
var cir = "○";
var cirE = "⧃";
var circ$1 = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledR = "®";
var circledS = "Ⓢ";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var clubs$1 = "♣";
var clubsuit = "♣";
var colon$3 = ":";
var colone = "≔";
var coloneq = "≔";
var comma$2 = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong$1 = "≅";
var congdot = "⩭";
var conint = "∮";
var copf = "𝕔";
var coprod = "∐";
var cop = "©";
var copy$1 = "©";
var copysr = "℗";
var crarr$1 = "↵";
var cross = "✗";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cup$1 = "∪";
var cupbrcap = "⩈";
var cupcap = "⩆";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curre = "¤";
var curren$1 = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dArr$1 = "⇓";
var dHar = "⥥";
var dagger$1 = "†";
var daleth = "ℸ";
var darr$1 = "↓";
var dash$8 = "‐";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var dcaron = "ď";
var dcy = "д";
var dd$1 = "ⅆ";
var ddagger = "‡";
var ddarr = "⇊";
var ddotseq = "⩷";
var de2 = "°";
var deg$1 = "°";
var delta$1 = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var dfr = "𝔡";
var dharl = "⇃";
var dharr = "⇂";
var diam = "⋄";
var diamond = "⋄";
var diamondsuit = "♦";
var diams$1 = "♦";
var die = "¨";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divid = "÷";
var divide$1 = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var dopf = "𝕕";
var dot$4 = "˙";
var doteq = "≐";
var doteqdot = "≑";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var downarrow = "↓";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var dscr = "𝒹";
var dscy = "ѕ";
var dsol = "⧶";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var dzcy = "џ";
var dzigrarr = "⟿";
var eDDot = "⩷";
var eDot = "≑";
var eacut = "é";
var eacute$1 = "é";
var easter = "⩮";
var ecaron = "ě";
var ecir = "ê";
var ecirc$1 = "ê";
var ecolon = "≕";
var ecy = "э";
var edot = "ė";
var ee2 = "ⅇ";
var efDot = "≒";
var efr = "𝔢";
var eg = "⪚";
var egrav = "è";
var egrave$1 = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var emacr = "ē";
var empty$3 = "∅";
var emptyset = "∅";
var emptyv = "∅";
var emsp13 = " ";
var emsp14 = " ";
var emsp$1 = " ";
var eng = "ŋ";
var ensp$1 = " ";
var eogon = "ę";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var epsilon$1 = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var equals = "=";
var equest = "≟";
var equiv$1 = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erDot = "≓";
var erarr = "⥱";
var escr = "ℯ";
var esdot = "≐";
var esim = "≂";
var eta$1 = "η";
var et2 = "ð";
var eth$1 = "ð";
var eum = "ë";
var euml$1 = "ë";
var euro$1 = "€";
var excl = "!";
var exist$1 = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var fallingdotseq = "≒";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var ffr = "𝔣";
var filig = "ﬁ";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof$1 = "ƒ";
var fopf = "𝕗";
var forall$1 = "∀";
var fork = "⋔";
var forkv = "⫙";
var fpartint = "⨍";
var frac1 = "¼";
var frac12$1 = "½";
var frac13 = "⅓";
var frac14$1 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac3 = "¾";
var frac34$1 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl$1 = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var gE = "≧";
var gEl = "⪌";
var gacute = "ǵ";
var gamma$1 = "γ";
var gammad = "ϝ";
var gap = "⪆";
var gbreve = "ğ";
var gcirc = "ĝ";
var gcy = "г";
var gdot = "ġ";
var ge$1 = "≥";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var ges = "⩾";
var gescc = "⪩";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var gfr = "𝔤";
var gg = "≫";
var ggg = "⋙";
var gimel = "ℷ";
var gjcy = "ѓ";
var gl2 = "≷";
var glE = "⪒";
var gla = "⪥";
var glj = "⪤";
var gnE = "≩";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var gopf = "𝕘";
var grave = "`";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var g2 = ">";
var gt$1 = ">";
var gtcc = "⪧";
var gtcir = "⩺";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var hArr$1 = "⇔";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var hardcy = "ъ";
var harr$1 = "↔";
var harrcir = "⥈";
var harrw = "↭";
var hbar = "ℏ";
var hcirc = "ĥ";
var hearts$1 = "♥";
var heartsuit = "♥";
var hellip$1 = "…";
var hercon = "⊹";
var hfr = "𝔥";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var horbar = "―";
var hscr = "𝒽";
var hslash = "ℏ";
var hstrok = "ħ";
var hybull = "⁃";
var hyphen = "‐";
var iacut = "í";
var iacute$1 = "í";
var ic2 = "⁣";
var icir = "î";
var icirc$1 = "î";
var icy = "и";
var iecy = "е";
var iexc = "¡";
var iexcl$1 = "¡";
var iff = "⇔";
var ifr = "𝔦";
var igrav = "ì";
var igrave$1 = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var ijlig = "ĳ";
var imacr = "ī";
var image$3 = "ℑ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var imof = "⊷";
var imped = "Ƶ";
var incare = "℅";
var infin$1 = "∞";
var infintie = "⧝";
var inodot = "ı";
var int$1 = "∫";
var intcal = "⊺";
var integers = "ℤ";
var intercal = "⊺";
var intlarhk = "⨗";
var intprod = "⨼";
var iocy = "ё";
var iogon = "į";
var iopf = "𝕚";
var iota$1 = "ι";
var iprod = "⨼";
var iques = "¿";
var iquest$1 = "¿";
var iscr = "𝒾";
var isin$1 = "∈";
var isinE = "⋹";
var isindot = "⋵";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it2 = "⁢";
var itilde = "ĩ";
var iukcy = "і";
var ium = "ï";
var iuml$1 = "ï";
var jcirc = "ĵ";
var jcy = "й";
var jfr = "𝔧";
var jmath = "ȷ";
var jopf = "𝕛";
var jscr = "𝒿";
var jsercy = "ј";
var jukcy = "є";
var kappa$1 = "κ";
var kappav = "ϰ";
var kcedil = "ķ";
var kcy = "к";
var kfr = "𝔨";
var kgreen = "ĸ";
var khcy = "х";
var kjcy = "ќ";
var kopf = "𝕜";
var kscr = "𝓀";
var lAarr = "⇚";
var lArr$1 = "⇐";
var lAtail = "⤛";
var lBarr = "⤎";
var lE = "≦";
var lEg = "⪋";
var lHar = "⥢";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var lambda$1 = "λ";
var lang$1 = "⟨";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var laqu = "«";
var laquo$1 = "«";
var larr$1 = "←";
var larrb = "⇤";
var larrbfs = "⤟";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var lat = "⪫";
var latail = "⤙";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var lcaron = "ľ";
var lcedil = "ļ";
var lceil$1 = "⌈";
var lcub = "{";
var lcy = "л";
var ldca = "⤶";
var ldquo$1 = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le$1 = "≤";
var leftarrow = "←";
var leftarrowtail = "↢";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var leftthreetimes = "⋋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var les = "⩽";
var lescc = "⪨";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var lessgtr = "≶";
var lesssim = "≲";
var lfisht = "⥼";
var lfloor$1 = "⌊";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var ljcy = "љ";
var ll2 = "≪";
var llarr = "⇇";
var llcorner = "⌞";
var llhard = "⥫";
var lltri = "◺";
var lmidot = "ŀ";
var lmoust = "⎰";
var lmoustache = "⎰";
var lnE = "≨";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var longleftrightarrow = "⟷";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast$1 = "∗";
var lowbar = "_";
var loz$1 = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm$1 = "‎";
var lrtri = "⊿";
var lsaquo$1 = "‹";
var lscr = "𝓁";
var lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo$1 = "‘";
var lsquor = "‚";
var lstrok = "ł";
var l = "<";
var lt$1 = "<";
var ltcc = "⪦";
var ltcir = "⩹";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltrPar = "⦖";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var mDDot = "∺";
var mac = "¯";
var macr$1 = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map$1 = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var mcy = "м";
var mdash$1 = "—";
var measuredangle = "∡";
var mfr = "𝔪";
var mho = "℧";
var micr = "µ";
var micro$1 = "µ";
var mid = "∣";
var midast = "*";
var midcir = "⫰";
var middo = "·";
var middot$1 = "·";
var minus$1 = "−";
var minusb = "⊟";
var minusd = "∸";
var minusdu = "⨪";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var mopf = "𝕞";
var mp2 = "∓";
var mscr = "𝓂";
var mstpos = "∾";
var mu$1 = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nGg = "⋙̸";
var nGt = "≫⃒";
var nGtv = "≫̸";
var nLeftarrow = "⇍";
var nLeftrightarrow = "⇎";
var nLl = "⋘̸";
var nLt = "≪⃒";
var nLtv = "≪̸";
var nRightarrow = "⇏";
var nVDash = "⊯";
var nVdash = "⊮";
var nabla$1 = "∇";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natur = "♮";
var natural = "♮";
var naturals = "ℕ";
var nbs = " ";
var nbsp$1 = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var ncaron = "ň";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var ncy = "н";
var ndash$1 = "–";
var ne$1 = "≠";
var neArr = "⇗";
var nearhk = "⤤";
var nearr = "↗";
var nearrow = "↗";
var nedot = "≐̸";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var nexist = "∄";
var nexists = "∄";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var ngsim = "≵";
var ngt = "≯";
var ngtr = "≯";
var nhArr = "⇎";
var nharr = "↮";
var nhpar = "⫲";
var ni$1 = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var njcy = "њ";
var nlArr = "⇍";
var nlE = "≦̸";
var nlarr = "↚";
var nldr = "‥";
var nle = "≰";
var nleftarrow = "↚";
var nleftrightarrow = "↮";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nlsim = "≴";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nmid = "∤";
var nopf = "𝕟";
var no2 = "¬";
var not$1 = "¬";
var notin$1 = "∉";
var notinE = "⋹̸";
var notindot = "⋵̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var npar = "∦";
var nparallel = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var npre = "⪯̸";
var nprec = "⊀";
var npreceq = "⪯̸";
var nrArr = "⇏";
var nrarr = "↛";
var nrarrc = "⤳̸";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub$1 = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var ntild = "ñ";
var ntilde$1 = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var nu$1 = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvDash = "⊭";
var nvHarr = "⤄";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwArr = "⇖";
var nwarhk = "⤣";
var nwarr = "↖";
var nwarrow = "↖";
var nwnear = "⤧";
var oS = "Ⓢ";
var oacut = "ó";
var oacute$1 = "ó";
var oast = "⊛";
var ocir = "ô";
var ocirc$1 = "ô";
var ocy = "о";
var odash = "⊝";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var oelig$1 = "œ";
var ofcir = "⦿";
var ofr = "𝔬";
var ogon = "˛";
var ograv = "ò";
var ograve$1 = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline$1 = "‾";
var olt = "⧀";
var omacr = "ō";
var omega$1 = "ω";
var omicron$1 = "ο";
var omid = "⦶";
var ominus = "⊖";
var oopf = "𝕠";
var opar = "⦷";
var operp = "⦹";
var oplus$1 = "⊕";
var or$1 = "∨";
var orarr = "↻";
var ord = "º";
var order = "ℴ";
var orderof = "ℴ";
var ordf$1 = "ª";
var ordm$1 = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oscr = "ℴ";
var oslas = "ø";
var oslash$1 = "ø";
var osol = "⊘";
var otild = "õ";
var otilde$1 = "õ";
var otimes$1 = "⊗";
var otimesas = "⨶";
var oum = "ö";
var ouml$1 = "ö";
var ovbar = "⌽";
var par = "¶";
var para$1 = "¶";
var parallel = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part$1 = "∂";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil$1 = "‰";
var perp$1 = "⊥";
var pertenk = "‱";
var pfr = "𝔭";
var phi$1 = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var pi$1 = "π";
var pitchfork = "⋔";
var piv$1 = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plus = "+";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var plusm = "±";
var plusmn$1 = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var pointint = "⨕";
var popf = "𝕡";
var poun = "£";
var pound$1 = "£";
var pr = "≺";
var prE = "⪳";
var prap = "⪷";
var prcue = "≼";
var pre = "⪯";
var prec = "≺";
var precapprox = "⪷";
var preccurlyeq = "≼";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var precsim = "≾";
var prime$1 = "′";
var primes = "ℙ";
var prnE = "⪵";
var prnap = "⪹";
var prnsim = "⋨";
var prod$1 = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop$1 = "∝";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var pscr = "𝓅";
var psi$1 = "ψ";
var puncsp = " ";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var qprime = "⁗";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quo = '"';
var quot$1 = '"';
var rAarr = "⇛";
var rArr$1 = "⇒";
var rAtail = "⤜";
var rBarr = "⤏";
var rHar = "⥤";
var race = "∽̱";
var racute = "ŕ";
var radic$1 = "√";
var raemptyv = "⦳";
var rang$1 = "⟩";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raqu = "»";
var raquo$1 = "»";
var rarr$1 = "→";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var rcaron = "ř";
var rcedil = "ŗ";
var rceil$1 = "⌉";
var rcub = "}";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo$1 = "”";
var rdquor = "”";
var rdsh = "↳";
var real$1 = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var rect = "▭";
var re$3 = "®";
var reg$1 = "®";
var rfisht = "⥽";
var rfloor$1 = "⌋";
var rfr = "𝔯";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var rho$1 = "ρ";
var rhov = "ϱ";
var rightarrow = "→";
var rightarrowtail = "↣";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var rightthreetimes = "⋌";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm$1 = "‏";
var rmoust = "⎱";
var rmoustache = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var roplus = "⨮";
var rotimes = "⨵";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var rsaquo$1 = "›";
var rscr = "𝓇";
var rsh = "↱";
var rsqb = "]";
var rsquo$1 = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var ruluhar = "⥨";
var rx = "℞";
var sacute = "ś";
var sbquo$1 = "‚";
var sc2 = "≻";
var scE = "⪴";
var scap = "⪸";
var scaron$1 = "š";
var sccue = "≽";
var sce = "⪰";
var scedil = "ş";
var scirc = "ŝ";
var scnE = "⪶";
var scnap = "⪺";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var scy = "с";
var sdot$1 = "⋅";
var sdotb = "⊡";
var sdote = "⩦";
var seArr = "⇘";
var searhk = "⤥";
var searr = "↘";
var searrow = "↘";
var sec = "§";
var sect$1 = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var shchcy = "щ";
var shcy = "ш";
var shortmid = "∣";
var shortparallel = "∥";
var sh2 = "­";
var shy$1 = "­";
var sigma$1 = "σ";
var sigmaf$1 = "ς";
var sigmav = "ς";
var sim$1 = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var softcy = "ь";
var sol = "/";
var solb = "⧄";
var solbar = "⌿";
var sopf = "𝕤";
var spades$1 = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var squ = "□";
var square = "□";
var squarf = "▪";
var squf = "▪";
var srarr = "→";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub$1 = "⊂";
var subE = "⫅";
var subdot = "⪽";
var sube$1 = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var subseteq = "⊆";
var subseteqq = "⫅";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succ = "≻";
var succapprox = "⪸";
var succcurlyeq = "≽";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var sum$1 = "∑";
var sung = "♪";
var sup$1 = "⊃";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var supE = "⫆";
var supdot = "⪾";
var supdsub = "⫘";
var supe$1 = "⊇";
var supedot = "⫄";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swArr = "⇙";
var swarhk = "⤦";
var swarr = "↙";
var swarrow = "↙";
var swnwar = "⤪";
var szli = "ß";
var szlig$1 = "ß";
var target = "⌖";
var tau$1 = "τ";
var tbrk = "⎴";
var tcaron = "ť";
var tcedil = "ţ";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var tfr = "𝔱";
var there4$1 = "∴";
var therefore = "∴";
var theta$1 = "θ";
var thetasym$1 = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var thinsp$1 = " ";
var thkap = "≈";
var thksim = "∼";
var thor = "þ";
var thorn$1 = "þ";
var tilde$4 = "˜";
var time = "×";
var times$1 = "×";
var timesb = "⊠";
var timesbar = "⨱";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var top = "⊤";
var topbot = "⌶";
var topcir = "⫱";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade$1 = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var tscr = "𝓉";
var tscy = "ц";
var tshcy = "ћ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var uArr$1 = "⇑";
var uHar = "⥣";
var uacut = "ú";
var uacute$1 = "ú";
var uarr$1 = "↑";
var ubrcy = "ў";
var ubreve = "ŭ";
var ucir = "û";
var ucirc$1 = "û";
var ucy = "у";
var udarr = "⇅";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var ufr = "𝔲";
var ugrav = "ù";
var ugrave$1 = "ù";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var umacr = "ū";
var um = "¨";
var uml$1 = "¨";
var uogon = "ų";
var uopf = "𝕦";
var uparrow = "↑";
var updownarrow = "↕";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var upsi = "υ";
var upsih$1 = "ϒ";
var upsilon$1 = "υ";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var uring = "ů";
var urtri = "◹";
var uscr = "𝓊";
var utdot = "⋰";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var uum = "ü";
var uuml$1 = "ü";
var uwangle = "⦧";
var vArr = "⇕";
var vBar = "⫨";
var vBarv = "⫩";
var vDash = "⊨";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vcy = "в";
var vdash = "⊢";
var vee = "∨";
var veebar = "⊻";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var vert = "|";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var vzigzag = "⦚";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var wedgeq = "≙";
var weierp$1 = "℘";
var wfr = "𝔴";
var wopf = "𝕨";
var wp2 = "℘";
var wr2 = "≀";
var wreath = "≀";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var xfr = "𝔵";
var xhArr = "⟺";
var xharr = "⟷";
var xi$1 = "ξ";
var xlArr = "⟸";
var xlarr = "⟵";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrArr = "⟹";
var xrarr = "⟶";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var yacut = "ý";
var yacute$1 = "ý";
var yacy = "я";
var ycirc = "ŷ";
var ycy = "ы";
var ye2 = "¥";
var yen$1 = "¥";
var yfr = "𝔶";
var yicy = "ї";
var yopf = "𝕪";
var yscr = "𝓎";
var yucy = "ю";
var yum = "ÿ";
var yuml$1 = "ÿ";
var zacute = "ź";
var zcaron = "ž";
var zcy = "з";
var zdot = "ż";
var zeetrf = "ℨ";
var zeta$1 = "ζ";
var zfr = "𝔷";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var zscr = "𝓏";
var zwj$1 = "‍";
var zwnj$1 = "‌";
var index$3 = {
  AEli,
  AElig: AElig$1,
  AM,
  AMP: AMP$1,
  Aacut,
  Aacute: Aacute$1,
  Abreve,
  Acir,
  Acirc: Acirc$1,
  Acy,
  Afr,
  Agrav,
  Agrave: Agrave$1,
  Alpha: Alpha$1,
  Amacr,
  And,
  Aogon,
  Aopf,
  ApplyFunction,
  Arin,
  Aring: Aring$1,
  Ascr,
  Assign,
  Atild,
  Atilde: Atilde$1,
  Aum,
  Auml: Auml$1,
  Backslash,
  Barv,
  Barwed,
  Bcy,
  Because,
  Bernoullis,
  Beta: Beta$1,
  Bfr,
  Bopf,
  Breve,
  Bscr,
  Bumpeq,
  CHcy,
  COP,
  COPY,
  Cacute,
  Cap,
  CapitalDifferentialD,
  Cayleys,
  Ccaron,
  Ccedi,
  Ccedil: Ccedil$1,
  Ccirc,
  Cconint,
  Cdot,
  Cedilla,
  CenterDot,
  Cfr,
  Chi: Chi$1,
  CircleDot,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  Colon: Colon2,
  Colone,
  Congruent,
  Conint,
  ContourIntegral,
  Copf,
  Coproduct,
  CounterClockwiseContourIntegral,
  Cross,
  Cscr,
  Cup,
  CupCap,
  DD,
  DDotrahd,
  DJcy,
  DScy,
  DZcy,
  Dagger: Dagger$1,
  Darr,
  Dashv,
  Dcaron,
  Dcy,
  Del,
  Delta: Delta$1,
  Dfr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  Diamond,
  DifferentialD,
  Dopf,
  Dot,
  DotDot,
  DotEqual,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrow,
  DownArrowBar,
  DownArrowUpArrow,
  DownBreve,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVector,
  DownLeftVectorBar,
  DownRightTeeVector,
  DownRightVector,
  DownRightVectorBar,
  DownTee,
  DownTeeArrow,
  Downarrow,
  Dscr,
  Dstrok,
  ENG,
  ET,
  ETH: ETH$1,
  Eacut,
  Eacute: Eacute$1,
  Ecaron,
  Ecir,
  Ecirc: Ecirc$1,
  Ecy,
  Edot,
  Efr,
  Egrav,
  Egrave: Egrave$1,
  Element,
  Emacr,
  EmptySmallSquare,
  EmptyVerySmallSquare,
  Eogon,
  Eopf,
  Epsilon: Epsilon$1,
  Equal,
  EqualTilde,
  Equilibrium,
  Escr,
  Esim,
  Eta: Eta$1,
  Eum,
  Euml: Euml$1,
  Exists,
  ExponentialE,
  Fcy,
  Ffr,
  FilledSmallSquare,
  FilledVerySmallSquare,
  Fopf,
  ForAll,
  Fouriertrf,
  Fscr,
  GJcy,
  G: G2,
  GT: GT$1,
  Gamma: Gamma$1,
  Gammad,
  Gbreve,
  Gcedil,
  Gcirc,
  Gcy,
  Gdot,
  Gfr,
  Gg,
  Gopf,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  Gt: Gt2,
  HARDcy,
  Hacek,
  Hat,
  Hcirc,
  Hfr,
  HilbertSpace,
  Hopf,
  HorizontalLine,
  Hscr,
  Hstrok,
  HumpDownHump,
  HumpEqual,
  IEcy,
  IJlig,
  IOcy,
  Iacut,
  Iacute: Iacute$1,
  Icir,
  Icirc: Icirc$1,
  Icy,
  Idot,
  Ifr,
  Igrav,
  Igrave: Igrave$1,
  Im,
  Imacr,
  ImaginaryI,
  Implies,
  Int,
  Integral,
  Intersection,
  InvisibleComma,
  InvisibleTimes,
  Iogon,
  Iopf,
  Iota: Iota$1,
  Iscr,
  Itilde,
  Iukcy,
  Ium,
  Iuml: Iuml$1,
  Jcirc,
  Jcy,
  Jfr,
  Jopf,
  Jscr,
  Jsercy,
  Jukcy,
  KHcy,
  KJcy,
  Kappa: Kappa$1,
  Kcedil,
  Kcy,
  Kfr,
  Kopf,
  Kscr,
  LJcy,
  L: L2,
  LT: LT$1,
  Lacute,
  Lambda: Lambda$1,
  Lang,
  Laplacetrf,
  Larr,
  Lcaron,
  Lcedil,
  Lcy,
  LeftAngleBracket,
  LeftArrow,
  LeftArrowBar,
  LeftArrowRightArrow,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVector,
  LeftDownVectorBar,
  LeftFloor,
  LeftRightArrow,
  LeftRightVector,
  LeftTee,
  LeftTeeArrow,
  LeftTeeVector,
  LeftTriangle,
  LeftTriangleBar,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVector,
  LeftUpVectorBar,
  LeftVector,
  LeftVectorBar,
  Leftarrow,
  Leftrightarrow,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  LessLess,
  LessSlantEqual,
  LessTilde,
  Lfr,
  Ll: Ll2,
  Lleftarrow,
  Lmidot,
  LongLeftArrow,
  LongLeftRightArrow,
  LongRightArrow,
  Longleftarrow,
  Longleftrightarrow,
  Longrightarrow,
  Lopf,
  LowerLeftArrow,
  LowerRightArrow,
  Lscr,
  Lsh,
  Lstrok,
  Lt,
  "Map": "⤅",
  Mcy,
  MediumSpace,
  Mellintrf,
  Mfr,
  MinusPlus,
  Mopf,
  Mscr,
  Mu: Mu$1,
  NJcy,
  Nacute,
  Ncaron,
  Ncedil,
  Ncy,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  Nfr,
  NoBreak,
  NonBreakingSpace,
  Nopf,
  Not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  NotLeftTriangle,
  NotLeftTriangleBar,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangle,
  NotRightTriangleBar,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  Nscr,
  Ntild,
  Ntilde: Ntilde$1,
  Nu: Nu$1,
  OElig: OElig$1,
  Oacut,
  Oacute: Oacute$1,
  Ocir,
  Ocirc: Ocirc$1,
  Ocy,
  Odblac,
  Ofr,
  Ograv,
  Ograve: Ograve$1,
  Omacr,
  Omega: Omega$1,
  Omicron: Omicron$1,
  Oopf,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  Or: Or2,
  Oscr,
  Oslas,
  Oslash: Oslash$1,
  Otild,
  Otilde: Otilde$1,
  Otimes,
  Oum,
  Ouml: Ouml$1,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  PartialD,
  Pcy,
  Pfr,
  Phi: Phi$1,
  Pi: Pi$1,
  PlusMinus,
  Poincareplane,
  Popf,
  Pr: Pr2,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  Prime: Prime$1,
  Product,
  Proportion,
  Proportional,
  Pscr,
  Psi: Psi$1,
  QUO,
  QUOT,
  Qfr,
  Qopf,
  Qscr,
  RBarr,
  RE,
  REG,
  Racute,
  Rang,
  Rarr,
  Rarrtl,
  Rcaron,
  Rcedil,
  Rcy,
  Re: Re2,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  Rfr,
  Rho: Rho$1,
  RightAngleBracket,
  RightArrow,
  RightArrowBar,
  RightArrowLeftArrow,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVector,
  RightDownVectorBar,
  RightFloor,
  RightTee,
  RightTeeArrow,
  RightTeeVector,
  RightTriangle,
  RightTriangleBar,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVector,
  RightUpVectorBar,
  RightVector,
  RightVectorBar,
  Rightarrow,
  Ropf,
  RoundImplies,
  Rrightarrow,
  Rscr,
  Rsh,
  RuleDelayed,
  SHCHcy,
  SHcy,
  SOFTcy,
  Sacute,
  Sc: Sc2,
  Scaron: Scaron$1,
  Scedil,
  Scirc,
  Scy,
  Sfr,
  ShortDownArrow,
  ShortLeftArrow,
  ShortRightArrow,
  ShortUpArrow,
  Sigma: Sigma$1,
  SmallCircle,
  Sopf,
  Sqrt,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  Sscr,
  Star,
  Sub,
  Subset,
  SubsetEqual,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  SuchThat,
  Sum,
  Sup,
  Superset,
  SupersetEqual,
  Supset,
  THOR,
  THORN: THORN$1,
  TRADE,
  TSHcy,
  TScy,
  Tab,
  Tau: Tau$1,
  Tcaron,
  Tcedil,
  Tcy,
  Tfr,
  Therefore,
  Theta: Theta$1,
  ThickSpace,
  ThinSpace,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  Topf,
  TripleDot,
  Tscr,
  Tstrok,
  Uacut,
  Uacute: Uacute$1,
  Uarr,
  Uarrocir,
  Ubrcy,
  Ubreve,
  Ucir,
  Ucirc: Ucirc$1,
  Ucy,
  Udblac,
  Ufr,
  Ugrav,
  Ugrave: Ugrave$1,
  Umacr,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  Uopf,
  UpArrow,
  UpArrowBar,
  UpArrowDownArrow,
  UpDownArrow,
  UpEquilibrium,
  UpTee,
  UpTeeArrow,
  Uparrow,
  Updownarrow,
  UpperLeftArrow,
  UpperRightArrow,
  Upsi,
  Upsilon: Upsilon$1,
  Uring,
  Uscr,
  Utilde,
  Uum,
  Uuml: Uuml$1,
  VDash,
  Vbar,
  Vcy,
  Vdash,
  Vdashl,
  Vee,
  Verbar,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  Vopf,
  Vscr,
  Vvdash,
  Wcirc,
  Wedge,
  Wfr,
  Wopf,
  Wscr,
  Xfr,
  Xi: Xi$1,
  Xopf,
  Xscr,
  YAcy,
  YIcy,
  YUcy,
  Yacut,
  Yacute: Yacute$1,
  Ycirc,
  Ycy,
  Yfr,
  Yopf,
  Yscr,
  Yuml: Yuml$1,
  ZHcy,
  Zacute,
  Zcaron,
  Zcy,
  Zdot,
  ZeroWidthSpace,
  Zeta: Zeta$1,
  Zfr,
  Zopf,
  Zscr,
  aacut,
  aacute: aacute$1,
  abreve,
  ac: ac2,
  acE,
  acd,
  acir,
  acirc: acirc$1,
  acut,
  acute: acute$1,
  acy,
  aeli,
  aelig: aelig$1,
  af,
  afr,
  agrav,
  agrave: agrave$1,
  alefsym: alefsym$1,
  aleph,
  alpha: alpha$1,
  amacr,
  amalg,
  am,
  amp: amp$1,
  and: and$1,
  andand,
  andd,
  andslope,
  andv,
  ang: ang$1,
  ange,
  angle,
  angmsd,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  aogon,
  aopf,
  ap: ap2,
  apE,
  apacir,
  ape,
  apid,
  apos,
  approx,
  approxeq,
  arin,
  aring: aring$1,
  ascr,
  ast,
  asymp: asymp$1,
  asympeq,
  atild,
  atilde: atilde$1,
  aum,
  auml: auml$1,
  awconint,
  awint,
  bNot,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  barvee,
  barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  bcy,
  bdquo: bdquo$1,
  becaus,
  because,
  bemptyv,
  bepsi,
  bernou,
  beta: beta$1,
  beth,
  between,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bnot,
  bopf,
  bot,
  bottom,
  bowtie,
  boxDL,
  boxDR,
  boxDl,
  boxDr,
  boxH,
  boxHD,
  boxHU,
  boxHd,
  boxHu,
  boxUL,
  boxUR,
  boxUl,
  boxUr,
  boxV,
  boxVH,
  boxVL,
  boxVR,
  boxVh,
  boxVl,
  boxVr,
  boxbox,
  boxdL,
  boxdR,
  boxdl,
  boxdr,
  boxh,
  boxhD,
  boxhU,
  boxhd,
  boxhu,
  boxminus,
  boxplus,
  boxtimes,
  boxuL,
  boxuR,
  boxul,
  boxur,
  boxv,
  boxvH,
  boxvL,
  boxvR,
  boxvh,
  boxvl,
  boxvr,
  bprime,
  breve,
  brvba,
  brvbar: brvbar$1,
  bscr,
  bsemi,
  bsim,
  bsime,
  bsol,
  bsolb,
  bsolhsub,
  bull: bull$1,
  bullet,
  bump,
  bumpE,
  bumpe,
  bumpeq,
  cacute,
  cap: cap$2,
  capand,
  capbrcup,
  capcap,
  capcup,
  capdot,
  caps,
  caret,
  caron,
  ccaps,
  ccaron,
  ccedi,
  ccedil: ccedil$1,
  ccirc,
  ccups,
  ccupssm,
  cdot,
  cedi,
  cedil: cedil$1,
  cemptyv,
  cen,
  cent: cent$1,
  centerdot,
  cfr,
  chcy,
  check,
  checkmark,
  chi: chi$1,
  cir,
  cirE,
  circ: circ$1,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledR,
  circledS,
  circledast,
  circledcirc,
  circleddash,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  clubs: clubs$1,
  clubsuit,
  colon: colon$3,
  colone,
  coloneq,
  comma: comma$2,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong: cong$1,
  congdot,
  conint,
  copf,
  coprod,
  cop,
  copy: copy$1,
  copysr,
  crarr: crarr$1,
  cross,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cup: cup$1,
  cupbrcap,
  cupcap,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curre,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dArr: dArr$1,
  dHar,
  dagger: dagger$1,
  daleth,
  darr: darr$1,
  dash: dash$8,
  dashv,
  dbkarow,
  dblac,
  dcaron,
  dcy,
  dd: dd$1,
  ddagger,
  ddarr,
  ddotseq,
  de: de2,
  deg: deg$1,
  delta: delta$1,
  demptyv,
  dfisht,
  dfr,
  dharl,
  dharr,
  diam,
  diamond,
  diamondsuit,
  diams: diams$1,
  die,
  digamma,
  disin,
  div,
  divid,
  divide: divide$1,
  divideontimes,
  divonx,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  dopf,
  dot: dot$4,
  doteq,
  doteqdot,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  downarrow,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  drbkarow,
  drcorn,
  drcrop,
  dscr,
  dscy,
  dsol,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  dzcy,
  dzigrarr,
  eDDot,
  eDot,
  eacut,
  eacute: eacute$1,
  easter,
  ecaron,
  ecir,
  ecirc: ecirc$1,
  ecolon,
  ecy,
  edot,
  ee: ee2,
  efDot,
  efr,
  eg,
  egrav,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  elinters,
  ell,
  els,
  elsdot,
  emacr,
  empty: empty$3,
  emptyset,
  emptyv,
  emsp13,
  emsp14,
  emsp: emsp$1,
  eng,
  ensp: ensp$1,
  eogon,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  epsilon: epsilon$1,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  equals,
  equest,
  equiv: equiv$1,
  equivDD,
  eqvparsl,
  erDot,
  erarr,
  escr,
  esdot,
  esim,
  eta: eta$1,
  et: et2,
  eth: eth$1,
  eum,
  euml: euml$1,
  euro: euro$1,
  excl,
  exist: exist$1,
  expectation,
  exponentiale,
  fallingdotseq,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  ffr,
  filig,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof: fnof$1,
  fopf,
  forall: forall$1,
  fork,
  forkv,
  fpartint,
  frac1,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac3,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl: frasl$1,
  frown,
  fscr,
  gE,
  gEl,
  gacute,
  gamma: gamma$1,
  gammad,
  gap,
  gbreve,
  gcirc,
  gcy,
  gdot,
  ge: ge$1,
  gel,
  geq,
  geqq,
  geqslant,
  ges,
  gescc,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  gfr,
  gg,
  ggg,
  gimel,
  gjcy,
  gl: gl2,
  glE,
  gla,
  glj,
  gnE,
  gnap,
  gnapprox,
  gne,
  gneq,
  gneqq,
  gnsim,
  gopf,
  grave,
  gscr,
  gsim,
  gsime,
  gsiml,
  g: g2,
  gt: gt$1,
  gtcc,
  gtcir,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  hArr: hArr$1,
  hairsp,
  half,
  hamilt,
  hardcy,
  harr: harr$1,
  harrcir,
  harrw,
  hbar,
  hcirc,
  hearts: hearts$1,
  heartsuit,
  hellip: hellip$1,
  hercon,
  hfr,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  horbar,
  hscr,
  hslash,
  hstrok,
  hybull,
  hyphen,
  iacut,
  iacute: iacute$1,
  ic: ic2,
  icir,
  icirc: icirc$1,
  icy,
  iecy,
  iexc,
  iexcl: iexcl$1,
  iff,
  ifr,
  igrav,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  ijlig,
  imacr,
  image: image$3,
  imagline,
  imagpart,
  imath,
  imof,
  imped,
  "in": "∈",
  incare,
  infin: infin$1,
  infintie,
  inodot,
  int: int$1,
  intcal,
  integers,
  intercal,
  intlarhk,
  intprod,
  iocy,
  iogon,
  iopf,
  iota: iota$1,
  iprod,
  iques,
  iquest: iquest$1,
  iscr,
  isin: isin$1,
  isinE,
  isindot,
  isins,
  isinsv,
  isinv,
  it: it2,
  itilde,
  iukcy,
  ium,
  iuml: iuml$1,
  jcirc,
  jcy,
  jfr,
  jmath,
  jopf,
  jscr,
  jsercy,
  jukcy,
  kappa: kappa$1,
  kappav,
  kcedil,
  kcy,
  kfr,
  kgreen,
  khcy,
  kjcy,
  kopf,
  kscr,
  lAarr,
  lArr: lArr$1,
  lAtail,
  lBarr,
  lE,
  lEg,
  lHar,
  lacute,
  laemptyv,
  lagran,
  lambda: lambda$1,
  lang: lang$1,
  langd,
  langle,
  lap,
  laqu,
  laquo: laquo$1,
  larr: larr$1,
  larrb,
  larrbfs,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  lat,
  latail,
  late,
  lates,
  lbarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  lcaron,
  lcedil,
  lceil: lceil$1,
  lcub,
  lcy,
  ldca,
  ldquo: ldquo$1,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le: le$1,
  leftarrow,
  leftarrowtail,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  leftthreetimes,
  leg,
  leq,
  leqq,
  leqslant,
  les,
  lescc,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  lessgtr,
  lesssim,
  lfisht,
  lfloor: lfloor$1,
  lfr,
  lg,
  lgE,
  lhard,
  lharu,
  lharul,
  lhblk,
  ljcy,
  ll: ll2,
  llarr,
  llcorner,
  llhard,
  lltri,
  lmidot,
  lmoust,
  lmoustache,
  lnE,
  lnap,
  lnapprox,
  lne,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  longleftrightarrow,
  longmapsto,
  longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  lopf,
  loplus,
  lotimes,
  lowast: lowast$1,
  lowbar,
  loz: loz$1,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm: lrm$1,
  lrtri,
  lsaquo: lsaquo$1,
  lscr,
  lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo: lsquo$1,
  lsquor,
  lstrok,
  l,
  lt: lt$1,
  ltcc,
  ltcir,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltrPar,
  ltri,
  ltrie,
  ltrif,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  mDDot,
  mac,
  macr: macr$1,
  male,
  malt,
  maltese,
  map: map$1,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  mcy,
  mdash: mdash$1,
  measuredangle,
  mfr,
  mho,
  micr,
  micro: micro$1,
  mid,
  midast,
  midcir,
  middo,
  middot: middot$1,
  minus: minus$1,
  minusb,
  minusd,
  minusdu,
  mlcp,
  mldr,
  mnplus,
  models,
  mopf,
  mp: mp2,
  mscr,
  mstpos,
  mu: mu$1,
  multimap,
  mumap,
  nGg,
  nGt,
  nGtv,
  nLeftarrow,
  nLeftrightarrow,
  nLl,
  nLt,
  nLtv,
  nRightarrow,
  nVDash,
  nVdash,
  nabla: nabla$1,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natur,
  natural,
  naturals,
  nbs,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  ncaron,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  ncy,
  ndash: ndash$1,
  ne: ne$1,
  neArr,
  nearhk,
  nearr,
  nearrow,
  nedot,
  nequiv,
  nesear,
  nesim,
  nexist,
  nexists,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  ngsim,
  ngt,
  ngtr,
  nhArr,
  nharr,
  nhpar,
  ni: ni$1,
  nis,
  nisd,
  niv,
  njcy,
  nlArr,
  nlE,
  nlarr,
  nldr,
  nle,
  nleftarrow,
  nleftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nlsim,
  nlt,
  nltri,
  nltrie,
  nmid,
  nopf,
  no: no2,
  not: not$1,
  notin: notin$1,
  notinE,
  notindot,
  notinva,
  notinvb,
  notinvc,
  notni,
  notniva,
  notnivb,
  notnivc,
  npar,
  nparallel,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  npre,
  nprec,
  npreceq,
  nrArr,
  nrarr,
  nrarrc,
  nrarrw,
  nrightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub: nsub$1,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  ntild,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  nu: nu$1,
  num,
  numero,
  numsp,
  nvDash,
  nvHarr,
  nvap,
  nvdash,
  nvge,
  nvgt,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwArr,
  nwarhk,
  nwarr,
  nwarrow,
  nwnear,
  oS,
  oacut,
  oacute: oacute$1,
  oast,
  ocir,
  ocirc: ocirc$1,
  ocy,
  odash,
  odblac,
  odiv,
  odot,
  odsold,
  oelig: oelig$1,
  ofcir,
  ofr,
  ogon,
  ograv,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline: oline$1,
  olt,
  omacr,
  omega: omega$1,
  omicron: omicron$1,
  omid,
  ominus,
  oopf,
  opar,
  operp,
  oplus: oplus$1,
  or: or$1,
  orarr,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oscr,
  oslas,
  oslash: oslash$1,
  osol,
  otild,
  otilde: otilde$1,
  otimes: otimes$1,
  otimesas,
  oum,
  ouml: ouml$1,
  ovbar,
  par,
  para: para$1,
  parallel,
  parsim,
  parsl,
  part: part$1,
  pcy,
  percnt,
  period,
  permil: permil$1,
  perp: perp$1,
  pertenk,
  pfr,
  phi: phi$1,
  phiv,
  phmmat,
  phone,
  pi: pi$1,
  pitchfork,
  piv: piv$1,
  planck,
  planckh,
  plankv,
  plus,
  plusacir,
  plusb,
  pluscir,
  plusdo,
  plusdu,
  pluse,
  plusm,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  pointint,
  popf,
  poun,
  pound: pound$1,
  pr,
  prE,
  prap,
  prcue,
  pre,
  prec,
  precapprox,
  preccurlyeq,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  precsim,
  prime: prime$1,
  primes,
  prnE,
  prnap,
  prnsim,
  prod: prod$1,
  profalar,
  profline,
  profsurf,
  prop: prop$1,
  propto,
  prsim,
  prurel,
  pscr,
  psi: psi$1,
  puncsp,
  qfr,
  qint,
  qopf,
  qprime,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quo,
  quot: quot$1,
  rAarr,
  rArr: rArr$1,
  rAtail,
  rBarr,
  rHar,
  race,
  racute,
  radic: radic$1,
  raemptyv,
  rang: rang$1,
  rangd,
  range,
  rangle,
  raqu,
  raquo: raquo$1,
  rarr: rarr$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  rarrtl,
  rarrw,
  ratail,
  ratio,
  rationals,
  rbarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  rcaron,
  rcedil,
  rceil: rceil$1,
  rcub,
  rcy,
  rdca,
  rdldhar,
  rdquo: rdquo$1,
  rdquor,
  rdsh,
  real: real$1,
  realine,
  realpart,
  reals,
  rect,
  re: re$3,
  reg: reg$1,
  rfisht,
  rfloor: rfloor$1,
  rfr,
  rhard,
  rharu,
  rharul,
  rho: rho$1,
  rhov,
  rightarrow,
  rightarrowtail,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  rightthreetimes,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm: rlm$1,
  rmoust,
  rmoustache,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  roplus,
  rotimes,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  rsaquo: rsaquo$1,
  rscr,
  rsh,
  rsqb,
  rsquo: rsquo$1,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  ruluhar,
  rx,
  sacute,
  sbquo: sbquo$1,
  sc: sc2,
  scE,
  scap,
  scaron: scaron$1,
  sccue,
  sce,
  scedil,
  scirc,
  scnE,
  scnap,
  scnsim,
  scpolint,
  scsim,
  scy,
  sdot: sdot$1,
  sdotb,
  sdote,
  seArr,
  searhk,
  searr,
  searrow,
  sec,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  sfr,
  sfrown,
  sharp,
  shchcy,
  shcy,
  shortmid,
  shortparallel,
  sh: sh2,
  shy: shy$1,
  sigma: sigma$1,
  sigmaf: sigmaf$1,
  sigmav,
  sim: sim$1,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  softcy,
  sol,
  solb,
  solbar,
  sopf,
  spades: spades$1,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  squ,
  square,
  squarf,
  squf,
  srarr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub: sub$1,
  subE,
  subdot,
  sube: sube$1,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  subseteq,
  subseteqq,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succ,
  succapprox,
  succcurlyeq,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  sum: sum$1,
  sung,
  sup: sup$1,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  supE,
  supdot,
  supdsub,
  supe: supe$1,
  supedot,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swArr,
  swarhk,
  swarr,
  swarrow,
  swnwar,
  szli,
  szlig: szlig$1,
  target,
  tau: tau$1,
  tbrk,
  tcaron,
  tcedil,
  tcy,
  tdot,
  telrec,
  tfr,
  there4: there4$1,
  therefore,
  theta: theta$1,
  thetasym: thetasym$1,
  thetav,
  thickapprox,
  thicksim,
  thinsp: thinsp$1,
  thkap,
  thksim,
  thor,
  thorn: thorn$1,
  tilde: tilde$4,
  time,
  times: times$1,
  timesb,
  timesbar,
  timesd,
  tint,
  toea,
  top,
  topbot,
  topcir,
  topf,
  topfork,
  tosa,
  tprime,
  trade: trade$1,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  triplus,
  trisb,
  tritime,
  trpezium,
  tscr,
  tscy,
  tshcy,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  uArr: uArr$1,
  uHar,
  uacut,
  uacute: uacute$1,
  uarr: uarr$1,
  ubrcy,
  ubreve,
  ucir,
  ucirc: ucirc$1,
  ucy,
  udarr,
  udblac,
  udhar,
  ufisht,
  ufr,
  ugrav,
  ugrave: ugrave$1,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  umacr,
  um,
  uml: uml$1,
  uogon,
  uopf,
  uparrow,
  updownarrow,
  upharpoonleft,
  upharpoonright,
  uplus,
  upsi,
  upsih: upsih$1,
  upsilon: upsilon$1,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  uring,
  urtri,
  uscr,
  utdot,
  utilde,
  utri,
  utrif,
  uuarr,
  uum,
  uuml: uuml$1,
  uwangle,
  vArr,
  vBar,
  vBarv,
  vDash,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vcy,
  vdash,
  vee,
  veebar,
  veeeq,
  vellip,
  verbar,
  vert,
  vfr,
  vltri,
  vnsub,
  vnsup,
  vopf,
  vprop,
  vrtri,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  vzigzag,
  wcirc,
  wedbar,
  wedge,
  wedgeq,
  weierp: weierp$1,
  wfr,
  wopf,
  wp: wp2,
  wr: wr2,
  wreath,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  xfr,
  xhArr,
  xharr,
  xi: xi$1,
  xlArr,
  xlarr,
  xmap,
  xnis,
  xodot,
  xopf,
  xoplus,
  xotime,
  xrArr,
  xrarr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  yacut,
  yacute: yacute$1,
  yacy,
  ycirc,
  ycy,
  ye: ye2,
  yen: yen$1,
  yfr,
  yicy,
  yopf,
  yscr,
  yucy,
  yum,
  yuml: yuml$1,
  zacute,
  zcaron,
  zcy,
  zdot,
  zeetrf,
  zeta: zeta$1,
  zfr,
  zhcy,
  zigrarr,
  zopf,
  zscr,
  zwj: zwj$1,
  zwnj: zwnj$1
};
var characterEntities$1 = Object.freeze({
  __proto__: null,
  AEli,
  AElig: AElig$1,
  AM,
  AMP: AMP$1,
  Aacut,
  Aacute: Aacute$1,
  Abreve,
  Acir,
  Acirc: Acirc$1,
  Acy,
  Afr,
  Agrav,
  Agrave: Agrave$1,
  Alpha: Alpha$1,
  Amacr,
  And,
  Aogon,
  Aopf,
  ApplyFunction,
  Arin,
  Aring: Aring$1,
  Ascr,
  Assign,
  Atild,
  Atilde: Atilde$1,
  Aum,
  Auml: Auml$1,
  Backslash,
  Barv,
  Barwed,
  Bcy,
  Because,
  Bernoullis,
  Beta: Beta$1,
  Bfr,
  Bopf,
  Breve,
  Bscr,
  Bumpeq,
  CHcy,
  COP,
  COPY,
  Cacute,
  Cap,
  CapitalDifferentialD,
  Cayleys,
  Ccaron,
  Ccedi,
  Ccedil: Ccedil$1,
  Ccirc,
  Cconint,
  Cdot,
  Cedilla,
  CenterDot,
  Cfr,
  Chi: Chi$1,
  CircleDot,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  Colon: Colon2,
  Colone,
  Congruent,
  Conint,
  ContourIntegral,
  Copf,
  Coproduct,
  CounterClockwiseContourIntegral,
  Cross,
  Cscr,
  Cup,
  CupCap,
  DD,
  DDotrahd,
  DJcy,
  DScy,
  DZcy,
  Dagger: Dagger$1,
  Darr,
  Dashv,
  Dcaron,
  Dcy,
  Del,
  Delta: Delta$1,
  Dfr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  Diamond,
  DifferentialD,
  Dopf,
  Dot,
  DotDot,
  DotEqual,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrow,
  DownArrowBar,
  DownArrowUpArrow,
  DownBreve,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVector,
  DownLeftVectorBar,
  DownRightTeeVector,
  DownRightVector,
  DownRightVectorBar,
  DownTee,
  DownTeeArrow,
  Downarrow,
  Dscr,
  Dstrok,
  ENG,
  ET,
  ETH: ETH$1,
  Eacut,
  Eacute: Eacute$1,
  Ecaron,
  Ecir,
  Ecirc: Ecirc$1,
  Ecy,
  Edot,
  Efr,
  Egrav,
  Egrave: Egrave$1,
  Element,
  Emacr,
  EmptySmallSquare,
  EmptyVerySmallSquare,
  Eogon,
  Eopf,
  Epsilon: Epsilon$1,
  Equal,
  EqualTilde,
  Equilibrium,
  Escr,
  Esim,
  Eta: Eta$1,
  Eum,
  Euml: Euml$1,
  Exists,
  ExponentialE,
  Fcy,
  Ffr,
  FilledSmallSquare,
  FilledVerySmallSquare,
  Fopf,
  ForAll,
  Fouriertrf,
  Fscr,
  GJcy,
  G: G2,
  GT: GT$1,
  Gamma: Gamma$1,
  Gammad,
  Gbreve,
  Gcedil,
  Gcirc,
  Gcy,
  Gdot,
  Gfr,
  Gg,
  Gopf,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  Gt: Gt2,
  HARDcy,
  Hacek,
  Hat,
  Hcirc,
  Hfr,
  HilbertSpace,
  Hopf,
  HorizontalLine,
  Hscr,
  Hstrok,
  HumpDownHump,
  HumpEqual,
  IEcy,
  IJlig,
  IOcy,
  Iacut,
  Iacute: Iacute$1,
  Icir,
  Icirc: Icirc$1,
  Icy,
  Idot,
  Ifr,
  Igrav,
  Igrave: Igrave$1,
  Im,
  Imacr,
  ImaginaryI,
  Implies,
  Int,
  Integral,
  Intersection,
  InvisibleComma,
  InvisibleTimes,
  Iogon,
  Iopf,
  Iota: Iota$1,
  Iscr,
  Itilde,
  Iukcy,
  Ium,
  Iuml: Iuml$1,
  Jcirc,
  Jcy,
  Jfr,
  Jopf,
  Jscr,
  Jsercy,
  Jukcy,
  KHcy,
  KJcy,
  Kappa: Kappa$1,
  Kcedil,
  Kcy,
  Kfr,
  Kopf,
  Kscr,
  LJcy,
  L: L2,
  LT: LT$1,
  Lacute,
  Lambda: Lambda$1,
  Lang,
  Laplacetrf,
  Larr,
  Lcaron,
  Lcedil,
  Lcy,
  LeftAngleBracket,
  LeftArrow,
  LeftArrowBar,
  LeftArrowRightArrow,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVector,
  LeftDownVectorBar,
  LeftFloor,
  LeftRightArrow,
  LeftRightVector,
  LeftTee,
  LeftTeeArrow,
  LeftTeeVector,
  LeftTriangle,
  LeftTriangleBar,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVector,
  LeftUpVectorBar,
  LeftVector,
  LeftVectorBar,
  Leftarrow,
  Leftrightarrow,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  LessLess,
  LessSlantEqual,
  LessTilde,
  Lfr,
  Ll: Ll2,
  Lleftarrow,
  Lmidot,
  LongLeftArrow,
  LongLeftRightArrow,
  LongRightArrow,
  Longleftarrow,
  Longleftrightarrow,
  Longrightarrow,
  Lopf,
  LowerLeftArrow,
  LowerRightArrow,
  Lscr,
  Lsh,
  Lstrok,
  Lt,
  Mcy,
  MediumSpace,
  Mellintrf,
  Mfr,
  MinusPlus,
  Mopf,
  Mscr,
  Mu: Mu$1,
  NJcy,
  Nacute,
  Ncaron,
  Ncedil,
  Ncy,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  Nfr,
  NoBreak,
  NonBreakingSpace,
  Nopf,
  Not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  NotLeftTriangle,
  NotLeftTriangleBar,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangle,
  NotRightTriangleBar,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  Nscr,
  Ntild,
  Ntilde: Ntilde$1,
  Nu: Nu$1,
  OElig: OElig$1,
  Oacut,
  Oacute: Oacute$1,
  Ocir,
  Ocirc: Ocirc$1,
  Ocy,
  Odblac,
  Ofr,
  Ograv,
  Ograve: Ograve$1,
  Omacr,
  Omega: Omega$1,
  Omicron: Omicron$1,
  Oopf,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  Or: Or2,
  Oscr,
  Oslas,
  Oslash: Oslash$1,
  Otild,
  Otilde: Otilde$1,
  Otimes,
  Oum,
  Ouml: Ouml$1,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  PartialD,
  Pcy,
  Pfr,
  Phi: Phi$1,
  Pi: Pi$1,
  PlusMinus,
  Poincareplane,
  Popf,
  Pr: Pr2,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  Prime: Prime$1,
  Product,
  Proportion,
  Proportional,
  Pscr,
  Psi: Psi$1,
  QUO,
  QUOT,
  Qfr,
  Qopf,
  Qscr,
  RBarr,
  RE,
  REG,
  Racute,
  Rang,
  Rarr,
  Rarrtl,
  Rcaron,
  Rcedil,
  Rcy,
  Re: Re2,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  Rfr,
  Rho: Rho$1,
  RightAngleBracket,
  RightArrow,
  RightArrowBar,
  RightArrowLeftArrow,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVector,
  RightDownVectorBar,
  RightFloor,
  RightTee,
  RightTeeArrow,
  RightTeeVector,
  RightTriangle,
  RightTriangleBar,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVector,
  RightUpVectorBar,
  RightVector,
  RightVectorBar,
  Rightarrow,
  Ropf,
  RoundImplies,
  Rrightarrow,
  Rscr,
  Rsh,
  RuleDelayed,
  SHCHcy,
  SHcy,
  SOFTcy,
  Sacute,
  Sc: Sc2,
  Scaron: Scaron$1,
  Scedil,
  Scirc,
  Scy,
  Sfr,
  ShortDownArrow,
  ShortLeftArrow,
  ShortRightArrow,
  ShortUpArrow,
  Sigma: Sigma$1,
  SmallCircle,
  Sopf,
  Sqrt,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  Sscr,
  Star,
  Sub,
  Subset,
  SubsetEqual,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  SuchThat,
  Sum,
  Sup,
  Superset,
  SupersetEqual,
  Supset,
  THOR,
  THORN: THORN$1,
  TRADE,
  TSHcy,
  TScy,
  Tab,
  Tau: Tau$1,
  Tcaron,
  Tcedil,
  Tcy,
  Tfr,
  Therefore,
  Theta: Theta$1,
  ThickSpace,
  ThinSpace,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  Topf,
  TripleDot,
  Tscr,
  Tstrok,
  Uacut,
  Uacute: Uacute$1,
  Uarr,
  Uarrocir,
  Ubrcy,
  Ubreve,
  Ucir,
  Ucirc: Ucirc$1,
  Ucy,
  Udblac,
  Ufr,
  Ugrav,
  Ugrave: Ugrave$1,
  Umacr,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  Uopf,
  UpArrow,
  UpArrowBar,
  UpArrowDownArrow,
  UpDownArrow,
  UpEquilibrium,
  UpTee,
  UpTeeArrow,
  Uparrow,
  Updownarrow,
  UpperLeftArrow,
  UpperRightArrow,
  Upsi,
  Upsilon: Upsilon$1,
  Uring,
  Uscr,
  Utilde,
  Uum,
  Uuml: Uuml$1,
  VDash,
  Vbar,
  Vcy,
  Vdash,
  Vdashl,
  Vee,
  Verbar,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  Vopf,
  Vscr,
  Vvdash,
  Wcirc,
  Wedge,
  Wfr,
  Wopf,
  Wscr,
  Xfr,
  Xi: Xi$1,
  Xopf,
  Xscr,
  YAcy,
  YIcy,
  YUcy,
  Yacut,
  Yacute: Yacute$1,
  Ycirc,
  Ycy,
  Yfr,
  Yopf,
  Yscr,
  Yuml: Yuml$1,
  ZHcy,
  Zacute,
  Zcaron,
  Zcy,
  Zdot,
  ZeroWidthSpace,
  Zeta: Zeta$1,
  Zfr,
  Zopf,
  Zscr,
  aacut,
  aacute: aacute$1,
  abreve,
  ac: ac2,
  acE,
  acd,
  acir,
  acirc: acirc$1,
  acut,
  acute: acute$1,
  acy,
  aeli,
  aelig: aelig$1,
  af,
  afr,
  agrav,
  agrave: agrave$1,
  alefsym: alefsym$1,
  aleph,
  alpha: alpha$1,
  amacr,
  amalg,
  am,
  amp: amp$1,
  and: and$1,
  andand,
  andd,
  andslope,
  andv,
  ang: ang$1,
  ange,
  angle,
  angmsd,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  aogon,
  aopf,
  ap: ap2,
  apE,
  apacir,
  ape,
  apid,
  apos,
  approx,
  approxeq,
  arin,
  aring: aring$1,
  ascr,
  ast,
  asymp: asymp$1,
  asympeq,
  atild,
  atilde: atilde$1,
  aum,
  auml: auml$1,
  awconint,
  awint,
  bNot,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  barvee,
  barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  bcy,
  bdquo: bdquo$1,
  becaus,
  because,
  bemptyv,
  bepsi,
  bernou,
  beta: beta$1,
  beth,
  between,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bnot,
  bopf,
  bot,
  bottom,
  bowtie,
  boxDL,
  boxDR,
  boxDl,
  boxDr,
  boxH,
  boxHD,
  boxHU,
  boxHd,
  boxHu,
  boxUL,
  boxUR,
  boxUl,
  boxUr,
  boxV,
  boxVH,
  boxVL,
  boxVR,
  boxVh,
  boxVl,
  boxVr,
  boxbox,
  boxdL,
  boxdR,
  boxdl,
  boxdr,
  boxh,
  boxhD,
  boxhU,
  boxhd,
  boxhu,
  boxminus,
  boxplus,
  boxtimes,
  boxuL,
  boxuR,
  boxul,
  boxur,
  boxv,
  boxvH,
  boxvL,
  boxvR,
  boxvh,
  boxvl,
  boxvr,
  bprime,
  breve,
  brvba,
  brvbar: brvbar$1,
  bscr,
  bsemi,
  bsim,
  bsime,
  bsol,
  bsolb,
  bsolhsub,
  bull: bull$1,
  bullet,
  bump,
  bumpE,
  bumpe,
  bumpeq,
  cacute,
  cap: cap$2,
  capand,
  capbrcup,
  capcap,
  capcup,
  capdot,
  caps,
  caret,
  caron,
  ccaps,
  ccaron,
  ccedi,
  ccedil: ccedil$1,
  ccirc,
  ccups,
  ccupssm,
  cdot,
  cedi,
  cedil: cedil$1,
  cemptyv,
  cen,
  cent: cent$1,
  centerdot,
  cfr,
  chcy,
  check,
  checkmark,
  chi: chi$1,
  cir,
  cirE,
  circ: circ$1,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledR,
  circledS,
  circledast,
  circledcirc,
  circleddash,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  clubs: clubs$1,
  clubsuit,
  colon: colon$3,
  colone,
  coloneq,
  comma: comma$2,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong: cong$1,
  congdot,
  conint,
  copf,
  coprod,
  cop,
  copy: copy$1,
  copysr,
  crarr: crarr$1,
  cross,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cup: cup$1,
  cupbrcap,
  cupcap,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curre,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dArr: dArr$1,
  dHar,
  dagger: dagger$1,
  daleth,
  darr: darr$1,
  dash: dash$8,
  dashv,
  dbkarow,
  dblac,
  dcaron,
  dcy,
  dd: dd$1,
  ddagger,
  ddarr,
  ddotseq,
  de: de2,
  deg: deg$1,
  delta: delta$1,
  demptyv,
  dfisht,
  dfr,
  dharl,
  dharr,
  diam,
  diamond,
  diamondsuit,
  diams: diams$1,
  die,
  digamma,
  disin,
  div,
  divid,
  divide: divide$1,
  divideontimes,
  divonx,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  dopf,
  dot: dot$4,
  doteq,
  doteqdot,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  downarrow,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  drbkarow,
  drcorn,
  drcrop,
  dscr,
  dscy,
  dsol,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  dzcy,
  dzigrarr,
  eDDot,
  eDot,
  eacut,
  eacute: eacute$1,
  easter,
  ecaron,
  ecir,
  ecirc: ecirc$1,
  ecolon,
  ecy,
  edot,
  ee: ee2,
  efDot,
  efr,
  eg,
  egrav,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  elinters,
  ell,
  els,
  elsdot,
  emacr,
  empty: empty$3,
  emptyset,
  emptyv,
  emsp13,
  emsp14,
  emsp: emsp$1,
  eng,
  ensp: ensp$1,
  eogon,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  epsilon: epsilon$1,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  equals,
  equest,
  equiv: equiv$1,
  equivDD,
  eqvparsl,
  erDot,
  erarr,
  escr,
  esdot,
  esim,
  eta: eta$1,
  et: et2,
  eth: eth$1,
  eum,
  euml: euml$1,
  euro: euro$1,
  excl,
  exist: exist$1,
  expectation,
  exponentiale,
  fallingdotseq,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  ffr,
  filig,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof: fnof$1,
  fopf,
  forall: forall$1,
  fork,
  forkv,
  fpartint,
  frac1,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac3,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl: frasl$1,
  frown,
  fscr,
  gE,
  gEl,
  gacute,
  gamma: gamma$1,
  gammad,
  gap,
  gbreve,
  gcirc,
  gcy,
  gdot,
  ge: ge$1,
  gel,
  geq,
  geqq,
  geqslant,
  ges,
  gescc,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  gfr,
  gg,
  ggg,
  gimel,
  gjcy,
  gl: gl2,
  glE,
  gla,
  glj,
  gnE,
  gnap,
  gnapprox,
  gne,
  gneq,
  gneqq,
  gnsim,
  gopf,
  grave,
  gscr,
  gsim,
  gsime,
  gsiml,
  g: g2,
  gt: gt$1,
  gtcc,
  gtcir,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  hArr: hArr$1,
  hairsp,
  half,
  hamilt,
  hardcy,
  harr: harr$1,
  harrcir,
  harrw,
  hbar,
  hcirc,
  hearts: hearts$1,
  heartsuit,
  hellip: hellip$1,
  hercon,
  hfr,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  horbar,
  hscr,
  hslash,
  hstrok,
  hybull,
  hyphen,
  iacut,
  iacute: iacute$1,
  ic: ic2,
  icir,
  icirc: icirc$1,
  icy,
  iecy,
  iexc,
  iexcl: iexcl$1,
  iff,
  ifr,
  igrav,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  ijlig,
  imacr,
  image: image$3,
  imagline,
  imagpart,
  imath,
  imof,
  imped,
  incare,
  infin: infin$1,
  infintie,
  inodot,
  int: int$1,
  intcal,
  integers,
  intercal,
  intlarhk,
  intprod,
  iocy,
  iogon,
  iopf,
  iota: iota$1,
  iprod,
  iques,
  iquest: iquest$1,
  iscr,
  isin: isin$1,
  isinE,
  isindot,
  isins,
  isinsv,
  isinv,
  it: it2,
  itilde,
  iukcy,
  ium,
  iuml: iuml$1,
  jcirc,
  jcy,
  jfr,
  jmath,
  jopf,
  jscr,
  jsercy,
  jukcy,
  kappa: kappa$1,
  kappav,
  kcedil,
  kcy,
  kfr,
  kgreen,
  khcy,
  kjcy,
  kopf,
  kscr,
  lAarr,
  lArr: lArr$1,
  lAtail,
  lBarr,
  lE,
  lEg,
  lHar,
  lacute,
  laemptyv,
  lagran,
  lambda: lambda$1,
  lang: lang$1,
  langd,
  langle,
  lap,
  laqu,
  laquo: laquo$1,
  larr: larr$1,
  larrb,
  larrbfs,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  lat,
  latail,
  late,
  lates,
  lbarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  lcaron,
  lcedil,
  lceil: lceil$1,
  lcub,
  lcy,
  ldca,
  ldquo: ldquo$1,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le: le$1,
  leftarrow,
  leftarrowtail,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  leftthreetimes,
  leg,
  leq,
  leqq,
  leqslant,
  les,
  lescc,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  lessgtr,
  lesssim,
  lfisht,
  lfloor: lfloor$1,
  lfr,
  lg,
  lgE,
  lhard,
  lharu,
  lharul,
  lhblk,
  ljcy,
  ll: ll2,
  llarr,
  llcorner,
  llhard,
  lltri,
  lmidot,
  lmoust,
  lmoustache,
  lnE,
  lnap,
  lnapprox,
  lne,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  longleftrightarrow,
  longmapsto,
  longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  lopf,
  loplus,
  lotimes,
  lowast: lowast$1,
  lowbar,
  loz: loz$1,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm: lrm$1,
  lrtri,
  lsaquo: lsaquo$1,
  lscr,
  lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo: lsquo$1,
  lsquor,
  lstrok,
  l,
  lt: lt$1,
  ltcc,
  ltcir,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltrPar,
  ltri,
  ltrie,
  ltrif,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  mDDot,
  mac,
  macr: macr$1,
  male,
  malt,
  maltese,
  map: map$1,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  mcy,
  mdash: mdash$1,
  measuredangle,
  mfr,
  mho,
  micr,
  micro: micro$1,
  mid,
  midast,
  midcir,
  middo,
  middot: middot$1,
  minus: minus$1,
  minusb,
  minusd,
  minusdu,
  mlcp,
  mldr,
  mnplus,
  models,
  mopf,
  mp: mp2,
  mscr,
  mstpos,
  mu: mu$1,
  multimap,
  mumap,
  nGg,
  nGt,
  nGtv,
  nLeftarrow,
  nLeftrightarrow,
  nLl,
  nLt,
  nLtv,
  nRightarrow,
  nVDash,
  nVdash,
  nabla: nabla$1,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natur,
  natural,
  naturals,
  nbs,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  ncaron,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  ncy,
  ndash: ndash$1,
  ne: ne$1,
  neArr,
  nearhk,
  nearr,
  nearrow,
  nedot,
  nequiv,
  nesear,
  nesim,
  nexist,
  nexists,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  ngsim,
  ngt,
  ngtr,
  nhArr,
  nharr,
  nhpar,
  ni: ni$1,
  nis,
  nisd,
  niv,
  njcy,
  nlArr,
  nlE,
  nlarr,
  nldr,
  nle,
  nleftarrow,
  nleftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nlsim,
  nlt,
  nltri,
  nltrie,
  nmid,
  nopf,
  no: no2,
  not: not$1,
  notin: notin$1,
  notinE,
  notindot,
  notinva,
  notinvb,
  notinvc,
  notni,
  notniva,
  notnivb,
  notnivc,
  npar,
  nparallel,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  npre,
  nprec,
  npreceq,
  nrArr,
  nrarr,
  nrarrc,
  nrarrw,
  nrightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub: nsub$1,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  ntild,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  nu: nu$1,
  num,
  numero,
  numsp,
  nvDash,
  nvHarr,
  nvap,
  nvdash,
  nvge,
  nvgt,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwArr,
  nwarhk,
  nwarr,
  nwarrow,
  nwnear,
  oS,
  oacut,
  oacute: oacute$1,
  oast,
  ocir,
  ocirc: ocirc$1,
  ocy,
  odash,
  odblac,
  odiv,
  odot,
  odsold,
  oelig: oelig$1,
  ofcir,
  ofr,
  ogon,
  ograv,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline: oline$1,
  olt,
  omacr,
  omega: omega$1,
  omicron: omicron$1,
  omid,
  ominus,
  oopf,
  opar,
  operp,
  oplus: oplus$1,
  or: or$1,
  orarr,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oscr,
  oslas,
  oslash: oslash$1,
  osol,
  otild,
  otilde: otilde$1,
  otimes: otimes$1,
  otimesas,
  oum,
  ouml: ouml$1,
  ovbar,
  par,
  para: para$1,
  parallel,
  parsim,
  parsl,
  part: part$1,
  pcy,
  percnt,
  period,
  permil: permil$1,
  perp: perp$1,
  pertenk,
  pfr,
  phi: phi$1,
  phiv,
  phmmat,
  phone,
  pi: pi$1,
  pitchfork,
  piv: piv$1,
  planck,
  planckh,
  plankv,
  plus,
  plusacir,
  plusb,
  pluscir,
  plusdo,
  plusdu,
  pluse,
  plusm,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  pointint,
  popf,
  poun,
  pound: pound$1,
  pr,
  prE,
  prap,
  prcue,
  pre,
  prec,
  precapprox,
  preccurlyeq,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  precsim,
  prime: prime$1,
  primes,
  prnE,
  prnap,
  prnsim,
  prod: prod$1,
  profalar,
  profline,
  profsurf,
  prop: prop$1,
  propto,
  prsim,
  prurel,
  pscr,
  psi: psi$1,
  puncsp,
  qfr,
  qint,
  qopf,
  qprime,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quo,
  quot: quot$1,
  rAarr,
  rArr: rArr$1,
  rAtail,
  rBarr,
  rHar,
  race,
  racute,
  radic: radic$1,
  raemptyv,
  rang: rang$1,
  rangd,
  range,
  rangle,
  raqu,
  raquo: raquo$1,
  rarr: rarr$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  rarrtl,
  rarrw,
  ratail,
  ratio,
  rationals,
  rbarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  rcaron,
  rcedil,
  rceil: rceil$1,
  rcub,
  rcy,
  rdca,
  rdldhar,
  rdquo: rdquo$1,
  rdquor,
  rdsh,
  real: real$1,
  realine,
  realpart,
  reals,
  rect,
  re: re$3,
  reg: reg$1,
  rfisht,
  rfloor: rfloor$1,
  rfr,
  rhard,
  rharu,
  rharul,
  rho: rho$1,
  rhov,
  rightarrow,
  rightarrowtail,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  rightthreetimes,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm: rlm$1,
  rmoust,
  rmoustache,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  roplus,
  rotimes,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  rsaquo: rsaquo$1,
  rscr,
  rsh,
  rsqb,
  rsquo: rsquo$1,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  ruluhar,
  rx,
  sacute,
  sbquo: sbquo$1,
  sc: sc2,
  scE,
  scap,
  scaron: scaron$1,
  sccue,
  sce,
  scedil,
  scirc,
  scnE,
  scnap,
  scnsim,
  scpolint,
  scsim,
  scy,
  sdot: sdot$1,
  sdotb,
  sdote,
  seArr,
  searhk,
  searr,
  searrow,
  sec,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  sfr,
  sfrown,
  sharp,
  shchcy,
  shcy,
  shortmid,
  shortparallel,
  sh: sh2,
  shy: shy$1,
  sigma: sigma$1,
  sigmaf: sigmaf$1,
  sigmav,
  sim: sim$1,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  softcy,
  sol,
  solb,
  solbar,
  sopf,
  spades: spades$1,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  squ,
  square,
  squarf,
  squf,
  srarr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub: sub$1,
  subE,
  subdot,
  sube: sube$1,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  subseteq,
  subseteqq,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succ,
  succapprox,
  succcurlyeq,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  sum: sum$1,
  sung,
  sup: sup$1,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  supE,
  supdot,
  supdsub,
  supe: supe$1,
  supedot,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swArr,
  swarhk,
  swarr,
  swarrow,
  swnwar,
  szli,
  szlig: szlig$1,
  target,
  tau: tau$1,
  tbrk,
  tcaron,
  tcedil,
  tcy,
  tdot,
  telrec,
  tfr,
  there4: there4$1,
  therefore,
  theta: theta$1,
  thetasym: thetasym$1,
  thetav,
  thickapprox,
  thicksim,
  thinsp: thinsp$1,
  thkap,
  thksim,
  thor,
  thorn: thorn$1,
  tilde: tilde$4,
  time,
  times: times$1,
  timesb,
  timesbar,
  timesd,
  tint,
  toea,
  top,
  topbot,
  topcir,
  topf,
  topfork,
  tosa,
  tprime,
  trade: trade$1,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  triplus,
  trisb,
  tritime,
  trpezium,
  tscr,
  tscy,
  tshcy,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  uArr: uArr$1,
  uHar,
  uacut,
  uacute: uacute$1,
  uarr: uarr$1,
  ubrcy,
  ubreve,
  ucir,
  ucirc: ucirc$1,
  ucy,
  udarr,
  udblac,
  udhar,
  ufisht,
  ufr,
  ugrav,
  ugrave: ugrave$1,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  umacr,
  um,
  uml: uml$1,
  uogon,
  uopf,
  uparrow,
  updownarrow,
  upharpoonleft,
  upharpoonright,
  uplus,
  upsi,
  upsih: upsih$1,
  upsilon: upsilon$1,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  uring,
  urtri,
  uscr,
  utdot,
  utilde,
  utri,
  utrif,
  uuarr,
  uum,
  uuml: uuml$1,
  uwangle,
  vArr,
  vBar,
  vBarv,
  vDash,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vcy,
  vdash,
  vee,
  veebar,
  veeeq,
  vellip,
  verbar,
  vert,
  vfr,
  vltri,
  vnsub,
  vnsup,
  vopf,
  vprop,
  vrtri,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  vzigzag,
  wcirc,
  wedbar,
  wedge,
  wedgeq,
  weierp: weierp$1,
  wfr,
  wopf,
  wp: wp2,
  wr: wr2,
  wreath,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  xfr,
  xhArr,
  xharr,
  xi: xi$1,
  xlArr,
  xlarr,
  xmap,
  xnis,
  xodot,
  xopf,
  xoplus,
  xotime,
  xrArr,
  xrarr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  yacut,
  yacute: yacute$1,
  yacy,
  ycirc,
  ycy,
  ye: ye2,
  yen: yen$1,
  yfr,
  yicy,
  yopf,
  yscr,
  yucy,
  yum,
  yuml: yuml$1,
  zacute,
  zcaron,
  zcy,
  zdot,
  zeetrf,
  zeta: zeta$1,
  zfr,
  zhcy,
  zigrarr,
  zopf,
  zscr,
  zwj: zwj$1,
  zwnj: zwnj$1,
  "default": index$3
});
var characterEntities = getCjsExportFromNamespace2(characterEntities$1);
var decodeEntity_1 = decodeEntity;
var own$c = {}.hasOwnProperty;
function decodeEntity(characters2) {
  return own$c.call(characterEntities, characters2) ? characterEntities[characters2] : false;
}
var legacy = getCjsExportFromNamespace2(characterEntitiesLegacy);
var invalid = getCjsExportFromNamespace2(characterReferenceInvalid);
var parseEntities_1 = parseEntities;
var own$b = {}.hasOwnProperty;
var fromCharCode = String.fromCharCode;
var noop = Function.prototype;
var defaults$3 = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: false,
  nonTerminated: true
};
var tab$e = 9;
var lineFeed$j = 10;
var formFeed = 12;
var space$j = 32;
var ampersand$1 = 38;
var semicolon$1 = 59;
var lessThan$8 = 60;
var equalsTo$2 = 61;
var numberSign$1 = 35;
var uppercaseX = 88;
var lowercaseX$1 = 120;
var replacementCharacter = 65533;
var name$12 = "named";
var hexa = "hexadecimal";
var deci = "decimal";
var bases = {};
bases[hexa] = 16;
bases[deci] = 10;
var tests = {};
tests[name$12] = isAlphanumerical;
tests[deci] = isDecimal;
tests[hexa] = isHexadecimal;
var namedNotTerminated = 1;
var numericNotTerminated = 2;
var namedEmpty = 3;
var numericEmpty = 4;
var namedUnknown = 5;
var numericDisallowed = 6;
var numericProhibited = 7;
var messages = {};
messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
messages[namedEmpty] = "Named character references cannot be empty";
messages[numericEmpty] = "Numeric character references cannot be empty";
messages[namedUnknown] = "Named character references must be known";
messages[numericDisallowed] = "Numeric character references cannot be disallowed";
messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
function parseEntities(value, options2) {
  var settings = {};
  var option2;
  var key;
  if (!options2) {
    options2 = {};
  }
  for (key in defaults$3) {
    option2 = options2[key];
    settings[key] = option2 === null || option2 === void 0 ? defaults$3[key] : option2;
  }
  if (settings.position.indent || settings.position.start) {
    settings.indent = settings.position.indent || [];
    settings.position = settings.position.start;
  }
  return parse$72(value, settings);
}
function parse$72(value, settings) {
  var additional = settings.additional;
  var nonTerminated = settings.nonTerminated;
  var handleText = settings.text;
  var handleReference = settings.reference;
  var handleWarning = settings.warning;
  var textContext = settings.textContext;
  var referenceContext = settings.referenceContext;
  var warningContext = settings.warningContext;
  var pos = settings.position;
  var indent = settings.indent || [];
  var length = value.length;
  var index2 = 0;
  var lines = -1;
  var column = pos.column || 1;
  var line2 = pos.line || 1;
  var queue = "";
  var result = [];
  var entityCharacters;
  var namedEntity;
  var terminated;
  var characters2;
  var character;
  var reference2;
  var following;
  var warning;
  var reason;
  var output;
  var entity;
  var begin;
  var start2;
  var type2;
  var test2;
  var prev;
  var next;
  var diff;
  var end2;
  if (typeof additional === "string") {
    additional = additional.charCodeAt(0);
  }
  prev = now2();
  warning = handleWarning ? parseError : noop;
  index2--;
  length++;
  while (++index2 < length) {
    if (character === lineFeed$j) {
      column = indent[lines] || 1;
    }
    character = value.charCodeAt(index2);
    if (character === ampersand$1) {
      following = value.charCodeAt(index2 + 1);
      if (following === tab$e || following === lineFeed$j || following === formFeed || following === space$j || following === ampersand$1 || following === lessThan$8 || following !== following || additional && following === additional) {
        queue += fromCharCode(character);
        column++;
        continue;
      }
      start2 = index2 + 1;
      begin = start2;
      end2 = start2;
      if (following === numberSign$1) {
        end2 = ++begin;
        following = value.charCodeAt(end2);
        if (following === uppercaseX || following === lowercaseX$1) {
          type2 = hexa;
          end2 = ++begin;
        } else {
          type2 = deci;
        }
      } else {
        type2 = name$12;
      }
      entityCharacters = "";
      entity = "";
      characters2 = "";
      test2 = tests[type2];
      end2--;
      while (++end2 < length) {
        following = value.charCodeAt(end2);
        if (!test2(following)) {
          break;
        }
        characters2 += fromCharCode(following);
        if (type2 === name$12 && own$b.call(legacy, characters2)) {
          entityCharacters = characters2;
          entity = legacy[characters2];
        }
      }
      terminated = value.charCodeAt(end2) === semicolon$1;
      if (terminated) {
        end2++;
        namedEntity = type2 === name$12 ? decodeEntity_1(characters2) : false;
        if (namedEntity) {
          entityCharacters = characters2;
          entity = namedEntity;
        }
      }
      diff = 1 + end2 - start2;
      if (!terminated && !nonTerminated)
        ;
      else if (!characters2) {
        if (type2 !== name$12) {
          warning(numericEmpty, diff);
        }
      } else if (type2 === name$12) {
        if (terminated && !entity) {
          warning(namedUnknown, 1);
        } else {
          if (entityCharacters !== characters2) {
            end2 = begin + entityCharacters.length;
            diff = 1 + end2 - begin;
            terminated = false;
          }
          if (!terminated) {
            reason = entityCharacters ? namedNotTerminated : namedEmpty;
            if (settings.attribute) {
              following = value.charCodeAt(end2);
              if (following === equalsTo$2) {
                warning(reason, diff);
                entity = null;
              } else if (isAlphanumerical(following)) {
                entity = null;
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }
        reference2 = entity;
      } else {
        if (!terminated) {
          warning(numericNotTerminated, diff);
        }
        reference2 = parseInt(characters2, bases[type2]);
        if (prohibited(reference2)) {
          warning(numericProhibited, diff);
          reference2 = fromCharCode(replacementCharacter);
        } else if (reference2 in invalid) {
          warning(numericDisallowed, diff);
          reference2 = invalid[reference2];
        } else {
          output = "";
          if (disallowed(reference2)) {
            warning(numericDisallowed, diff);
          }
          if (reference2 > 65535) {
            reference2 -= 65536;
            output += fromCharCode(reference2 >>> (10 & 1023) | 55296);
            reference2 = 56320 | reference2 & 1023;
          }
          reference2 = output + fromCharCode(reference2);
        }
      }
      if (reference2) {
        flush();
        prev = now2();
        index2 = end2 - 1;
        column += end2 - start2 + 1;
        result.push(reference2);
        next = now2();
        next.offset++;
        if (handleReference) {
          handleReference.call(
            referenceContext,
            reference2,
            { start: prev, end: next },
            value.slice(start2 - 1, end2)
          );
        }
        prev = next;
      } else {
        characters2 = value.slice(start2 - 1, end2);
        queue += characters2;
        column += characters2.length;
        index2 = end2 - 1;
      }
    } else {
      if (character === 10) {
        line2++;
        lines++;
        column = 0;
      }
      if (character === character) {
        queue += fromCharCode(character);
        column++;
      } else {
        flush();
      }
    }
  }
  return result.join("");
  function now2() {
    return {
      line: line2,
      column,
      offset: index2 + (pos.offset || 0)
    };
  }
  function parseError(code2, offset2) {
    var position2 = now2();
    position2.column += offset2;
    position2.offset += offset2;
    handleWarning.call(warningContext, messages[code2], position2, code2);
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (handleText) {
        handleText.call(textContext, queue, { start: prev, end: now2() });
      }
      queue = "";
    }
  }
}
function prohibited(code2) {
  return code2 >= 55296 && code2 <= 57343 || code2 > 1114111;
}
function disallowed(code2) {
  return code2 >= 1 && code2 <= 8 || code2 === 11 || code2 >= 13 && code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 64976 && code2 <= 65007 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534;
}
var decode = factory$3;
function factory$3(ctx) {
  decoder.raw = decodeRaw;
  return decoder;
  function normalize3(position2) {
    var offsets = ctx.offset;
    var line2 = position2.line;
    var result = [];
    while (++line2) {
      if (!(line2 in offsets)) {
        break;
      }
      result.push((offsets[line2] || 0) + 1);
    }
    return { start: position2, indent: result };
  }
  function decoder(value, position2, handler) {
    parseEntities_1(value, {
      position: normalize3(position2),
      warning: handleWarning,
      text: handler,
      reference: handler,
      textContext: ctx,
      referenceContext: ctx
    });
  }
  function decodeRaw(value, position2, options2) {
    return parseEntities_1(
      value,
      immutable(options2, { position: normalize3(position2), warning: handleWarning })
    );
  }
  function handleWarning(reason, position2, code2) {
    if (code2 !== 3) {
      ctx.file.message(reason, position2);
    }
  }
}
var tokenizer$1 = factory$2;
function factory$2(type2) {
  return tokenize2;
  function tokenize2(value, location) {
    var self2 = this;
    var offset2 = self2.offset;
    var tokens = [];
    var methods = self2[type2 + "Methods"];
    var tokenizers = self2[type2 + "Tokenizers"];
    var line2 = location.line;
    var column = location.column;
    var index2;
    var length;
    var method;
    var name3;
    var matched;
    var valueLength;
    if (!value) {
      return tokens;
    }
    eat2.now = now2;
    eat2.file = self2.file;
    updatePosition("");
    while (value) {
      index2 = -1;
      length = methods.length;
      matched = false;
      while (++index2 < length) {
        name3 = methods[index2];
        method = tokenizers[name3];
        if (method && /* istanbul ignore next */
        (!method.onlyAtStart || self2.atStart) && /* istanbul ignore next */
        (!method.notInList || !self2.inList) && /* istanbul ignore next */
        (!method.notInBlock || !self2.inBlock) && (!method.notInLink || !self2.inLink)) {
          valueLength = value.length;
          method.apply(self2, [eat2, value]);
          matched = valueLength !== value.length;
          if (matched) {
            break;
          }
        }
      }
      if (!matched) {
        self2.file.fail(new Error("Infinite loop"), eat2.now());
      }
    }
    self2.eof = now2();
    return tokens;
    function updatePosition(subvalue) {
      var lastIndex = -1;
      var index3 = subvalue.indexOf("\n");
      while (index3 !== -1) {
        line2++;
        lastIndex = index3;
        index3 = subvalue.indexOf("\n", index3 + 1);
      }
      if (lastIndex === -1) {
        column += subvalue.length;
      } else {
        column = subvalue.length - lastIndex;
      }
      if (line2 in offset2) {
        if (lastIndex !== -1) {
          column += offset2[line2];
        } else if (column <= offset2[line2]) {
          column = offset2[line2] + 1;
        }
      }
    }
    function getOffset() {
      var indentation2 = [];
      var pos = line2 + 1;
      return function() {
        var last = line2 + 1;
        while (pos < last) {
          indentation2.push((offset2[pos] || 0) + 1);
          pos++;
        }
        return indentation2;
      };
    }
    function now2() {
      var pos = { line: line2, column };
      pos.offset = self2.toOffset(pos);
      return pos;
    }
    function Position3(start2) {
      this.start = start2;
      this.end = now2();
    }
    function validateEat(subvalue) {
      if (value.slice(0, subvalue.length) !== subvalue) {
        self2.file.fail(
          new Error(
            "Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"
          ),
          now2()
        );
      }
    }
    function position2() {
      var before2 = now2();
      return update;
      function update(node2, indent) {
        var previous = node2.position;
        var start2 = previous ? previous.start : before2;
        var combined = [];
        var n = previous && previous.end.line;
        var l2 = before2.line;
        node2.position = new Position3(start2);
        if (previous && indent && previous.indent) {
          combined = previous.indent;
          if (n < l2) {
            while (++n < l2) {
              combined.push((offset2[n] || 0) + 1);
            }
            combined.push(before2.column);
          }
          indent = combined.concat(indent);
        }
        node2.position.indent = indent || [];
        return node2;
      }
    }
    function add(node2, parent) {
      var children = parent ? parent.children : tokens;
      var previous = children[children.length - 1];
      var fn2;
      if (previous && node2.type === previous.type && (node2.type === "text" || node2.type === "blockquote") && mergeable(previous) && mergeable(node2)) {
        fn2 = node2.type === "text" ? mergeText : mergeBlockquote;
        node2 = fn2.call(self2, previous, node2);
      }
      if (node2 !== previous) {
        children.push(node2);
      }
      if (self2.atStart && tokens.length !== 0) {
        self2.exitStart();
      }
      return node2;
    }
    function eat2(subvalue) {
      var indent = getOffset();
      var pos = position2();
      var current2 = now2();
      validateEat(subvalue);
      apply.reset = reset2;
      reset2.test = test2;
      apply.test = test2;
      value = value.slice(subvalue.length);
      updatePosition(subvalue);
      indent = indent();
      return apply;
      function apply(node2, parent) {
        return pos(add(pos(node2), parent), indent);
      }
      function reset2() {
        var node2 = apply.apply(null, arguments);
        line2 = current2.line;
        column = current2.column;
        value = subvalue + value;
        return node2;
      }
      function test2() {
        var result = pos({});
        line2 = current2.line;
        column = current2.column;
        value = subvalue + value;
        return result.position;
      }
    }
  }
}
function mergeable(node2) {
  var start2;
  var end2;
  if (node2.type !== "text" || !node2.position) {
    return true;
  }
  start2 = node2.position.start;
  end2 = node2.position.end;
  return start2.line !== end2.line || end2.column - start2.column === node2.value.length;
}
function mergeText(previous, node2) {
  previous.value += node2.value;
  return previous;
}
function mergeBlockquote(previous, node2) {
  if (this.options.commonmark || this.options.gfm) {
    return node2;
  }
  previous.children = previous.children.concat(node2.children);
  return previous;
}
var markdownEscapes = escapes$1;
var defaults$2 = [
  "\\",
  "`",
  "*",
  "{",
  "}",
  "[",
  "]",
  "(",
  ")",
  "#",
  "+",
  "-",
  ".",
  "!",
  "_",
  ">"
];
var gfm = defaults$2.concat(["~", "|"]);
var commonmark = gfm.concat([
  "\n",
  '"',
  "$",
  "%",
  "&",
  "'",
  ",",
  "/",
  ":",
  ";",
  "<",
  "=",
  "?",
  "@",
  "^"
]);
escapes$1.default = defaults$2;
escapes$1.gfm = gfm;
escapes$1.commonmark = commonmark;
function escapes$1(options2) {
  var settings = options2 || {};
  if (settings.commonmark) {
    return commonmark;
  }
  return settings.gfm ? gfm : defaults$2;
}
var blockElements = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "meta",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "pre",
  "section",
  "source",
  "title",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var defaults$1 = {
  position: true,
  gfm: true,
  commonmark: false,
  pedantic: false,
  blocks: blockElements
};
var setOptions_1 = setOptions;
function setOptions(options2) {
  var self2 = this;
  var current2 = self2.options;
  var key;
  var value;
  if (options2 == null) {
    options2 = {};
  } else if (typeof options2 === "object") {
    options2 = immutable(options2);
  } else {
    throw new Error("Invalid value `" + options2 + "` for setting `options`");
  }
  for (key in defaults$1) {
    value = options2[key];
    if (value == null) {
      value = current2[key];
    }
    if (key !== "blocks" && typeof value !== "boolean" || key === "blocks" && typeof value !== "object") {
      throw new Error(
        "Invalid value `" + value + "` for setting `options." + key + "`"
      );
    }
    options2[key] = value;
  }
  self2.options = options2;
  self2.escape = markdownEscapes(options2);
  return self2;
}
var convert_1 = convert$1;
function convert$1(test2) {
  if (test2 == null) {
    return ok$1;
  }
  if (typeof test2 === "string") {
    return typeFactory$1(test2);
  }
  if (typeof test2 === "object") {
    return "length" in test2 ? anyFactory$1(test2) : allFactory(test2);
  }
  if (typeof test2 === "function") {
    return test2;
  }
  throw new Error("Expected function, string, or object as test");
}
function allFactory(test2) {
  return all2;
  function all2(node2) {
    var key;
    for (key in test2) {
      if (node2[key] !== test2[key])
        return false;
    }
    return true;
  }
}
function anyFactory$1(tests2) {
  var checks2 = [];
  var index2 = -1;
  while (++index2 < tests2.length) {
    checks2[index2] = convert$1(tests2[index2]);
  }
  return any;
  function any() {
    var index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  }
}
function typeFactory$1(test2) {
  return type2;
  function type2(node2) {
    return Boolean(node2 && node2.type === test2);
  }
}
function ok$1() {
  return true;
}
var color_1 = color;
function color(d2) {
  return "\x1B[33m" + d2 + "\x1B[39m";
}
var unistUtilVisitParents = visitParents;
var CONTINUE$1 = true;
var SKIP$1 = "skip";
var EXIT$1 = false;
visitParents.CONTINUE = CONTINUE$1;
visitParents.SKIP = SKIP$1;
visitParents.EXIT = EXIT$1;
function visitParents(tree, test2, visitor, reverse) {
  var step;
  var is4;
  if (typeof test2 === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test2;
    test2 = null;
  }
  is4 = convert_1(test2);
  step = reverse ? -1 : 1;
  factory2(tree, null, [])();
  function factory2(node2, index2, parents) {
    var value = typeof node2 === "object" && node2 !== null ? node2 : {};
    var name3;
    if (typeof value.type === "string") {
      name3 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
      visit2.displayName = "node (" + color_1(value.type + (name3 ? "<" + name3 + ">" : "")) + ")";
    }
    return visit2;
    function visit2() {
      var grandparents = parents.concat(node2);
      var result = [];
      var subresult;
      var offset2;
      if (!test2 || is4(node2, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT$1) {
          return result;
        }
      }
      if (node2.children && result[0] !== SKIP$1) {
        offset2 = (reverse ? node2.children.length : -1) + step;
        while (offset2 > -1 && offset2 < node2.children.length) {
          subresult = factory2(node2.children[offset2], offset2, grandparents)();
          if (subresult[0] === EXIT$1) {
            return subresult;
          }
          offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (value !== null && typeof value === "object" && "length" in value) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE$1, value];
  }
  return [value];
}
var unistUtilVisit = visit;
var CONTINUE = unistUtilVisitParents.CONTINUE;
var SKIP = unistUtilVisitParents.SKIP;
var EXIT = unistUtilVisitParents.EXIT;
visit.CONTINUE = CONTINUE;
visit.SKIP = SKIP;
visit.EXIT = EXIT;
function visit(tree, test2, visitor, reverse) {
  if (typeof test2 === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test2;
    test2 = null;
  }
  unistUtilVisitParents(tree, test2, overload, reverse);
  function overload(node2, parents) {
    var parent = parents[parents.length - 1];
    var index2 = parent ? parent.children.indexOf(node2) : null;
    return visitor(node2, index2, parent);
  }
}
var unistUtilRemovePosition = removePosition;
function removePosition(node2, force) {
  unistUtilVisit(node2, force ? hard : soft);
  return node2;
}
function hard(node2) {
  delete node2.position;
}
function soft(node2) {
  node2.position = void 0;
}
var parse_1$2 = parse$62;
var lineFeed$i = "\n";
var lineBreaksExpression = /\r\n|\r/g;
function parse$62() {
  var self2 = this;
  var value = String(self2.file);
  var start2 = { line: 1, column: 1, offset: 0 };
  var content = immutable(start2);
  var node2;
  value = value.replace(lineBreaksExpression, lineFeed$i);
  if (value.charCodeAt(0) === 65279) {
    value = value.slice(1);
    content.column++;
    content.offset++;
  }
  node2 = {
    type: "root",
    children: self2.tokenizeBlock(value, content),
    position: { start: start2, end: self2.eof || immutable(start2) }
  };
  if (!self2.options.position) {
    unistUtilRemovePosition(node2, true);
  }
  return node2;
}
var reBlankLine = /^[ \t]*(\n|$)/;
var blankLine_1 = blankLine;
function blankLine(eat2, value, silent) {
  var match;
  var subvalue = "";
  var index2 = 0;
  var length = value.length;
  while (index2 < length) {
    match = reBlankLine.exec(value.slice(index2));
    if (match == null) {
      break;
    }
    index2 += match[0].length;
    subvalue += match[0];
  }
  if (subvalue === "") {
    return;
  }
  if (silent) {
    return true;
  }
  eat2(subvalue);
}
var res = "";
var cache;
var repeatString = repeat$1;
function repeat$1(str2, num2) {
  if (typeof str2 !== "string") {
    throw new TypeError("expected a string");
  }
  if (num2 === 1)
    return str2;
  if (num2 === 2)
    return str2 + str2;
  var max = str2.length * num2;
  if (cache !== str2 || typeof cache === "undefined") {
    cache = str2;
    res = "";
  } else if (res.length >= max) {
    return res.substr(0, max);
  }
  while (max > res.length && num2 > 1) {
    if (num2 & 1) {
      res += str2;
    }
    num2 >>= 1;
    str2 += str2;
  }
  res += str2;
  res = res.substr(0, max);
  return res;
}
var trimTrailingLines_1 = trimTrailingLines;
var line = "\n";
function trimTrailingLines(value) {
  var val = String(value);
  var index2 = val.length;
  while (val.charAt(--index2) === line) {
  }
  return val.slice(0, index2 + 1);
}
var codeIndented = indentedCode$1;
var lineFeed$h = "\n";
var tab$d = "	";
var space$i = " ";
var tabSize$4 = 4;
var codeIndent = repeatString(space$i, tabSize$4);
function indentedCode$1(eat2, value, silent) {
  var index2 = -1;
  var length = value.length;
  var subvalue = "";
  var content = "";
  var subvalueQueue = "";
  var contentQueue = "";
  var character;
  var blankQueue;
  var indent;
  while (++index2 < length) {
    character = value.charAt(index2);
    if (indent) {
      indent = false;
      subvalue += subvalueQueue;
      content += contentQueue;
      subvalueQueue = "";
      contentQueue = "";
      if (character === lineFeed$h) {
        subvalueQueue = character;
        contentQueue = character;
      } else {
        subvalue += character;
        content += character;
        while (++index2 < length) {
          character = value.charAt(index2);
          if (!character || character === lineFeed$h) {
            contentQueue = character;
            subvalueQueue = character;
            break;
          }
          subvalue += character;
          content += character;
        }
      }
    } else if (character === space$i && value.charAt(index2 + 1) === character && value.charAt(index2 + 2) === character && value.charAt(index2 + 3) === character) {
      subvalueQueue += codeIndent;
      index2 += 3;
      indent = true;
    } else if (character === tab$d) {
      subvalueQueue += character;
      indent = true;
    } else {
      blankQueue = "";
      while (character === tab$d || character === space$i) {
        blankQueue += character;
        character = value.charAt(++index2);
      }
      if (character !== lineFeed$h) {
        break;
      }
      subvalueQueue += blankQueue + character;
      contentQueue += character;
    }
  }
  if (content) {
    if (silent) {
      return true;
    }
    return eat2(subvalue)({
      type: "code",
      lang: null,
      meta: null,
      value: trimTrailingLines_1(content)
    });
  }
}
var codeFenced = fencedCode;
var lineFeed$g = "\n";
var tab$c = "	";
var space$h = " ";
var tilde$3 = "~";
var graveAccent$2 = "`";
var minFenceCount = 3;
var tabSize$3 = 4;
function fencedCode(eat2, value, silent) {
  var self2 = this;
  var gfm2 = self2.options.gfm;
  var length = value.length + 1;
  var index2 = 0;
  var subvalue = "";
  var fenceCount;
  var marker2;
  var character;
  var flag;
  var lang2;
  var meta2;
  var queue;
  var content;
  var exdentedContent;
  var closing2;
  var exdentedClosing;
  var indent;
  var now2;
  if (!gfm2) {
    return;
  }
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== space$h && character !== tab$c) {
      break;
    }
    subvalue += character;
    index2++;
  }
  indent = index2;
  character = value.charAt(index2);
  if (character !== tilde$3 && character !== graveAccent$2) {
    return;
  }
  index2++;
  marker2 = character;
  fenceCount = 1;
  subvalue += character;
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== marker2) {
      break;
    }
    subvalue += character;
    fenceCount++;
    index2++;
  }
  if (fenceCount < minFenceCount) {
    return;
  }
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== space$h && character !== tab$c) {
      break;
    }
    subvalue += character;
    index2++;
  }
  flag = "";
  queue = "";
  while (index2 < length) {
    character = value.charAt(index2);
    if (character === lineFeed$g || marker2 === graveAccent$2 && character === marker2) {
      break;
    }
    if (character === space$h || character === tab$c) {
      queue += character;
    } else {
      flag += queue + character;
      queue = "";
    }
    index2++;
  }
  character = value.charAt(index2);
  if (character && character !== lineFeed$g) {
    return;
  }
  if (silent) {
    return true;
  }
  now2 = eat2.now();
  now2.column += subvalue.length;
  now2.offset += subvalue.length;
  subvalue += flag;
  flag = self2.decode.raw(self2.unescape(flag), now2);
  if (queue) {
    subvalue += queue;
  }
  queue = "";
  closing2 = "";
  exdentedClosing = "";
  content = "";
  exdentedContent = "";
  var skip = true;
  while (index2 < length) {
    character = value.charAt(index2);
    content += closing2;
    exdentedContent += exdentedClosing;
    closing2 = "";
    exdentedClosing = "";
    if (character !== lineFeed$g) {
      content += character;
      exdentedClosing += character;
      index2++;
      continue;
    }
    if (skip) {
      subvalue += character;
      skip = false;
    } else {
      closing2 += character;
      exdentedClosing += character;
    }
    queue = "";
    index2++;
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== space$h) {
        break;
      }
      queue += character;
      index2++;
    }
    closing2 += queue;
    exdentedClosing += queue.slice(indent);
    if (queue.length >= tabSize$3) {
      continue;
    }
    queue = "";
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== marker2) {
        break;
      }
      queue += character;
      index2++;
    }
    closing2 += queue;
    exdentedClosing += queue;
    if (queue.length < fenceCount) {
      continue;
    }
    queue = "";
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== space$h && character !== tab$c) {
        break;
      }
      closing2 += character;
      exdentedClosing += character;
      index2++;
    }
    if (!character || character === lineFeed$g) {
      break;
    }
  }
  subvalue += content + closing2;
  index2 = -1;
  length = flag.length;
  while (++index2 < length) {
    character = flag.charAt(index2);
    if (character === space$h || character === tab$c) {
      if (!lang2) {
        lang2 = flag.slice(0, index2);
      }
    } else if (lang2) {
      meta2 = flag.slice(index2);
      break;
    }
  }
  return eat2(subvalue)({
    type: "code",
    lang: lang2 || flag || null,
    meta: meta2 || null,
    value: exdentedContent
  });
}
var trim_1 = createCommonjsModule2(function(module, exports) {
  exports = module.exports = trim;
  function trim(str2) {
    return str2.replace(/^\s*|\s*$/g, "");
  }
  exports.left = function(str2) {
    return str2.replace(/^\s*/, "");
  };
  exports.right = function(str2) {
    return str2.replace(/\s*$/, "");
  };
});
trim_1.left;
trim_1.right;
var interrupt_1 = interrupt;
function interrupt(interruptors, tokenizers, ctx, parameters) {
  var length = interruptors.length;
  var index2 = -1;
  var interruptor;
  var config;
  while (++index2 < length) {
    interruptor = interruptors[index2];
    config = interruptor[1] || {};
    if (config.pedantic !== void 0 && config.pedantic !== ctx.options.pedantic) {
      continue;
    }
    if (config.commonmark !== void 0 && config.commonmark !== ctx.options.commonmark) {
      continue;
    }
    if (tokenizers[interruptor[0]].apply(ctx, parameters)) {
      return true;
    }
  }
  return false;
}
var blockquote_1$1 = blockquote$1;
var lineFeed$f = "\n";
var tab$b = "	";
var space$g = " ";
var greaterThan$4 = ">";
function blockquote$1(eat2, value, silent) {
  var self2 = this;
  var offsets = self2.offset;
  var tokenizers = self2.blockTokenizers;
  var interruptors = self2.interruptBlockquote;
  var now2 = eat2.now();
  var currentLine = now2.line;
  var length = value.length;
  var values2 = [];
  var contents = [];
  var indents = [];
  var add;
  var index2 = 0;
  var character;
  var rest;
  var nextIndex2;
  var content;
  var line2;
  var startIndex;
  var prefixed;
  var exit;
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== space$g && character !== tab$b) {
      break;
    }
    index2++;
  }
  if (value.charAt(index2) !== greaterThan$4) {
    return;
  }
  if (silent) {
    return true;
  }
  index2 = 0;
  while (index2 < length) {
    nextIndex2 = value.indexOf(lineFeed$f, index2);
    startIndex = index2;
    prefixed = false;
    if (nextIndex2 === -1) {
      nextIndex2 = length;
    }
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== space$g && character !== tab$b) {
        break;
      }
      index2++;
    }
    if (value.charAt(index2) === greaterThan$4) {
      index2++;
      prefixed = true;
      if (value.charAt(index2) === space$g) {
        index2++;
      }
    } else {
      index2 = startIndex;
    }
    content = value.slice(index2, nextIndex2);
    if (!prefixed && !trim_1(content)) {
      index2 = startIndex;
      break;
    }
    if (!prefixed) {
      rest = value.slice(index2);
      if (interrupt_1(interruptors, tokenizers, self2, [eat2, rest, true])) {
        break;
      }
    }
    line2 = startIndex === index2 ? content : value.slice(startIndex, nextIndex2);
    indents.push(index2 - startIndex);
    values2.push(line2);
    contents.push(content);
    index2 = nextIndex2 + 1;
  }
  index2 = -1;
  length = indents.length;
  add = eat2(values2.join(lineFeed$f));
  while (++index2 < length) {
    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index2];
    currentLine++;
  }
  exit = self2.enterBlock();
  contents = self2.tokenizeBlock(contents.join(lineFeed$f), now2);
  exit();
  return add({ type: "blockquote", children: contents });
}
var headingAtx = atxHeading;
var lineFeed$e = "\n";
var tab$a = "	";
var space$f = " ";
var numberSign = "#";
var maxFenceCount = 6;
function atxHeading(eat2, value, silent) {
  var self2 = this;
  var pedantic = self2.options.pedantic;
  var length = value.length + 1;
  var index2 = -1;
  var now2 = eat2.now();
  var subvalue = "";
  var content = "";
  var character;
  var queue;
  var depth;
  while (++index2 < length) {
    character = value.charAt(index2);
    if (character !== space$f && character !== tab$a) {
      index2--;
      break;
    }
    subvalue += character;
  }
  depth = 0;
  while (++index2 <= length) {
    character = value.charAt(index2);
    if (character !== numberSign) {
      index2--;
      break;
    }
    subvalue += character;
    depth++;
  }
  if (depth > maxFenceCount) {
    return;
  }
  if (!depth || !pedantic && value.charAt(index2 + 1) === numberSign) {
    return;
  }
  length = value.length + 1;
  queue = "";
  while (++index2 < length) {
    character = value.charAt(index2);
    if (character !== space$f && character !== tab$a) {
      index2--;
      break;
    }
    queue += character;
  }
  if (!pedantic && queue.length === 0 && character && character !== lineFeed$e) {
    return;
  }
  if (silent) {
    return true;
  }
  subvalue += queue;
  queue = "";
  content = "";
  while (++index2 < length) {
    character = value.charAt(index2);
    if (!character || character === lineFeed$e) {
      break;
    }
    if (character !== space$f && character !== tab$a && character !== numberSign) {
      content += queue + character;
      queue = "";
      continue;
    }
    while (character === space$f || character === tab$a) {
      queue += character;
      character = value.charAt(++index2);
    }
    if (!pedantic && content && !queue && character === numberSign) {
      content += character;
      continue;
    }
    while (character === numberSign) {
      queue += character;
      character = value.charAt(++index2);
    }
    while (character === space$f || character === tab$a) {
      queue += character;
      character = value.charAt(++index2);
    }
    index2--;
  }
  now2.column += subvalue.length;
  now2.offset += subvalue.length;
  subvalue += content + queue;
  return eat2(subvalue)({
    type: "heading",
    depth,
    children: self2.tokenizeInline(content, now2)
  });
}
var thematicBreak_1$1 = thematicBreak$1;
var tab$9 = "	";
var lineFeed$d = "\n";
var space$e = " ";
var asterisk$4 = "*";
var dash$7 = "-";
var underscore$6 = "_";
var maxCount = 3;
function thematicBreak$1(eat2, value, silent) {
  var index2 = -1;
  var length = value.length + 1;
  var subvalue = "";
  var character;
  var marker2;
  var markerCount;
  var queue;
  while (++index2 < length) {
    character = value.charAt(index2);
    if (character !== tab$9 && character !== space$e) {
      break;
    }
    subvalue += character;
  }
  if (character !== asterisk$4 && character !== dash$7 && character !== underscore$6) {
    return;
  }
  marker2 = character;
  subvalue += character;
  markerCount = 1;
  queue = "";
  while (++index2 < length) {
    character = value.charAt(index2);
    if (character === marker2) {
      markerCount++;
      subvalue += queue + marker2;
      queue = "";
    } else if (character === space$e) {
      queue += character;
    } else if (markerCount >= maxCount && (!character || character === lineFeed$d)) {
      subvalue += queue;
      if (silent) {
        return true;
      }
      return eat2(subvalue)({ type: "thematicBreak" });
    } else {
      return;
    }
  }
}
var getIndentation = indentation$1;
var tab$8 = "	";
var space$d = " ";
var spaceSize = 1;
var tabSize$2 = 4;
function indentation$1(value) {
  var index2 = 0;
  var indent = 0;
  var character = value.charAt(index2);
  var stops = {};
  var size;
  var lastIndent = 0;
  while (character === tab$8 || character === space$d) {
    size = character === tab$8 ? tabSize$2 : spaceSize;
    indent += size;
    if (size > 1) {
      indent = Math.floor(indent / size) * size;
    }
    while (lastIndent < indent) {
      stops[++lastIndent] = index2;
    }
    character = value.charAt(++index2);
  }
  return { indent, stops };
}
var removeIndentation = indentation;
var lineFeed$c = "\n";
var space$c = " ";
var exclamationMark$4 = "!";
function indentation(value, maximum) {
  var values2 = value.split(lineFeed$c);
  var position2 = values2.length + 1;
  var minIndent = Infinity;
  var matrix = [];
  var index2;
  var indentation2;
  var stops;
  values2.unshift(repeatString(space$c, maximum) + exclamationMark$4);
  while (position2--) {
    indentation2 = getIndentation(values2[position2]);
    matrix[position2] = indentation2.stops;
    if (trim_1(values2[position2]).length === 0) {
      continue;
    }
    if (indentation2.indent) {
      if (indentation2.indent > 0 && indentation2.indent < minIndent) {
        minIndent = indentation2.indent;
      }
    } else {
      minIndent = Infinity;
      break;
    }
  }
  if (minIndent !== Infinity) {
    position2 = values2.length;
    while (position2--) {
      stops = matrix[position2];
      index2 = minIndent;
      while (index2 && !(index2 in stops)) {
        index2--;
      }
      values2[position2] = values2[position2].slice(stops[index2] + 1);
    }
  }
  values2.shift();
  return values2.join(lineFeed$c);
}
var list_1$1 = list$12;
var asterisk$3 = "*";
var underscore$5 = "_";
var plusSign$2 = "+";
var dash$6 = "-";
var dot$3 = ".";
var space$b = " ";
var lineFeed$b = "\n";
var tab$7 = "	";
var rightParenthesis$3 = ")";
var lowercaseX = "x";
var tabSize$1 = 4;
var looseListItemExpression = /\n\n(?!\s*$)/;
var taskItemExpression = /^\[([ X\tx])][ \t]/;
var bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var initialIndentExpression = /^( {1,4}|\t)?/gm;
function list$12(eat2, value, silent) {
  var self2 = this;
  var commonmark2 = self2.options.commonmark;
  var pedantic = self2.options.pedantic;
  var tokenizers = self2.blockTokenizers;
  var interuptors = self2.interruptList;
  var index2 = 0;
  var length = value.length;
  var start2 = null;
  var size;
  var queue;
  var ordered;
  var character;
  var marker2;
  var nextIndex2;
  var startIndex;
  var prefixed;
  var currentMarker;
  var content;
  var line2;
  var previousEmpty;
  var empty3;
  var items;
  var allLines;
  var emptyLines;
  var item;
  var enterTop;
  var exitBlockquote;
  var spread = false;
  var node2;
  var now2;
  var end2;
  var indented;
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== tab$7 && character !== space$b) {
      break;
    }
    index2++;
  }
  character = value.charAt(index2);
  if (character === asterisk$3 || character === plusSign$2 || character === dash$6) {
    marker2 = character;
    ordered = false;
  } else {
    ordered = true;
    queue = "";
    while (index2 < length) {
      character = value.charAt(index2);
      if (!isDecimal(character)) {
        break;
      }
      queue += character;
      index2++;
    }
    character = value.charAt(index2);
    if (!queue || !(character === dot$3 || commonmark2 && character === rightParenthesis$3)) {
      return;
    }
    if (silent && queue !== "1") {
      return;
    }
    start2 = parseInt(queue, 10);
    marker2 = character;
  }
  character = value.charAt(++index2);
  if (character !== space$b && character !== tab$7 && (pedantic || character !== lineFeed$b && character !== "")) {
    return;
  }
  if (silent) {
    return true;
  }
  index2 = 0;
  items = [];
  allLines = [];
  emptyLines = [];
  while (index2 < length) {
    nextIndex2 = value.indexOf(lineFeed$b, index2);
    startIndex = index2;
    prefixed = false;
    indented = false;
    if (nextIndex2 === -1) {
      nextIndex2 = length;
    }
    size = 0;
    while (index2 < length) {
      character = value.charAt(index2);
      if (character === tab$7) {
        size += tabSize$1 - size % tabSize$1;
      } else if (character === space$b) {
        size++;
      } else {
        break;
      }
      index2++;
    }
    if (item && size >= item.indent) {
      indented = true;
    }
    character = value.charAt(index2);
    currentMarker = null;
    if (!indented) {
      if (character === asterisk$3 || character === plusSign$2 || character === dash$6) {
        currentMarker = character;
        index2++;
        size++;
      } else {
        queue = "";
        while (index2 < length) {
          character = value.charAt(index2);
          if (!isDecimal(character)) {
            break;
          }
          queue += character;
          index2++;
        }
        character = value.charAt(index2);
        index2++;
        if (queue && (character === dot$3 || commonmark2 && character === rightParenthesis$3)) {
          currentMarker = character;
          size += queue.length + 1;
        }
      }
      if (currentMarker) {
        character = value.charAt(index2);
        if (character === tab$7) {
          size += tabSize$1 - size % tabSize$1;
          index2++;
        } else if (character === space$b) {
          end2 = index2 + tabSize$1;
          while (index2 < end2) {
            if (value.charAt(index2) !== space$b) {
              break;
            }
            index2++;
            size++;
          }
          if (index2 === end2 && value.charAt(index2) === space$b) {
            index2 -= tabSize$1 - 1;
            size -= tabSize$1 - 1;
          }
        } else if (character !== lineFeed$b && character !== "") {
          currentMarker = null;
        }
      }
    }
    if (currentMarker) {
      if (!pedantic && marker2 !== currentMarker) {
        break;
      }
      prefixed = true;
    } else {
      if (!commonmark2 && !indented && value.charAt(startIndex) === space$b) {
        indented = true;
      } else if (commonmark2 && item) {
        indented = size >= item.indent || size > tabSize$1;
      }
      prefixed = false;
      index2 = startIndex;
    }
    line2 = value.slice(startIndex, nextIndex2);
    content = startIndex === index2 ? line2 : value.slice(index2, nextIndex2);
    if (currentMarker === asterisk$3 || currentMarker === underscore$5 || currentMarker === dash$6) {
      if (tokenizers.thematicBreak.call(self2, eat2, line2, true)) {
        break;
      }
    }
    previousEmpty = empty3;
    empty3 = !prefixed && !trim_1(content).length;
    if (indented && item) {
      item.value = item.value.concat(emptyLines, line2);
      allLines = allLines.concat(emptyLines, line2);
      emptyLines = [];
    } else if (prefixed) {
      if (emptyLines.length !== 0) {
        spread = true;
        item.value.push("");
        item.trail = emptyLines.concat();
      }
      item = {
        value: [line2],
        indent: size,
        trail: []
      };
      items.push(item);
      allLines = allLines.concat(emptyLines, line2);
      emptyLines = [];
    } else if (empty3) {
      if (previousEmpty && !commonmark2) {
        break;
      }
      emptyLines.push(line2);
    } else {
      if (previousEmpty) {
        break;
      }
      if (interrupt_1(interuptors, tokenizers, self2, [eat2, line2, true])) {
        break;
      }
      item.value = item.value.concat(emptyLines, line2);
      allLines = allLines.concat(emptyLines, line2);
      emptyLines = [];
    }
    index2 = nextIndex2 + 1;
  }
  node2 = eat2(allLines.join(lineFeed$b)).reset({
    type: "list",
    ordered,
    start: start2,
    spread,
    children: []
  });
  enterTop = self2.enterList();
  exitBlockquote = self2.enterBlock();
  index2 = -1;
  length = items.length;
  while (++index2 < length) {
    item = items[index2].value.join(lineFeed$b);
    now2 = eat2.now();
    eat2(item)(listItem$2(self2, item, now2), node2);
    item = items[index2].trail.join(lineFeed$b);
    if (index2 !== length - 1) {
      item += lineFeed$b;
    }
    eat2(item);
  }
  enterTop();
  exitBlockquote();
  return node2;
}
function listItem$2(ctx, value, position2) {
  var offsets = ctx.offset;
  var fn2 = ctx.options.pedantic ? pedanticListItem : normalListItem;
  var checked = null;
  var task;
  var indent;
  value = fn2.apply(null, arguments);
  if (ctx.options.gfm) {
    task = value.match(taskItemExpression);
    if (task) {
      indent = task[0].length;
      checked = task[1].toLowerCase() === lowercaseX;
      offsets[position2.line] += indent;
      value = value.slice(indent);
    }
  }
  return {
    type: "listItem",
    spread: looseListItemExpression.test(value),
    checked,
    children: ctx.tokenizeBlock(value, position2)
  };
}
function pedanticListItem(ctx, value, position2) {
  var offsets = ctx.offset;
  var line2 = position2.line;
  value = value.replace(pedanticBulletExpression, replacer);
  line2 = position2.line;
  return value.replace(initialIndentExpression, replacer);
  function replacer($0) {
    offsets[line2] = (offsets[line2] || 0) + $0.length;
    line2++;
    return "";
  }
}
function normalListItem(ctx, value, position2) {
  var offsets = ctx.offset;
  var line2 = position2.line;
  var max;
  var bullet2;
  var rest;
  var lines;
  var trimmedLines;
  var index2;
  var length;
  value = value.replace(bulletExpression, replacer);
  lines = value.split(lineFeed$b);
  trimmedLines = removeIndentation(value, getIndentation(max).indent).split(lineFeed$b);
  trimmedLines[0] = rest;
  offsets[line2] = (offsets[line2] || 0) + bullet2.length;
  line2++;
  index2 = 0;
  length = lines.length;
  while (++index2 < length) {
    offsets[line2] = (offsets[line2] || 0) + lines[index2].length - trimmedLines[index2].length;
    line2++;
  }
  return trimmedLines.join(lineFeed$b);
  function replacer($0, $1, $2, $3, $4) {
    bullet2 = $1 + $2 + $3;
    rest = $4;
    if (Number($2) < 10 && bullet2.length % 2 === 1) {
      $2 = space$b + $2;
    }
    max = $1 + repeatString(space$b, $2.length) + $3;
    return max + rest;
  }
}
var headingSetext = setextHeading;
var lineFeed$a = "\n";
var tab$6 = "	";
var space$a = " ";
var equalsTo$1 = "=";
var dash$5 = "-";
var maxIndent = 3;
var equalsToDepth = 1;
var dashDepth = 2;
function setextHeading(eat2, value, silent) {
  var self2 = this;
  var now2 = eat2.now();
  var length = value.length;
  var index2 = -1;
  var subvalue = "";
  var content;
  var queue;
  var character;
  var marker2;
  var depth;
  while (++index2 < length) {
    character = value.charAt(index2);
    if (character !== space$a || index2 >= maxIndent) {
      index2--;
      break;
    }
    subvalue += character;
  }
  content = "";
  queue = "";
  while (++index2 < length) {
    character = value.charAt(index2);
    if (character === lineFeed$a) {
      index2--;
      break;
    }
    if (character === space$a || character === tab$6) {
      queue += character;
    } else {
      content += queue + character;
      queue = "";
    }
  }
  now2.column += subvalue.length;
  now2.offset += subvalue.length;
  subvalue += content + queue;
  character = value.charAt(++index2);
  marker2 = value.charAt(++index2);
  if (character !== lineFeed$a || marker2 !== equalsTo$1 && marker2 !== dash$5) {
    return;
  }
  subvalue += character;
  queue = marker2;
  depth = marker2 === equalsTo$1 ? equalsToDepth : dashDepth;
  while (++index2 < length) {
    character = value.charAt(index2);
    if (character !== marker2) {
      if (character !== lineFeed$a) {
        return;
      }
      index2--;
      break;
    }
    queue += character;
  }
  if (silent) {
    return true;
  }
  return eat2(subvalue + queue)({
    type: "heading",
    depth,
    children: self2.tokenizeInline(content, now2)
  });
}
var attributeName$2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted$2 = "[^\"'=<>`\\u0000-\\u0020]+";
var singleQuoted$2 = "'[^']*'";
var doubleQuoted$2 = '"[^"]*"';
var attributeValue$2 = "(?:" + unquoted$2 + "|" + singleQuoted$2 + "|" + doubleQuoted$2 + ")";
var attribute$2 = "(?:\\s+" + attributeName$2 + "(?:\\s*=\\s*" + attributeValue$2 + ")?)";
var openTag$1 = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute$2 + "*\\s*\\/?>";
var closeTag$1 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment$1 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var processing = "<[?].*?[?]>";
var declaration = "<![A-Za-z]+\\s+[^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var openCloseTag$2 = new RegExp("^(?:" + openTag$1 + "|" + closeTag$1 + ")");
var tag$2 = new RegExp(
  "^(?:" + openTag$1 + "|" + closeTag$1 + "|" + comment$1 + "|" + processing + "|" + declaration + "|" + cdata + ")"
);
var html$4 = {
  openCloseTag: openCloseTag$2,
  tag: tag$2
};
var openCloseTag$1 = html$4.openCloseTag;
var htmlBlock = blockHtml$1;
var tab$5 = "	";
var space$9 = " ";
var lineFeed$9 = "\n";
var lessThan$7 = "<";
var rawOpenExpression$1 = /^<(script|pre|style)(?=(\s|>|$))/i;
var rawCloseExpression$1 = /<\/(script|pre|style)>/i;
var commentOpenExpression$1 = /^<!--/;
var commentCloseExpression$1 = /-->/;
var instructionOpenExpression$1 = /^<\?/;
var instructionCloseExpression$1 = /\?>/;
var directiveOpenExpression$1 = /^<![A-Za-z]/;
var directiveCloseExpression$1 = />/;
var cdataOpenExpression$1 = /^<!\[CDATA\[/;
var cdataCloseExpression$1 = /]]>/;
var elementCloseExpression$1 = /^$/;
var otherElementOpenExpression$1 = new RegExp(openCloseTag$1.source + "\\s*$");
function blockHtml$1(eat2, value, silent) {
  var self2 = this;
  var blocks = self2.options.blocks.join("|");
  var elementOpenExpression = new RegExp(
    "^</?(" + blocks + ")(?=(\\s|/?>|$))",
    "i"
  );
  var length = value.length;
  var index2 = 0;
  var next;
  var line2;
  var offset2;
  var character;
  var count;
  var sequence;
  var subvalue;
  var sequences = [
    [rawOpenExpression$1, rawCloseExpression$1, true],
    [commentOpenExpression$1, commentCloseExpression$1, true],
    [instructionOpenExpression$1, instructionCloseExpression$1, true],
    [directiveOpenExpression$1, directiveCloseExpression$1, true],
    [cdataOpenExpression$1, cdataCloseExpression$1, true],
    [elementOpenExpression, elementCloseExpression$1, true],
    [otherElementOpenExpression$1, elementCloseExpression$1, false]
  ];
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== tab$5 && character !== space$9) {
      break;
    }
    index2++;
  }
  if (value.charAt(index2) !== lessThan$7) {
    return;
  }
  next = value.indexOf(lineFeed$9, index2 + 1);
  next = next === -1 ? length : next;
  line2 = value.slice(index2, next);
  offset2 = -1;
  count = sequences.length;
  while (++offset2 < count) {
    if (sequences[offset2][0].test(line2)) {
      sequence = sequences[offset2];
      break;
    }
  }
  if (!sequence) {
    return;
  }
  if (silent) {
    return sequence[2];
  }
  index2 = next;
  if (!sequence[1].test(line2)) {
    while (index2 < length) {
      next = value.indexOf(lineFeed$9, index2 + 1);
      next = next === -1 ? length : next;
      line2 = value.slice(index2 + 1, next);
      if (sequence[1].test(line2)) {
        if (line2) {
          index2 = next;
        }
        break;
      }
      index2 = next;
    }
  }
  subvalue = value.slice(0, index2);
  return eat2(subvalue)({ type: "html", value: subvalue });
}
var isWhitespaceCharacter = whitespace$1;
var fromCode$1 = String.fromCharCode;
var re$2 = /\s/;
function whitespace$1(character) {
  return re$2.test(
    typeof character === "number" ? fromCode$1(character) : character.charAt(0)
  );
}
var collapseWhiteSpace = collapse;
function collapse(value) {
  return String(value).replace(/\s+/g, " ");
}
var normalize_1$1 = normalize$1;
function normalize$1(value) {
  return collapseWhiteSpace(value).toLowerCase();
}
var definition_1 = definition;
var quotationMark$2 = '"';
var apostrophe$3 = "'";
var backslash$6 = "\\";
var lineFeed$8 = "\n";
var tab$4 = "	";
var space$8 = " ";
var leftSquareBracket$2 = "[";
var rightSquareBracket$2 = "]";
var leftParenthesis$1 = "(";
var rightParenthesis$2 = ")";
var colon$2 = ":";
var lessThan$6 = "<";
var greaterThan$3 = ">";
function definition(eat2, value, silent) {
  var self2 = this;
  var commonmark2 = self2.options.commonmark;
  var index2 = 0;
  var length = value.length;
  var subvalue = "";
  var beforeURL;
  var beforeTitle;
  var queue;
  var character;
  var test2;
  var identifier;
  var url2;
  var title;
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== space$8 && character !== tab$4) {
      break;
    }
    subvalue += character;
    index2++;
  }
  character = value.charAt(index2);
  if (character !== leftSquareBracket$2) {
    return;
  }
  index2++;
  subvalue += character;
  queue = "";
  while (index2 < length) {
    character = value.charAt(index2);
    if (character === rightSquareBracket$2) {
      break;
    } else if (character === backslash$6) {
      queue += character;
      index2++;
      character = value.charAt(index2);
    }
    queue += character;
    index2++;
  }
  if (!queue || value.charAt(index2) !== rightSquareBracket$2 || value.charAt(index2 + 1) !== colon$2) {
    return;
  }
  identifier = queue;
  subvalue += queue + rightSquareBracket$2 + colon$2;
  index2 = subvalue.length;
  queue = "";
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== tab$4 && character !== space$8 && character !== lineFeed$8) {
      break;
    }
    subvalue += character;
    index2++;
  }
  character = value.charAt(index2);
  queue = "";
  beforeURL = subvalue;
  if (character === lessThan$6) {
    index2++;
    while (index2 < length) {
      character = value.charAt(index2);
      if (!isEnclosedURLCharacter(character)) {
        break;
      }
      queue += character;
      index2++;
    }
    character = value.charAt(index2);
    if (character === isEnclosedURLCharacter.delimiter) {
      subvalue += lessThan$6 + queue + character;
      index2++;
    } else {
      if (commonmark2) {
        return;
      }
      index2 -= queue.length + 1;
      queue = "";
    }
  }
  if (!queue) {
    while (index2 < length) {
      character = value.charAt(index2);
      if (!isUnclosedURLCharacter(character)) {
        break;
      }
      queue += character;
      index2++;
    }
    subvalue += queue;
  }
  if (!queue) {
    return;
  }
  url2 = queue;
  queue = "";
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== tab$4 && character !== space$8 && character !== lineFeed$8) {
      break;
    }
    queue += character;
    index2++;
  }
  character = value.charAt(index2);
  test2 = null;
  if (character === quotationMark$2) {
    test2 = quotationMark$2;
  } else if (character === apostrophe$3) {
    test2 = apostrophe$3;
  } else if (character === leftParenthesis$1) {
    test2 = rightParenthesis$2;
  }
  if (!test2) {
    queue = "";
    index2 = subvalue.length;
  } else if (queue) {
    subvalue += queue + character;
    index2 = subvalue.length;
    queue = "";
    while (index2 < length) {
      character = value.charAt(index2);
      if (character === test2) {
        break;
      }
      if (character === lineFeed$8) {
        index2++;
        character = value.charAt(index2);
        if (character === lineFeed$8 || character === test2) {
          return;
        }
        queue += lineFeed$8;
      }
      queue += character;
      index2++;
    }
    character = value.charAt(index2);
    if (character !== test2) {
      return;
    }
    beforeTitle = subvalue;
    subvalue += queue + character;
    index2++;
    title = queue;
    queue = "";
  } else {
    return;
  }
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== tab$4 && character !== space$8) {
      break;
    }
    subvalue += character;
    index2++;
  }
  character = value.charAt(index2);
  if (!character || character === lineFeed$8) {
    if (silent) {
      return true;
    }
    beforeURL = eat2(beforeURL).test().end;
    url2 = self2.decode.raw(self2.unescape(url2), beforeURL, { nonTerminated: false });
    if (title) {
      beforeTitle = eat2(beforeTitle).test().end;
      title = self2.decode.raw(self2.unescape(title), beforeTitle);
    }
    return eat2(subvalue)({
      type: "definition",
      identifier: normalize_1$1(identifier),
      label: identifier,
      title: title || null,
      url: url2
    });
  }
}
function isEnclosedURLCharacter(character) {
  return character !== greaterThan$3 && character !== leftSquareBracket$2 && character !== rightSquareBracket$2;
}
isEnclosedURLCharacter.delimiter = greaterThan$3;
function isUnclosedURLCharacter(character) {
  return character !== leftSquareBracket$2 && character !== rightSquareBracket$2 && !isWhitespaceCharacter(character);
}
var table_1$1 = table$1;
var tab$3 = "	";
var lineFeed$7 = "\n";
var space$7 = " ";
var dash$4 = "-";
var colon$1 = ":";
var backslash$5 = "\\";
var verticalBar = "|";
var minColumns = 1;
var minRows = 2;
var left = "left";
var center = "center";
var right = "right";
function table$1(eat2, value, silent) {
  var self2 = this;
  var index2;
  var alignments;
  var alignment;
  var subvalue;
  var row;
  var length;
  var lines;
  var queue;
  var character;
  var hasDash;
  var align;
  var cell;
  var preamble;
  var now2;
  var position2;
  var lineCount;
  var line2;
  var rows;
  var table2;
  var lineIndex;
  var pipeIndex;
  var first2;
  if (!self2.options.gfm) {
    return;
  }
  index2 = 0;
  lineCount = 0;
  length = value.length + 1;
  lines = [];
  while (index2 < length) {
    lineIndex = value.indexOf(lineFeed$7, index2);
    pipeIndex = value.indexOf(verticalBar, index2 + 1);
    if (lineIndex === -1) {
      lineIndex = value.length;
    }
    if (pipeIndex === -1 || pipeIndex > lineIndex) {
      if (lineCount < minRows) {
        return;
      }
      break;
    }
    lines.push(value.slice(index2, lineIndex));
    lineCount++;
    index2 = lineIndex + 1;
  }
  subvalue = lines.join(lineFeed$7);
  alignments = lines.splice(1, 1)[0] || [];
  index2 = 0;
  length = alignments.length;
  lineCount--;
  alignment = false;
  align = [];
  while (index2 < length) {
    character = alignments.charAt(index2);
    if (character === verticalBar) {
      hasDash = null;
      if (alignment === false) {
        if (first2 === false) {
          return;
        }
      } else {
        align.push(alignment);
        alignment = false;
      }
      first2 = false;
    } else if (character === dash$4) {
      hasDash = true;
      alignment = alignment || null;
    } else if (character === colon$1) {
      if (alignment === left) {
        alignment = center;
      } else if (hasDash && alignment === null) {
        alignment = right;
      } else {
        alignment = left;
      }
    } else if (!isWhitespaceCharacter(character)) {
      return;
    }
    index2++;
  }
  if (alignment !== false) {
    align.push(alignment);
  }
  if (align.length < minColumns) {
    return;
  }
  if (silent) {
    return true;
  }
  position2 = -1;
  rows = [];
  table2 = eat2(subvalue).reset({ type: "table", align, children: rows });
  while (++position2 < lineCount) {
    line2 = lines[position2];
    row = { type: "tableRow", children: [] };
    if (position2) {
      eat2(lineFeed$7);
    }
    eat2(line2).reset(row, table2);
    length = line2.length + 1;
    index2 = 0;
    queue = "";
    cell = "";
    preamble = true;
    while (index2 < length) {
      character = line2.charAt(index2);
      if (character === tab$3 || character === space$7) {
        if (cell) {
          queue += character;
        } else {
          eat2(character);
        }
        index2++;
        continue;
      }
      if (character === "" || character === verticalBar) {
        if (preamble) {
          eat2(character);
        } else {
          if ((cell || character) && !preamble) {
            subvalue = cell;
            if (queue.length > 1) {
              if (character) {
                subvalue += queue.slice(0, -1);
                queue = queue.charAt(queue.length - 1);
              } else {
                subvalue += queue;
                queue = "";
              }
            }
            now2 = eat2.now();
            eat2(subvalue)(
              { type: "tableCell", children: self2.tokenizeInline(cell, now2) },
              row
            );
          }
          eat2(queue + character);
          queue = "";
          cell = "";
        }
      } else {
        if (queue) {
          cell += queue;
          queue = "";
        }
        cell += character;
        if (character === backslash$5 && index2 !== length - 2) {
          cell += line2.charAt(index2 + 1);
          index2++;
        }
      }
      preamble = false;
      index2++;
    }
    if (!position2) {
      eat2(lineFeed$7 + alignments);
    }
  }
  return table2;
}
var paragraph_1$1 = paragraph$1;
var tab$2 = "	";
var lineFeed$6 = "\n";
var space$6 = " ";
var tabSize = 4;
function paragraph$1(eat2, value, silent) {
  var self2 = this;
  var settings = self2.options;
  var commonmark2 = settings.commonmark;
  var tokenizers = self2.blockTokenizers;
  var interruptors = self2.interruptParagraph;
  var index2 = value.indexOf(lineFeed$6);
  var length = value.length;
  var position2;
  var subvalue;
  var character;
  var size;
  var now2;
  while (index2 < length) {
    if (index2 === -1) {
      index2 = length;
      break;
    }
    if (value.charAt(index2 + 1) === lineFeed$6) {
      break;
    }
    if (commonmark2) {
      size = 0;
      position2 = index2 + 1;
      while (position2 < length) {
        character = value.charAt(position2);
        if (character === tab$2) {
          size = tabSize;
          break;
        } else if (character === space$6) {
          size++;
        } else {
          break;
        }
        position2++;
      }
      if (size >= tabSize && character !== lineFeed$6) {
        index2 = value.indexOf(lineFeed$6, index2 + 1);
        continue;
      }
    }
    subvalue = value.slice(index2 + 1);
    if (interrupt_1(interruptors, tokenizers, self2, [eat2, subvalue, true])) {
      break;
    }
    position2 = index2;
    index2 = value.indexOf(lineFeed$6, index2 + 1);
    if (index2 !== -1 && trim_1(value.slice(position2, index2)) === "") {
      index2 = position2;
      break;
    }
  }
  subvalue = value.slice(0, index2);
  if (silent) {
    return true;
  }
  now2 = eat2.now();
  subvalue = trimTrailingLines_1(subvalue);
  return eat2(subvalue)({
    type: "paragraph",
    children: self2.tokenizeInline(subvalue, now2)
  });
}
var _escape$1 = locate$9;
function locate$9(value, fromIndex) {
  return value.indexOf("\\", fromIndex);
}
var _escape = escape$1;
escape$1.locator = _escape$1;
var lineFeed$5 = "\n";
var backslash$4 = "\\";
function escape$1(eat2, value, silent) {
  var self2 = this;
  var character;
  var node2;
  if (value.charAt(0) === backslash$4) {
    character = value.charAt(1);
    if (self2.escape.indexOf(character) !== -1) {
      if (silent) {
        return true;
      }
      if (character === lineFeed$5) {
        node2 = { type: "break" };
      } else {
        node2 = { type: "text", value: character };
      }
      return eat2(backslash$4 + character)(node2);
    }
  }
}
var tag$1 = locate$8;
function locate$8(value, fromIndex) {
  return value.indexOf("<", fromIndex);
}
var autoLink_1 = autoLink;
autoLink.locator = tag$1;
autoLink.notInLink = true;
var lessThan$5 = "<";
var greaterThan$2 = ">";
var atSign$1 = "@";
var slash$3 = "/";
var mailto = "mailto:";
var mailtoLength = mailto.length;
function autoLink(eat2, value, silent) {
  var self2 = this;
  var subvalue = "";
  var length = value.length;
  var index2 = 0;
  var queue = "";
  var hasAtCharacter = false;
  var link2 = "";
  var character;
  var now2;
  var content;
  var tokenizers;
  var exit;
  if (value.charAt(0) !== lessThan$5) {
    return;
  }
  index2++;
  subvalue = lessThan$5;
  while (index2 < length) {
    character = value.charAt(index2);
    if (isWhitespaceCharacter(character) || character === greaterThan$2 || character === atSign$1 || character === ":" && value.charAt(index2 + 1) === slash$3) {
      break;
    }
    queue += character;
    index2++;
  }
  if (!queue) {
    return;
  }
  link2 += queue;
  queue = "";
  character = value.charAt(index2);
  link2 += character;
  index2++;
  if (character === atSign$1) {
    hasAtCharacter = true;
  } else {
    if (character !== ":" || value.charAt(index2 + 1) !== slash$3) {
      return;
    }
    link2 += slash$3;
    index2++;
  }
  while (index2 < length) {
    character = value.charAt(index2);
    if (isWhitespaceCharacter(character) || character === greaterThan$2) {
      break;
    }
    queue += character;
    index2++;
  }
  character = value.charAt(index2);
  if (!queue || character !== greaterThan$2) {
    return;
  }
  if (silent) {
    return true;
  }
  link2 += queue;
  content = link2;
  subvalue += link2 + character;
  now2 = eat2.now();
  now2.column++;
  now2.offset++;
  if (hasAtCharacter) {
    if (link2.slice(0, mailtoLength).toLowerCase() === mailto) {
      content = content.slice(mailtoLength);
      now2.column += mailtoLength;
      now2.offset += mailtoLength;
    } else {
      link2 = mailto + link2;
    }
  }
  tokenizers = self2.inlineTokenizers;
  self2.inlineTokenizers = { text: tokenizers.text };
  exit = self2.enterLink();
  content = self2.tokenizeInline(content, now2);
  self2.inlineTokenizers = tokenizers;
  exit();
  return eat2(subvalue)({
    type: "link",
    title: null,
    url: parseEntities_1(link2, { nonTerminated: false }),
    children: content
  });
}
var ccount_1 = ccount;
function ccount(value, character) {
  var val = String(value);
  var count = 0;
  var index2;
  if (typeof character !== "string" || character.length !== 1) {
    throw new Error("Expected character");
  }
  index2 = val.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = val.indexOf(character, index2 + 1);
  }
  return count;
}
var url$1 = locate$7;
var values = ["www.", "http://", "https://"];
function locate$7(value, fromIndex) {
  var min = -1;
  var index2;
  var length;
  var position2;
  if (!this.options.gfm) {
    return min;
  }
  length = values.length;
  index2 = -1;
  while (++index2 < length) {
    position2 = value.indexOf(values[index2], fromIndex);
    if (position2 !== -1 && (min === -1 || position2 < min)) {
      min = position2;
    }
  }
  return min;
}
var url_1 = url;
url.locator = url$1;
url.notInLink = true;
var exclamationMark$3 = 33;
var ampersand = 38;
var rightParenthesis$1 = 41;
var asterisk$2 = 42;
var comma$1 = 44;
var dash$3 = 45;
var dot$2 = 46;
var colon = 58;
var semicolon2 = 59;
var questionMark$1 = 63;
var lessThan$4 = 60;
var underscore$4 = 95;
var tilde$2 = 126;
var leftParenthesisCharacter = "(";
var rightParenthesisCharacter = ")";
function url(eat2, value, silent) {
  var self2 = this;
  var gfm2 = self2.options.gfm;
  var tokenizers = self2.inlineTokenizers;
  var length = value.length;
  var previousDot = -1;
  var protocolless = false;
  var dots;
  var lastTwoPartsStart;
  var start2;
  var index2;
  var pathStart;
  var path2;
  var code2;
  var end2;
  var leftCount;
  var rightCount;
  var content;
  var children;
  var url2;
  var exit;
  if (!gfm2) {
    return;
  }
  if (value.slice(0, 4) === "www.") {
    protocolless = true;
    index2 = 4;
  } else if (value.slice(0, 7).toLowerCase() === "http://") {
    index2 = 7;
  } else if (value.slice(0, 8).toLowerCase() === "https://") {
    index2 = 8;
  } else {
    return;
  }
  previousDot = index2 - 1;
  start2 = index2;
  dots = [];
  while (index2 < length) {
    code2 = value.charCodeAt(index2);
    if (code2 === dot$2) {
      if (previousDot === index2 - 1) {
        break;
      }
      dots.push(index2);
      previousDot = index2;
      index2++;
      continue;
    }
    if (isDecimal(code2) || isAlphabetical(code2) || code2 === dash$3 || code2 === underscore$4) {
      index2++;
      continue;
    }
    break;
  }
  if (code2 === dot$2) {
    dots.pop();
    index2--;
  }
  if (dots[0] === void 0) {
    return;
  }
  lastTwoPartsStart = dots.length < 2 ? start2 : dots[dots.length - 2] + 1;
  if (value.slice(lastTwoPartsStart, index2).indexOf("_") !== -1) {
    return;
  }
  if (silent) {
    return true;
  }
  end2 = index2;
  pathStart = index2;
  while (index2 < length) {
    code2 = value.charCodeAt(index2);
    if (isWhitespaceCharacter(code2) || code2 === lessThan$4) {
      break;
    }
    index2++;
    if (code2 === exclamationMark$3 || code2 === asterisk$2 || code2 === comma$1 || code2 === dot$2 || code2 === colon || code2 === questionMark$1 || code2 === underscore$4 || code2 === tilde$2)
      ;
    else {
      end2 = index2;
    }
  }
  index2 = end2;
  if (value.charCodeAt(index2 - 1) === rightParenthesis$1) {
    path2 = value.slice(pathStart, index2);
    leftCount = ccount_1(path2, leftParenthesisCharacter);
    rightCount = ccount_1(path2, rightParenthesisCharacter);
    while (rightCount > leftCount) {
      index2 = pathStart + path2.lastIndexOf(rightParenthesisCharacter);
      path2 = value.slice(pathStart, index2);
      rightCount--;
    }
  }
  if (value.charCodeAt(index2 - 1) === semicolon2) {
    index2--;
    if (isAlphabetical(value.charCodeAt(index2 - 1))) {
      end2 = index2 - 2;
      while (isAlphabetical(value.charCodeAt(end2))) {
        end2--;
      }
      if (value.charCodeAt(end2) === ampersand) {
        index2 = end2;
      }
    }
  }
  content = value.slice(0, index2);
  url2 = parseEntities_1(content, { nonTerminated: false });
  if (protocolless) {
    url2 = "http://" + url2;
  }
  exit = self2.enterLink();
  self2.inlineTokenizers = { text: tokenizers.text };
  children = self2.tokenizeInline(content, eat2.now());
  self2.inlineTokenizers = tokenizers;
  exit();
  return eat2(content)({ type: "link", title: null, url: url2, children });
}
var plusSign$1 = 43;
var dash$2 = 45;
var dot$1 = 46;
var underscore$3 = 95;
var email$1 = locate$6;
function locate$6(value, fromIndex) {
  var self2 = this;
  var at3;
  var position2;
  if (!this.options.gfm) {
    return -1;
  }
  at3 = value.indexOf("@", fromIndex);
  if (at3 === -1) {
    return -1;
  }
  position2 = at3;
  if (position2 === fromIndex || !isGfmAtext(value.charCodeAt(position2 - 1))) {
    return locate$6.call(self2, value, at3 + 1);
  }
  while (position2 > fromIndex && isGfmAtext(value.charCodeAt(position2 - 1))) {
    position2--;
  }
  return position2;
}
function isGfmAtext(code2) {
  return isDecimal(code2) || isAlphabetical(code2) || code2 === plusSign$1 || code2 === dash$2 || code2 === dot$1 || code2 === underscore$3;
}
var email_1 = email;
email.locator = email$1;
email.notInLink = true;
var plusSign = 43;
var dash$1 = 45;
var dot = 46;
var atSign = 64;
var underscore$2 = 95;
function email(eat2, value, silent) {
  var self2 = this;
  var gfm2 = self2.options.gfm;
  var tokenizers = self2.inlineTokenizers;
  var index2 = 0;
  var length = value.length;
  var firstDot = -1;
  var code2;
  var content;
  var children;
  var exit;
  if (!gfm2) {
    return;
  }
  code2 = value.charCodeAt(index2);
  while (isDecimal(code2) || isAlphabetical(code2) || code2 === plusSign || code2 === dash$1 || code2 === dot || code2 === underscore$2) {
    code2 = value.charCodeAt(++index2);
  }
  if (index2 === 0) {
    return;
  }
  if (code2 !== atSign) {
    return;
  }
  index2++;
  while (index2 < length) {
    code2 = value.charCodeAt(index2);
    if (isDecimal(code2) || isAlphabetical(code2) || code2 === dash$1 || code2 === dot || code2 === underscore$2) {
      index2++;
      if (firstDot === -1 && code2 === dot) {
        firstDot = index2;
      }
      continue;
    }
    break;
  }
  if (firstDot === -1 || firstDot === index2 || code2 === dash$1 || code2 === underscore$2) {
    return;
  }
  if (code2 === dot) {
    index2--;
  }
  content = value.slice(0, index2);
  if (silent) {
    return true;
  }
  exit = self2.enterLink();
  self2.inlineTokenizers = { text: tokenizers.text };
  children = self2.tokenizeInline(content, eat2.now());
  self2.inlineTokenizers = tokenizers;
  exit();
  return eat2(content)({
    type: "link",
    title: null,
    url: "mailto:" + parseEntities_1(content, { nonTerminated: false }),
    children
  });
}
var tag2 = html$4.tag;
var htmlInline = inlineHTML;
inlineHTML.locator = tag$1;
var lessThan$3 = "<";
var questionMark = "?";
var exclamationMark$2 = "!";
var slash$2 = "/";
var htmlLinkOpenExpression = /^<a /i;
var htmlLinkCloseExpression = /^<\/a>/i;
function inlineHTML(eat2, value, silent) {
  var self2 = this;
  var length = value.length;
  var character;
  var subvalue;
  if (value.charAt(0) !== lessThan$3 || length < 3) {
    return;
  }
  character = value.charAt(1);
  if (!isAlphabetical(character) && character !== questionMark && character !== exclamationMark$2 && character !== slash$2) {
    return;
  }
  subvalue = value.match(tag2);
  if (!subvalue) {
    return;
  }
  if (silent) {
    return true;
  }
  subvalue = subvalue[0];
  if (!self2.inLink && htmlLinkOpenExpression.test(subvalue)) {
    self2.inLink = true;
  } else if (self2.inLink && htmlLinkCloseExpression.test(subvalue)) {
    self2.inLink = false;
  }
  return eat2(subvalue)({ type: "html", value: subvalue });
}
var link$3 = locate$5;
function locate$5(value, fromIndex) {
  var link2 = value.indexOf("[", fromIndex);
  var image2 = value.indexOf("![", fromIndex);
  if (image2 === -1) {
    return link2;
  }
  return link2 < image2 ? link2 : image2;
}
var link_1$1 = link$2;
link$2.locator = link$3;
var lineFeed$4 = "\n";
var exclamationMark$1 = "!";
var quotationMark$1 = '"';
var apostrophe$2 = "'";
var leftParenthesis = "(";
var rightParenthesis = ")";
var lessThan$2 = "<";
var greaterThan$1 = ">";
var leftSquareBracket$1 = "[";
var backslash$3 = "\\";
var rightSquareBracket$1 = "]";
var graveAccent$1 = "`";
function link$2(eat2, value, silent) {
  var self2 = this;
  var subvalue = "";
  var index2 = 0;
  var character = value.charAt(0);
  var pedantic = self2.options.pedantic;
  var commonmark2 = self2.options.commonmark;
  var gfm2 = self2.options.gfm;
  var closed;
  var count;
  var opening2;
  var beforeURL;
  var beforeTitle;
  var subqueue;
  var hasMarker;
  var isImage;
  var content;
  var marker2;
  var length;
  var title;
  var depth;
  var queue;
  var url2;
  var now2;
  var exit;
  var node2;
  if (character === exclamationMark$1) {
    isImage = true;
    subvalue = character;
    character = value.charAt(++index2);
  }
  if (character !== leftSquareBracket$1) {
    return;
  }
  if (!isImage && self2.inLink) {
    return;
  }
  subvalue += character;
  queue = "";
  index2++;
  length = value.length;
  now2 = eat2.now();
  depth = 0;
  now2.column += index2;
  now2.offset += index2;
  while (index2 < length) {
    character = value.charAt(index2);
    subqueue = character;
    if (character === graveAccent$1) {
      count = 1;
      while (value.charAt(index2 + 1) === graveAccent$1) {
        subqueue += character;
        index2++;
        count++;
      }
      if (!opening2) {
        opening2 = count;
      } else if (count >= opening2) {
        opening2 = 0;
      }
    } else if (character === backslash$3) {
      index2++;
      subqueue += value.charAt(index2);
    } else if ((!opening2 || gfm2) && character === leftSquareBracket$1) {
      depth++;
    } else if ((!opening2 || gfm2) && character === rightSquareBracket$1) {
      if (depth) {
        depth--;
      } else {
        if (value.charAt(index2 + 1) !== leftParenthesis) {
          return;
        }
        subqueue += leftParenthesis;
        closed = true;
        index2++;
        break;
      }
    }
    queue += subqueue;
    subqueue = "";
    index2++;
  }
  if (!closed) {
    return;
  }
  content = queue;
  subvalue += queue + subqueue;
  index2++;
  while (index2 < length) {
    character = value.charAt(index2);
    if (!isWhitespaceCharacter(character)) {
      break;
    }
    subvalue += character;
    index2++;
  }
  character = value.charAt(index2);
  queue = "";
  beforeURL = subvalue;
  if (character === lessThan$2) {
    index2++;
    beforeURL += lessThan$2;
    while (index2 < length) {
      character = value.charAt(index2);
      if (character === greaterThan$1) {
        break;
      }
      if (commonmark2 && character === lineFeed$4) {
        return;
      }
      queue += character;
      index2++;
    }
    if (value.charAt(index2) !== greaterThan$1) {
      return;
    }
    subvalue += lessThan$2 + queue + greaterThan$1;
    url2 = queue;
    index2++;
  } else {
    character = null;
    subqueue = "";
    while (index2 < length) {
      character = value.charAt(index2);
      if (subqueue && (character === quotationMark$1 || character === apostrophe$2 || commonmark2 && character === leftParenthesis)) {
        break;
      }
      if (isWhitespaceCharacter(character)) {
        if (!pedantic) {
          break;
        }
        subqueue += character;
      } else {
        if (character === leftParenthesis) {
          depth++;
        } else if (character === rightParenthesis) {
          if (depth === 0) {
            break;
          }
          depth--;
        }
        queue += subqueue;
        subqueue = "";
        if (character === backslash$3) {
          queue += backslash$3;
          character = value.charAt(++index2);
        }
        queue += character;
      }
      index2++;
    }
    subvalue += queue;
    url2 = queue;
    index2 = subvalue.length;
  }
  queue = "";
  while (index2 < length) {
    character = value.charAt(index2);
    if (!isWhitespaceCharacter(character)) {
      break;
    }
    queue += character;
    index2++;
  }
  character = value.charAt(index2);
  subvalue += queue;
  if (queue && (character === quotationMark$1 || character === apostrophe$2 || commonmark2 && character === leftParenthesis)) {
    index2++;
    subvalue += character;
    queue = "";
    marker2 = character === leftParenthesis ? rightParenthesis : character;
    beforeTitle = subvalue;
    if (commonmark2) {
      while (index2 < length) {
        character = value.charAt(index2);
        if (character === marker2) {
          break;
        }
        if (character === backslash$3) {
          queue += backslash$3;
          character = value.charAt(++index2);
        }
        index2++;
        queue += character;
      }
      character = value.charAt(index2);
      if (character !== marker2) {
        return;
      }
      title = queue;
      subvalue += queue + character;
      index2++;
      while (index2 < length) {
        character = value.charAt(index2);
        if (!isWhitespaceCharacter(character)) {
          break;
        }
        subvalue += character;
        index2++;
      }
    } else {
      subqueue = "";
      while (index2 < length) {
        character = value.charAt(index2);
        if (character === marker2) {
          if (hasMarker) {
            queue += marker2 + subqueue;
            subqueue = "";
          }
          hasMarker = true;
        } else if (!hasMarker) {
          queue += character;
        } else if (character === rightParenthesis) {
          subvalue += queue + marker2 + subqueue;
          title = queue;
          break;
        } else if (isWhitespaceCharacter(character)) {
          subqueue += character;
        } else {
          queue += marker2 + subqueue + character;
          subqueue = "";
          hasMarker = false;
        }
        index2++;
      }
    }
  }
  if (value.charAt(index2) !== rightParenthesis) {
    return;
  }
  if (silent) {
    return true;
  }
  subvalue += rightParenthesis;
  url2 = self2.decode.raw(self2.unescape(url2), eat2(beforeURL).test().end, {
    nonTerminated: false
  });
  if (title) {
    beforeTitle = eat2(beforeTitle).test().end;
    title = self2.decode.raw(self2.unescape(title), beforeTitle);
  }
  node2 = {
    type: isImage ? "image" : "link",
    title: title || null,
    url: url2
  };
  if (isImage) {
    node2.alt = self2.decode.raw(self2.unescape(content), now2) || null;
  } else {
    exit = self2.enterLink();
    node2.children = self2.tokenizeInline(content, now2);
    exit();
  }
  return eat2(subvalue)(node2);
}
var reference_1 = reference;
reference.locator = link$3;
var link$1 = "link";
var image$2 = "image";
var shortcut = "shortcut";
var collapsed = "collapsed";
var full = "full";
var exclamationMark = "!";
var leftSquareBracket = "[";
var backslash$2 = "\\";
var rightSquareBracket = "]";
function reference(eat2, value, silent) {
  var self2 = this;
  var commonmark2 = self2.options.commonmark;
  var character = value.charAt(0);
  var index2 = 0;
  var length = value.length;
  var subvalue = "";
  var intro = "";
  var type2 = link$1;
  var referenceType = shortcut;
  var content;
  var identifier;
  var now2;
  var node2;
  var exit;
  var queue;
  var bracketed;
  var depth;
  if (character === exclamationMark) {
    type2 = image$2;
    intro = character;
    character = value.charAt(++index2);
  }
  if (character !== leftSquareBracket) {
    return;
  }
  index2++;
  intro += character;
  queue = "";
  depth = 0;
  while (index2 < length) {
    character = value.charAt(index2);
    if (character === leftSquareBracket) {
      bracketed = true;
      depth++;
    } else if (character === rightSquareBracket) {
      if (!depth) {
        break;
      }
      depth--;
    }
    if (character === backslash$2) {
      queue += backslash$2;
      character = value.charAt(++index2);
    }
    queue += character;
    index2++;
  }
  subvalue = queue;
  content = queue;
  character = value.charAt(index2);
  if (character !== rightSquareBracket) {
    return;
  }
  index2++;
  subvalue += character;
  queue = "";
  if (!commonmark2) {
    while (index2 < length) {
      character = value.charAt(index2);
      if (!isWhitespaceCharacter(character)) {
        break;
      }
      queue += character;
      index2++;
    }
  }
  character = value.charAt(index2);
  if (character === leftSquareBracket) {
    identifier = "";
    queue += character;
    index2++;
    while (index2 < length) {
      character = value.charAt(index2);
      if (character === leftSquareBracket || character === rightSquareBracket) {
        break;
      }
      if (character === backslash$2) {
        identifier += backslash$2;
        character = value.charAt(++index2);
      }
      identifier += character;
      index2++;
    }
    character = value.charAt(index2);
    if (character === rightSquareBracket) {
      referenceType = identifier ? full : collapsed;
      queue += identifier + character;
      index2++;
    } else {
      identifier = "";
    }
    subvalue += queue;
    queue = "";
  } else {
    if (!content) {
      return;
    }
    identifier = content;
  }
  if (referenceType !== full && bracketed) {
    return;
  }
  subvalue = intro + subvalue;
  if (type2 === link$1 && self2.inLink) {
    return null;
  }
  if (silent) {
    return true;
  }
  now2 = eat2.now();
  now2.column += intro.length;
  now2.offset += intro.length;
  identifier = referenceType === full ? identifier : content;
  node2 = {
    type: type2 + "Reference",
    identifier: normalize_1$1(identifier),
    label: identifier,
    referenceType
  };
  if (type2 === link$1) {
    exit = self2.enterLink();
    node2.children = self2.tokenizeInline(content, now2);
    exit();
  } else {
    node2.alt = self2.decode.raw(self2.unescape(content), now2) || null;
  }
  return eat2(subvalue)(node2);
}
var strong$2 = locate$4;
function locate$4(value, fromIndex) {
  var asterisk2 = value.indexOf("**", fromIndex);
  var underscore2 = value.indexOf("__", fromIndex);
  if (underscore2 === -1) {
    return asterisk2;
  }
  if (asterisk2 === -1) {
    return underscore2;
  }
  return underscore2 < asterisk2 ? underscore2 : asterisk2;
}
var strong_1$1 = strong$1;
strong$1.locator = strong$2;
var backslash$1 = "\\";
var asterisk$1 = "*";
var underscore$1 = "_";
function strong$1(eat2, value, silent) {
  var self2 = this;
  var index2 = 0;
  var character = value.charAt(index2);
  var now2;
  var pedantic;
  var marker2;
  var queue;
  var subvalue;
  var length;
  var previous;
  if (character !== asterisk$1 && character !== underscore$1 || value.charAt(++index2) !== character) {
    return;
  }
  pedantic = self2.options.pedantic;
  marker2 = character;
  subvalue = marker2 + marker2;
  length = value.length;
  index2++;
  queue = "";
  character = "";
  if (pedantic && isWhitespaceCharacter(value.charAt(index2))) {
    return;
  }
  while (index2 < length) {
    previous = character;
    character = value.charAt(index2);
    if (character === marker2 && value.charAt(index2 + 1) === marker2 && (!pedantic || !isWhitespaceCharacter(previous))) {
      character = value.charAt(index2 + 2);
      if (character !== marker2) {
        if (!trim_1(queue)) {
          return;
        }
        if (silent) {
          return true;
        }
        now2 = eat2.now();
        now2.column += 2;
        now2.offset += 2;
        return eat2(subvalue + queue + subvalue)({
          type: "strong",
          children: self2.tokenizeInline(queue, now2)
        });
      }
    }
    if (!pedantic && character === backslash$1) {
      queue += character;
      character = value.charAt(++index2);
    }
    queue += character;
    index2++;
  }
}
var isWordCharacter = wordCharacter;
var fromCode = String.fromCharCode;
var re$12 = /\w/;
function wordCharacter(character) {
  return re$12.test(
    typeof character === "number" ? fromCode(character) : character.charAt(0)
  );
}
var emphasis$2 = locate$3;
function locate$3(value, fromIndex) {
  var asterisk2 = value.indexOf("*", fromIndex);
  var underscore2 = value.indexOf("_", fromIndex);
  if (underscore2 === -1) {
    return asterisk2;
  }
  if (asterisk2 === -1) {
    return underscore2;
  }
  return underscore2 < asterisk2 ? underscore2 : asterisk2;
}
var emphasis_1$1 = emphasis$1;
emphasis$1.locator = emphasis$2;
var asterisk = "*";
var underscore = "_";
var backslash = "\\";
function emphasis$1(eat2, value, silent) {
  var self2 = this;
  var index2 = 0;
  var character = value.charAt(index2);
  var now2;
  var pedantic;
  var marker2;
  var queue;
  var subvalue;
  var length;
  var previous;
  if (character !== asterisk && character !== underscore) {
    return;
  }
  pedantic = self2.options.pedantic;
  subvalue = character;
  marker2 = character;
  length = value.length;
  index2++;
  queue = "";
  character = "";
  if (pedantic && isWhitespaceCharacter(value.charAt(index2))) {
    return;
  }
  while (index2 < length) {
    previous = character;
    character = value.charAt(index2);
    if (character === marker2 && (!pedantic || !isWhitespaceCharacter(previous))) {
      character = value.charAt(++index2);
      if (character !== marker2) {
        if (!trim_1(queue) || previous === marker2) {
          return;
        }
        if (!pedantic && marker2 === underscore && isWordCharacter(character)) {
          queue += marker2;
          continue;
        }
        if (silent) {
          return true;
        }
        now2 = eat2.now();
        now2.column++;
        now2.offset++;
        return eat2(subvalue + queue + marker2)({
          type: "emphasis",
          children: self2.tokenizeInline(queue, now2)
        });
      }
      queue += marker2;
    }
    if (!pedantic && character === backslash) {
      queue += character;
      character = value.charAt(++index2);
    }
    queue += character;
    index2++;
  }
}
var _delete$2 = locate$2;
function locate$2(value, fromIndex) {
  return value.indexOf("~~", fromIndex);
}
var _delete$1 = strikethrough$1;
strikethrough$1.locator = _delete$2;
var tilde$1 = "~";
var fence$1 = "~~";
function strikethrough$1(eat2, value, silent) {
  var self2 = this;
  var character = "";
  var previous = "";
  var preceding = "";
  var subvalue = "";
  var index2;
  var length;
  var now2;
  if (!self2.options.gfm || value.charAt(0) !== tilde$1 || value.charAt(1) !== tilde$1 || isWhitespaceCharacter(value.charAt(2))) {
    return;
  }
  index2 = 1;
  length = value.length;
  now2 = eat2.now();
  now2.column += 2;
  now2.offset += 2;
  while (++index2 < length) {
    character = value.charAt(index2);
    if (character === tilde$1 && previous === tilde$1 && (!preceding || !isWhitespaceCharacter(preceding))) {
      if (silent) {
        return true;
      }
      return eat2(fence$1 + subvalue + fence$1)({
        type: "delete",
        children: self2.tokenizeInline(subvalue, now2)
      });
    }
    subvalue += previous;
    preceding = previous;
    previous = character;
  }
}
var codeInline$1 = locate$1;
function locate$1(value, fromIndex) {
  return value.indexOf("`", fromIndex);
}
var codeInline = inlineCode$1;
inlineCode$1.locator = codeInline$1;
var lineFeed$3 = 10;
var space$5 = 32;
var graveAccent = 96;
function inlineCode$1(eat2, value, silent) {
  var length = value.length;
  var index2 = 0;
  var openingFenceEnd;
  var closingFenceStart;
  var closingFenceEnd;
  var code2;
  var next;
  var found;
  while (index2 < length) {
    if (value.charCodeAt(index2) !== graveAccent) {
      break;
    }
    index2++;
  }
  if (index2 === 0 || index2 === length) {
    return;
  }
  openingFenceEnd = index2;
  next = value.charCodeAt(index2);
  while (index2 < length) {
    code2 = next;
    next = value.charCodeAt(index2 + 1);
    if (code2 === graveAccent) {
      if (closingFenceStart === void 0) {
        closingFenceStart = index2;
      }
      closingFenceEnd = index2 + 1;
      if (next !== graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
        found = true;
        break;
      }
    } else if (closingFenceStart !== void 0) {
      closingFenceStart = void 0;
      closingFenceEnd = void 0;
    }
    index2++;
  }
  if (!found) {
    return;
  }
  if (silent) {
    return true;
  }
  index2 = openingFenceEnd;
  length = closingFenceStart;
  code2 = value.charCodeAt(index2);
  next = value.charCodeAt(length - 1);
  found = false;
  if (length - index2 > 2 && (code2 === space$5 || code2 === lineFeed$3) && (next === space$5 || next === lineFeed$3)) {
    index2++;
    length--;
    while (index2 < length) {
      code2 = value.charCodeAt(index2);
      if (code2 !== space$5 && code2 !== lineFeed$3) {
        found = true;
        break;
      }
      index2++;
    }
    if (found === true) {
      openingFenceEnd++;
      closingFenceStart--;
    }
  }
  return eat2(value.slice(0, closingFenceEnd))({
    type: "inlineCode",
    value: value.slice(openingFenceEnd, closingFenceStart)
  });
}
var _break$2 = locate2;
function locate2(value, fromIndex) {
  var index2 = value.indexOf("\n", fromIndex);
  while (index2 > fromIndex) {
    if (value.charAt(index2 - 1) !== " ") {
      break;
    }
    index2--;
  }
  return index2;
}
var _break$1 = hardBreak$1;
hardBreak$1.locator = _break$2;
var space$4 = " ";
var lineFeed$2 = "\n";
var minBreakLength = 2;
function hardBreak$1(eat2, value, silent) {
  var length = value.length;
  var index2 = -1;
  var queue = "";
  var character;
  while (++index2 < length) {
    character = value.charAt(index2);
    if (character === lineFeed$2) {
      if (index2 < minBreakLength) {
        return;
      }
      if (silent) {
        return true;
      }
      queue += character;
      return eat2(queue)({ type: "break" });
    }
    if (character !== space$4) {
      return;
    }
    queue += character;
  }
}
var text_1$2 = text$3;
function text$3(eat2, value, silent) {
  var self2 = this;
  var methods;
  var tokenizers;
  var index2;
  var length;
  var subvalue;
  var position2;
  var tokenizer3;
  var name3;
  var min;
  var now2;
  if (silent) {
    return true;
  }
  methods = self2.inlineMethods;
  length = methods.length;
  tokenizers = self2.inlineTokenizers;
  index2 = -1;
  min = value.length;
  while (++index2 < length) {
    name3 = methods[index2];
    if (name3 === "text" || !tokenizers[name3]) {
      continue;
    }
    tokenizer3 = tokenizers[name3].locator;
    if (!tokenizer3) {
      eat2.file.fail("Missing locator: `" + name3 + "`");
    }
    position2 = tokenizer3.call(self2, value, 1);
    if (position2 !== -1 && position2 < min) {
      min = position2;
    }
  }
  subvalue = value.slice(0, min);
  now2 = eat2.now();
  self2.decode(subvalue, now2, handler);
  function handler(content, position3, source) {
    eat2(source || content)({ type: "text", value: content });
  }
}
var parser$1 = Parser3;
function Parser3(doc, file) {
  this.file = file;
  this.offset = {};
  this.options = immutable(this.options);
  this.setOptions({});
  this.inList = false;
  this.inBlock = false;
  this.inLink = false;
  this.atStart = true;
  this.toOffset = vfileLocation(file).toOffset;
  this.unescape = _unescape(this, "escape");
  this.decode = decode(this);
}
var proto$3 = Parser3.prototype;
proto$3.setOptions = setOptions_1;
proto$3.parse = parse_1$2;
proto$3.options = defaults$1;
proto$3.exitStart = stateToggle("atStart", true);
proto$3.enterList = stateToggle("inList", false);
proto$3.enterLink = stateToggle("inLink", false);
proto$3.enterBlock = stateToggle("inBlock", false);
proto$3.interruptParagraph = [
  ["thematicBreak"],
  ["list"],
  ["atxHeading"],
  ["fencedCode"],
  ["blockquote"],
  ["html"],
  ["setextHeading", { commonmark: false }],
  ["definition", { commonmark: false }]
];
proto$3.interruptList = [
  ["atxHeading", { pedantic: false }],
  ["fencedCode", { pedantic: false }],
  ["thematicBreak", { pedantic: false }],
  ["definition", { commonmark: false }]
];
proto$3.interruptBlockquote = [
  ["indentedCode", { commonmark: true }],
  ["fencedCode", { commonmark: true }],
  ["atxHeading", { commonmark: true }],
  ["setextHeading", { commonmark: true }],
  ["thematicBreak", { commonmark: true }],
  ["html", { commonmark: true }],
  ["list", { commonmark: true }],
  ["definition", { commonmark: false }]
];
proto$3.blockTokenizers = {
  blankLine: blankLine_1,
  indentedCode: codeIndented,
  fencedCode: codeFenced,
  blockquote: blockquote_1$1,
  atxHeading: headingAtx,
  thematicBreak: thematicBreak_1$1,
  list: list_1$1,
  setextHeading: headingSetext,
  html: htmlBlock,
  definition: definition_1,
  table: table_1$1,
  paragraph: paragraph_1$1
};
proto$3.inlineTokenizers = {
  escape: _escape,
  autoLink: autoLink_1,
  url: url_1,
  email: email_1,
  html: htmlInline,
  link: link_1$1,
  reference: reference_1,
  strong: strong_1$1,
  emphasis: emphasis_1$1,
  deletion: _delete$1,
  code: codeInline,
  break: _break$1,
  text: text_1$2
};
proto$3.blockMethods = keys$1(proto$3.blockTokenizers);
proto$3.inlineMethods = keys$1(proto$3.inlineTokenizers);
proto$3.tokenizeBlock = tokenizer$1("block");
proto$3.tokenizeInline = tokenizer$1("inline");
proto$3.tokenizeFactory = tokenizer$1;
function keys$1(value) {
  var result = [];
  var key;
  for (key in value) {
    result.push(key);
  }
  return result;
}
var remarkParse = parse$52;
parse$52.Parser = parser$1;
function parse$52(options2) {
  var settings = this.data("settings");
  var Local = unherit_1(parser$1);
  Local.prototype.options = immutable(Local.prototype.options, settings, options2);
  this.Parser = Local;
}
var mdastUtilDefinitions$1 = getDefinitionFactory$1;
var own$a = {}.hasOwnProperty;
function getDefinitionFactory$1(node2, options2) {
  return getterFactory$1(gather$1(node2, options2));
}
function gather$1(node2, options2) {
  var cache2 = {};
  if (!node2 || !node2.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  unistUtilVisit(node2, "definition", options2 && options2.commonmark ? commonmark2 : normal);
  return cache2;
  function commonmark2(definition2) {
    var id2 = normalise$1(definition2.identifier);
    if (!own$a.call(cache2, id2)) {
      cache2[id2] = definition2;
    }
  }
  function normal(definition2) {
    cache2[normalise$1(definition2.identifier)] = definition2;
  }
}
function getterFactory$1(cache2) {
  return getter;
  function getter(identifier) {
    var id2 = identifier && normalise$1(identifier);
    return id2 && own$a.call(cache2, id2) ? cache2[id2] : null;
  }
}
function normalise$1(identifier) {
  return identifier.toUpperCase();
}
var parse_1$1 = parse$42;
var stringify_1$1 = stringify$3;
var empty$2 = "";
var space$3 = " ";
var whiteSpace$1 = /[ \t\n\r\f]+/g;
function parse$42(value) {
  var input = String(value || empty$2).trim();
  return input === empty$2 ? [] : input.split(whiteSpace$1);
}
function stringify$3(values2) {
  return values2.join(space$3).trim();
}
var spaceSeparatedTokens = {
  parse: parse_1$1,
  stringify: stringify_1$1
};
var isAbsoluteUrl = (url2) => {
  if (typeof url2 !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof url2}\``);
  }
  if (/^[a-zA-Z]:\\/.test(url2)) {
    return false;
  }
  return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url2);
};
var spaceSeparated$4 = spaceSeparatedTokens.parse;
var remarkExternalLinks = externalLinks;
var defaultTarget = "_blank";
var defaultRel = ["nofollow", "noopener", "noreferrer"];
var defaultProtocols = ["http", "https"];
function externalLinks(options2) {
  var settings = options2 || {};
  var target2 = settings.target;
  var rel = settings.rel;
  var protocols = settings.protocols || defaultProtocols;
  var content = settings.content;
  var contentProperties = settings.contentProperties || {};
  if (typeof rel === "string") {
    rel = spaceSeparated$4(rel);
  }
  if (content && typeof content === "object" && !("length" in content)) {
    content = [content];
  }
  return transform2;
  function transform2(tree) {
    var definition2 = mdastUtilDefinitions$1(tree);
    unistUtilVisit(tree, ["link", "linkReference"], visitor);
    function visitor(node2) {
      var ctx = node2.type === "link" ? node2 : definition2(node2.identifier);
      var protocol;
      var data3;
      var props;
      if (!ctx)
        return;
      protocol = ctx.url.slice(0, ctx.url.indexOf(":"));
      if (isAbsoluteUrl(ctx.url) && protocols.indexOf(protocol) !== -1) {
        data3 = node2.data || (node2.data = {});
        props = data3.hProperties || (data3.hProperties = {});
        if (target2 !== false) {
          props.target = target2 || defaultTarget;
        }
        if (rel !== false) {
          props.rel = (rel || defaultRel).concat();
        }
        if (content) {
          node2.children.push({
            type: "fragment",
            children: [],
            data: {
              hName: "span",
              hProperties: extend$2(true, contentProperties),
              hChildren: extend$2(true, content)
            }
          });
        }
      }
    }
  }
}
var format = createCommonjsModule2(function(module) {
  (function() {
    var namespace;
    {
      namespace = module.exports = format2;
    }
    namespace.format = format2;
    namespace.vsprintf = vsprintf;
    if (typeof console !== "undefined" && typeof console.log === "function") {
      namespace.printf = printf;
    }
    function printf() {
      console.log(format2.apply(null, arguments));
    }
    function vsprintf(fmt, replacements) {
      return format2.apply(null, [fmt].concat(replacements));
    }
    function format2(fmt) {
      var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c2, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
        return args[argIndex++];
      }, slurpNumber = function() {
        var digits = "";
        while (/\d/.test(fmt[i])) {
          digits += fmt[i++];
          c2 = fmt[i];
        }
        return digits.length > 0 ? parseInt(digits) : null;
      };
      for (; i < n; ++i) {
        c2 = fmt[i];
        if (escaped) {
          escaped = false;
          if (c2 == ".") {
            leadingZero = false;
            c2 = fmt[++i];
          } else if (c2 == "0" && fmt[i + 1] == ".") {
            leadingZero = true;
            i += 2;
            c2 = fmt[i];
          } else {
            leadingZero = true;
          }
          precision = slurpNumber();
          switch (c2) {
            case "b":
              result += parseInt(nextArg(), 10).toString(2);
              break;
            case "c":
              arg = nextArg();
              if (typeof arg === "string" || arg instanceof String)
                result += arg;
              else
                result += String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
              result += parseInt(nextArg(), 10);
              break;
            case "f":
              tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
              result += leadingZero ? tmp : tmp.replace(/^0/, "");
              break;
            case "j":
              result += JSON.stringify(nextArg());
              break;
            case "o":
              result += "0" + parseInt(nextArg(), 10).toString(8);
              break;
            case "s":
              result += nextArg();
              break;
            case "x":
              result += "0x" + parseInt(nextArg(), 10).toString(16);
              break;
            case "X":
              result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
              break;
            default:
              result += c2;
              break;
          }
        } else if (c2 === "%") {
          escaped = true;
        } else {
          result += c2;
        }
      }
      return result;
    }
  })();
});
var fault = create$3(Error);
var fault_1 = fault;
fault.eval = create$3(EvalError);
fault.range = create$3(RangeError);
fault.reference = create$3(ReferenceError);
fault.syntax = create$3(SyntaxError);
fault.type = create$3(TypeError);
fault.uri = create$3(URIError);
fault.create = create$3;
function create$3(EConstructor) {
  FormattedError.displayName = EConstructor.displayName || EConstructor.name;
  return FormattedError;
  function FormattedError(format$1) {
    if (format$1) {
      format$1 = format.apply(null, arguments);
    }
    return new EConstructor(format$1);
  }
}
var matters_1 = matters;
var own$9 = {}.hasOwnProperty;
var markers = {
  yaml: "-",
  toml: "+"
};
function matters(options2) {
  var results = [];
  var index2 = -1;
  var length;
  if (typeof options2 === "string" || !("length" in options2)) {
    options2 = [options2];
  }
  length = options2.length;
  while (++index2 < length) {
    results[index2] = matter(options2[index2]);
  }
  return results;
}
function matter(option2) {
  var result = option2;
  if (typeof result === "string") {
    if (!own$9.call(markers, result)) {
      throw fault_1("Missing matter definition for `%s`", result);
    }
    result = { type: result, marker: markers[result] };
  } else if (typeof result !== "object") {
    throw fault_1("Expected matter to be an object, not `%j`", result);
  }
  if (!own$9.call(result, "type")) {
    throw fault_1("Missing `type` in matter `%j`", result);
  }
  if (!own$9.call(result, "fence") && !own$9.call(result, "marker")) {
    throw fault_1("Missing `marker` or `fence` in matter `%j`", result);
  }
  return result;
}
var fence_1 = fence;
function fence(matter2, prop2) {
  var marker2;
  if (matter2.marker) {
    marker2 = pick(matter2.marker, prop2);
    return marker2 + marker2 + marker2;
  }
  return pick(matter2.fence, prop2);
}
function pick(schema2, prop2) {
  return typeof schema2 === "string" ? schema2 : schema2[prop2];
}
var parse$32 = create$2;
function create$2(matter2) {
  var name3 = matter2.type + "FrontMatter";
  var open = fence_1(matter2, "open");
  var close = fence_1(matter2, "close");
  var newline2 = "\n";
  var anywhere = matter2.anywhere;
  frontmatter2.displayName = name3;
  frontmatter2.onlyAtStart = typeof anywhere === "boolean" ? !anywhere : true;
  return [name3, frontmatter2];
  function frontmatter2(eat2, value, silent) {
    var index2 = open.length;
    var offset2;
    if (value.slice(0, index2) !== open || value.charAt(index2) !== newline2) {
      return;
    }
    offset2 = value.indexOf(close, index2);
    while (offset2 !== -1 && value.charAt(offset2 - 1) !== newline2) {
      index2 = offset2 + close.length;
      offset2 = value.indexOf(close, index2);
    }
    if (offset2 !== -1) {
      if (silent) {
        return true;
      }
      return eat2(value.slice(0, offset2 + close.length))({
        type: matter2.type,
        value: value.slice(open.length + 1, offset2 - 1)
      });
    }
  }
}
var compile = create$1;
function create$1(matter2) {
  var type2 = matter2.type;
  var open = fence_1(matter2, "open");
  var close = fence_1(matter2, "close");
  frontmatter2.displayName = type2 + "FrontMatter";
  return [type2, frontmatter2];
  function frontmatter2(node2) {
    return open + (node2.value ? "\n" + node2.value : "") + "\n" + close;
  }
}
var remarkFrontmatter = frontmatter;
function frontmatter(options2) {
  var parser2 = this.Parser;
  var compiler2 = this.Compiler;
  var config = matters_1(options2 || ["yaml"]);
  if (isRemarkParser(parser2)) {
    attachParser(parser2, config);
  }
  if (isRemarkCompiler(compiler2)) {
    attachCompiler(compiler2, config);
  }
}
function attachParser(parser2, matters2) {
  var proto2 = parser2.prototype;
  var tokenizers = wrap$1(parse$32, matters2);
  var names = [];
  var key;
  for (key in tokenizers) {
    names.push(key);
  }
  proto2.blockMethods = names.concat(proto2.blockMethods);
  proto2.blockTokenizers = Object.assign({}, tokenizers, proto2.blockTokenizers);
}
function attachCompiler(compiler2, matters2) {
  var proto2 = compiler2.prototype;
  proto2.visitors = Object.assign({}, wrap$1(compile, matters2), proto2.visitors);
}
function wrap$1(func, matters2) {
  var result = {};
  var length = matters2.length;
  var index2 = -1;
  var tuple;
  while (++index2 < length) {
    tuple = func(matters2[index2]);
    result[tuple[0]] = tuple[1];
  }
  return result;
}
function isRemarkParser(parser2) {
  return Boolean(parser2 && parser2.prototype && parser2.prototype.blockTokenizers);
}
function isRemarkCompiler(compiler2) {
  return Boolean(compiler2 && compiler2.prototype && compiler2.prototype.visitors);
}
var unistBuilder = u;
function u(type2, props, value) {
  var node2;
  if ((value === null || value === void 0) && (typeof props !== "object" || Array.isArray(props))) {
    value = props;
    props = {};
  }
  node2 = Object.assign({ type: String(type2) }, props);
  if (Array.isArray(value)) {
    node2.children = value;
  } else if (value !== null && value !== void 0) {
    node2.value = String(value);
  }
  return node2;
}
var start = factory$1("start");
var end = factory$1("end");
var unistUtilPosition = position;
position.start = start;
position.end = end;
function position(node2) {
  return { start: start(node2), end: end(node2) };
}
function factory$1(type2) {
  point2.displayName = type2;
  return point2;
  function point2(node2) {
    var point3 = node2 && node2.position && node2.position[type2] || {};
    return {
      line: point3.line || null,
      column: point3.column || null,
      offset: isNaN(point3.offset) ? null : point3.offset
    };
  }
}
var unistUtilGenerated = generated;
function generated(node2) {
  var position2 = optional(optional(node2).position);
  var start2 = optional(position2.start);
  var end2 = optional(position2.end);
  return !start2.line || !start2.column || !end2.line || !end2.column;
}
function optional(value) {
  return value && typeof value === "object" ? value : {};
}
var mdastUtilDefinitions = getDefinitionFactory;
var own$8 = {}.hasOwnProperty;
function getDefinitionFactory(node2, options2) {
  return getterFactory(gather(node2, options2));
}
function gather(node2, options2) {
  var cache2 = {};
  if (!node2 || !node2.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  unistUtilVisit(node2, "definition", options2 && options2.commonmark ? commonmark2 : normal);
  return cache2;
  function commonmark2(definition2) {
    var id2 = normalise(definition2.identifier);
    if (!own$8.call(cache2, id2)) {
      cache2[id2] = definition2;
    }
  }
  function normal(definition2) {
    cache2[normalise(definition2.identifier)] = definition2;
  }
}
function getterFactory(cache2) {
  return getter;
  function getter(identifier) {
    var id2 = identifier && normalise(identifier);
    return id2 && own$8.call(cache2, id2) ? cache2[id2] : null;
  }
}
function normalise(identifier) {
  return identifier.toUpperCase();
}
var all_1$1 = all$2;
function all$2(h2, parent) {
  var nodes = parent.children || [];
  var length = nodes.length;
  var values2 = [];
  var index2 = -1;
  var result;
  var head2;
  while (++index2 < length) {
    result = one_1$1(h2, nodes[index2], parent);
    if (result) {
      if (index2 && nodes[index2 - 1].type === "break") {
        if (result.value) {
          result.value = result.value.replace(/^\s+/, "");
        }
        head2 = result.children && result.children[0];
        if (head2 && head2.value) {
          head2.value = head2.value.replace(/^\s+/, "");
        }
      }
      values2 = values2.concat(result);
    }
  }
  return values2;
}
var one_1$1 = one$2;
var own$7 = {}.hasOwnProperty;
function unknown(h2, node2) {
  if (text$2(node2)) {
    return h2.augment(node2, unistBuilder("text", node2.value));
  }
  return h2(node2, "div", all_1$1(h2, node2));
}
function one$2(h2, node2, parent) {
  var type2 = node2 && node2.type;
  var fn2 = own$7.call(h2.handlers, type2) ? h2.handlers[type2] : h2.unknownHandler;
  if (!type2) {
    throw new Error("Expected node, got `" + node2 + "`");
  }
  return (typeof fn2 === "function" ? fn2 : unknown)(h2, node2, parent);
}
function text$2(node2) {
  var data3 = node2.data || {};
  if (own$7.call(data3, "hName") || own$7.call(data3, "hProperties") || own$7.call(data3, "hChildren")) {
    return false;
  }
  return "value" in node2;
}
var thematicBreak_1 = thematicBreak;
function thematicBreak(h2, node2) {
  return h2(node2, "hr");
}
var wrap_1 = wrap;
function wrap(nodes, loose) {
  var result = [];
  var index2 = -1;
  var length = nodes.length;
  if (loose) {
    result.push(unistBuilder("text", "\n"));
  }
  while (++index2 < length) {
    if (index2) {
      result.push(unistBuilder("text", "\n"));
    }
    result.push(nodes[index2]);
  }
  if (loose && nodes.length !== 0) {
    result.push(unistBuilder("text", "\n"));
  }
  return result;
}
var list_1 = list;
function list(h2, node2) {
  var props = {};
  var name3 = node2.ordered ? "ol" : "ul";
  var items;
  var index2 = -1;
  var length;
  if (typeof node2.start === "number" && node2.start !== 1) {
    props.start = node2.start;
  }
  items = all_1$1(h2, node2);
  length = items.length;
  while (++index2 < length) {
    if (items[index2].properties.className && items[index2].properties.className.indexOf("task-list-item") !== -1) {
      props.className = ["contains-task-list"];
      break;
    }
  }
  return h2(node2, name3, props, wrap_1(items, true));
}
var footer = generateFootnotes;
function generateFootnotes(h2) {
  var footnoteById = h2.footnoteById;
  var footnoteOrder = h2.footnoteOrder;
  var length = footnoteOrder.length;
  var index2 = -1;
  var listItems = [];
  var def;
  var backReference;
  var content;
  var tail;
  while (++index2 < length) {
    def = footnoteById[footnoteOrder[index2].toUpperCase()];
    if (!def) {
      continue;
    }
    content = def.children.concat();
    tail = content[content.length - 1];
    backReference = {
      type: "link",
      url: "#fnref-" + def.identifier,
      data: { hProperties: { className: ["footnote-backref"] } },
      children: [{ type: "text", value: "↩" }]
    };
    if (!tail || tail.type !== "paragraph") {
      tail = { type: "paragraph", children: [] };
      content.push(tail);
    }
    tail.children.push(backReference);
    listItems.push({
      type: "listItem",
      data: { hProperties: { id: "fn-" + def.identifier } },
      children: content,
      position: def.position
    });
  }
  if (listItems.length === 0) {
    return null;
  }
  return h2(
    null,
    "div",
    { className: ["footnotes"] },
    wrap_1(
      [
        thematicBreak_1(h2),
        list_1(h2, { type: "list", ordered: true, children: listItems })
      ],
      true
    )
  );
}
var blockquote_1 = blockquote;
function blockquote(h2, node2) {
  return h2(node2, "blockquote", wrap_1(all_1$1(h2, node2), true));
}
var _break = hardBreak;
function hardBreak(h2, node2) {
  return [h2(node2, "br"), unistBuilder("text", "\n")];
}
var detab_1 = detab;
var tab$1 = 9;
var lineFeed$1 = 10;
var carriageReturn = 13;
function detab(value, size) {
  var string = typeof value === "string";
  var length = string && value.length;
  var start2 = 0;
  var index2 = -1;
  var column = -1;
  var tabSize2 = size || 4;
  var results = [];
  var code2;
  var add;
  if (!string) {
    throw new Error("detab expected string");
  }
  while (++index2 < length) {
    code2 = value.charCodeAt(index2);
    if (code2 === tab$1) {
      add = tabSize2 - (column + 1) % tabSize2;
      column += add;
      results.push(value.slice(start2, index2) + repeatString(" ", add));
      start2 = index2 + 1;
    } else if (code2 === lineFeed$1 || code2 === carriageReturn) {
      column = -1;
    } else {
      column++;
    }
  }
  results.push(value.slice(start2));
  return results.join("");
}
var code_1 = code;
function code(h2, node2) {
  var value = node2.value ? detab_1(node2.value + "\n") : "";
  var lang2 = node2.lang && node2.lang.match(/^[^ \t]+(?=[ \t]|$)/);
  var props = {};
  if (lang2) {
    props.className = ["language-" + lang2];
  }
  return h2(node2.position, "pre", [h2(node2, "code", props, [unistBuilder("text", value)])]);
}
var _delete = strikethrough;
function strikethrough(h2, node2) {
  return h2(node2, "del", all_1$1(h2, node2));
}
var emphasis_1 = emphasis;
function emphasis(h2, node2) {
  return h2(node2, "em", all_1$1(h2, node2));
}
var footnoteReference_1 = footnoteReference;
function footnoteReference(h2, node2) {
  var footnoteOrder = h2.footnoteOrder;
  var identifier = String(node2.identifier);
  if (footnoteOrder.indexOf(identifier) === -1) {
    footnoteOrder.push(identifier);
  }
  return h2(node2.position, "sup", { id: "fnref-" + identifier }, [
    h2(node2, "a", { href: "#fn-" + identifier, className: ["footnote-ref"] }, [
      unistBuilder("text", node2.label || identifier)
    ])
  ]);
}
var footnote_1 = footnote;
function footnote(h2, node2) {
  var footnoteById = h2.footnoteById;
  var footnoteOrder = h2.footnoteOrder;
  var identifier = 1;
  while (identifier in footnoteById) {
    identifier++;
  }
  identifier = String(identifier);
  footnoteOrder.push(identifier);
  footnoteById[identifier] = {
    type: "footnoteDefinition",
    identifier,
    children: [{ type: "paragraph", children: node2.children }],
    position: node2.position
  };
  return footnoteReference_1(h2, {
    type: "footnoteReference",
    identifier,
    position: node2.position
  });
}
var heading_1 = heading;
function heading(h2, node2) {
  return h2(node2, "h" + node2.depth, all_1$1(h2, node2));
}
var html_1$1 = html$3;
function html$3(h2, node2) {
  return h2.dangerous ? h2.augment(node2, unistBuilder("raw", node2.value)) : null;
}
var encodeCache = {};
function getEncodeCache(exclude) {
  var i, ch2, cache2 = encodeCache[exclude];
  if (cache2) {
    return cache2;
  }
  cache2 = encodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch2 = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch2)) {
      cache2.push(ch2);
    } else {
      cache2.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (i = 0; i < exclude.length; i++) {
    cache2[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache2;
}
function encode$1(string, exclude, keepEscaped) {
  var i, l2, code2, nextCode, cache2, result = "";
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  cache2 = getEncodeCache(exclude);
  for (i = 0, l2 = string.length; i < l2; i++) {
    code2 = string.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l2) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache2[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l2) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1;
var revert_1 = revert;
function revert(h2, node2) {
  var subtype = node2.referenceType;
  var suffix = "]";
  var contents;
  var head2;
  var tail;
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return unistBuilder("text", "![" + node2.alt + suffix);
  }
  contents = all_1$1(h2, node2);
  head2 = contents[0];
  if (head2 && head2.type === "text") {
    head2.value = "[" + head2.value;
  } else {
    contents.unshift(unistBuilder("text", "["));
  }
  tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push(unistBuilder("text", suffix));
  }
  return contents;
}
var imageReference_1 = imageReference;
function imageReference(h2, node2) {
  var def = h2.definition(node2.identifier);
  var props;
  if (!def) {
    return revert_1(h2, node2);
  }
  props = { src: encode_1(def.url || ""), alt: node2.alt };
  if (def.title !== null && def.title !== void 0) {
    props.title = def.title;
  }
  return h2(node2, "img", props);
}
var image_1 = image$1;
function image$1(h2, node2) {
  var props = { src: encode_1(node2.url), alt: node2.alt };
  if (node2.title !== null && node2.title !== void 0) {
    props.title = node2.title;
  }
  return h2(node2, "img", props);
}
var inlineCode_1 = inlineCode;
function inlineCode(h2, node2) {
  return h2(node2, "code", [unistBuilder("text", collapseWhiteSpace(node2.value))]);
}
var linkReference_1 = linkReference;
function linkReference(h2, node2) {
  var def = h2.definition(node2.identifier);
  var props;
  if (!def) {
    return revert_1(h2, node2);
  }
  props = { href: encode_1(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    props.title = def.title;
  }
  return h2(node2, "a", props, all_1$1(h2, node2));
}
var link_1 = link;
function link(h2, node2) {
  var props = { href: encode_1(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    props.title = node2.title;
  }
  return h2(node2, "a", props, all_1$1(h2, node2));
}
var listItem_1 = listItem$1;
function listItem$1(h2, node2, parent) {
  var children = node2.children;
  var head2 = children[0];
  var raw2 = all_1$1(h2, node2);
  var loose = parent ? listLoose(parent) : listItemLoose(node2);
  var props = {};
  var result;
  var container;
  var index2;
  var length;
  var child;
  if (loose) {
    result = raw2;
  } else {
    result = [];
    length = raw2.length;
    index2 = -1;
    while (++index2 < length) {
      child = raw2[index2];
      if (child.tagName === "p") {
        result = result.concat(child.children);
      } else {
        result.push(child);
      }
    }
  }
  if (typeof node2.checked === "boolean") {
    if (loose && (!head2 || head2.type !== "paragraph")) {
      result.unshift(h2(null, "p", []));
    }
    container = loose ? result[0].children : result;
    if (container.length !== 0) {
      container.unshift(unistBuilder("text", " "));
    }
    container.unshift(
      h2(null, "input", {
        type: "checkbox",
        checked: node2.checked,
        disabled: true
      })
    );
    props.className = ["task-list-item"];
  }
  if (loose && result.length !== 0) {
    result = wrap_1(result, true);
  }
  return h2(node2, "li", props, result);
}
function listLoose(node2) {
  var loose = node2.spread;
  var children = node2.children;
  var length = children.length;
  var index2 = -1;
  while (!loose && ++index2 < length) {
    loose = listItemLoose(children[index2]);
  }
  return loose;
}
function listItemLoose(node2) {
  var spread = node2.spread;
  return spread === void 0 || spread === null ? node2.children.length > 1 : spread;
}
var paragraph_1 = paragraph;
function paragraph(h2, node2) {
  return h2(node2, "p", all_1$1(h2, node2));
}
var root_1 = root;
function root(h2, node2) {
  return h2.augment(node2, unistBuilder("root", wrap_1(all_1$1(h2, node2))));
}
var strong_1 = strong;
function strong(h2, node2) {
  return h2(node2, "strong", all_1$1(h2, node2));
}
var table_1 = table;
function table(h2, node2) {
  var rows = node2.children;
  var index2 = rows.length;
  var align = node2.align;
  var alignLength = align.length;
  var result = [];
  var pos;
  var row;
  var out;
  var name3;
  var cell;
  while (index2--) {
    row = rows[index2].children;
    name3 = index2 === 0 ? "th" : "td";
    pos = alignLength;
    out = [];
    while (pos--) {
      cell = row[pos];
      out[pos] = h2(cell, name3, { align: align[pos] }, cell ? all_1$1(h2, cell) : []);
    }
    result[index2] = h2(rows[index2], "tr", wrap_1(out, true));
  }
  return h2(
    node2,
    "table",
    wrap_1(
      [
        h2(result[0].position, "thead", wrap_1([result[0]], true)),
        h2(
          {
            start: unistUtilPosition.start(result[1]),
            end: unistUtilPosition.end(result[result.length - 1])
          },
          "tbody",
          wrap_1(result.slice(1), true)
        )
      ],
      true
    )
  );
}
var trimLines_1 = trimLines;
var ws = /[ \t]*\n+[ \t]*/g;
var newline$1 = "\n";
function trimLines(value) {
  return String(value).replace(ws, newline$1);
}
var text_1$1 = text$1;
function text$1(h2, node2) {
  return h2.augment(node2, unistBuilder("text", trimLines_1(node2.value)));
}
var handlers$1 = {
  blockquote: blockquote_1,
  break: _break,
  code: code_1,
  delete: _delete,
  emphasis: emphasis_1,
  footnoteReference: footnoteReference_1,
  footnote: footnote_1,
  heading: heading_1,
  html: html_1$1,
  imageReference: imageReference_1,
  image: image_1,
  inlineCode: inlineCode_1,
  linkReference: linkReference_1,
  link: link_1,
  listItem: listItem_1,
  list: list_1,
  paragraph: paragraph_1,
  root: root_1,
  strong: strong_1,
  table: table_1,
  text: text_1$1,
  thematicBreak: thematicBreak_1,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return null;
}
var lib$2 = toHast;
var own$6 = {}.hasOwnProperty;
var deprecationWarningIssued = false;
function factory(tree, options2) {
  var settings = options2 || {};
  if (settings.allowDangerousHTML !== void 0 && !deprecationWarningIssued) {
    deprecationWarningIssued = true;
    console.warn(
      "mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead"
    );
  }
  var dangerous2 = settings.allowDangerousHtml || settings.allowDangerousHTML;
  var footnoteById = {};
  h2.dangerous = dangerous2;
  h2.definition = mdastUtilDefinitions(tree, settings);
  h2.footnoteById = footnoteById;
  h2.footnoteOrder = [];
  h2.augment = augment;
  h2.handlers = Object.assign({}, handlers$1, settings.handlers);
  h2.unknownHandler = settings.unknownHandler;
  unistUtilVisit(tree, "footnoteDefinition", onfootnotedefinition);
  return h2;
  function augment(left2, right2) {
    var data3;
    var ctx;
    if (left2 && "data" in left2) {
      data3 = left2.data;
      if (right2.type === "element" && data3.hName) {
        right2.tagName = data3.hName;
      }
      if (right2.type === "element" && data3.hProperties) {
        right2.properties = Object.assign({}, right2.properties, data3.hProperties);
      }
      if (right2.children && data3.hChildren) {
        right2.children = data3.hChildren;
      }
    }
    ctx = left2 && left2.position ? left2 : { position: left2 };
    if (!unistUtilGenerated(ctx)) {
      right2.position = {
        start: unistUtilPosition.start(ctx),
        end: unistUtilPosition.end(ctx)
      };
    }
    return right2;
  }
  function h2(node2, tagName, props, children) {
    if ((children === void 0 || children === null) && typeof props === "object" && "length" in props) {
      children = props;
      props = {};
    }
    return augment(node2, {
      type: "element",
      tagName,
      properties: props || {},
      children: children || []
    });
  }
  function onfootnotedefinition(definition2) {
    var id2 = String(definition2.identifier).toUpperCase();
    if (!own$6.call(footnoteById, id2)) {
      footnoteById[id2] = definition2;
    }
  }
}
function toHast(tree, options2) {
  var h2 = factory(tree, options2);
  var node2 = one_1$1(h2, tree);
  var foot = footer(h2);
  if (foot) {
    node2.children = node2.children.concat(unistBuilder("text", "\n"), foot);
  }
  return node2;
}
var mdastUtilToHast = lib$2;
var remarkRehype = remark2rehype;
function remark2rehype(destination, options2) {
  if (destination && !destination.process) {
    options2 = destination;
    destination = null;
  }
  return destination ? bridge(destination, options2) : mutate(options2);
}
function bridge(destination, options2) {
  return transformer;
  function transformer(node2, file, next) {
    destination.run(mdastUtilToHast(node2, options2), file, done);
    function done(err) {
      next(err);
    }
  }
}
function mutate(options2) {
  return transformer;
  function transformer(node2) {
    return mdastUtilToHast(node2, options2);
  }
}
var schema$1 = Schema$2;
var proto$2 = Schema$2.prototype;
proto$2.space = null;
proto$2.normal = {};
proto$2.property = {};
function Schema$2(property, normal, space2) {
  this.property = property;
  this.normal = normal;
  if (space2) {
    this.space = space2;
  }
}
var merge_1 = merge$1;
function merge$1(definitions) {
  var length = definitions.length;
  var property = [];
  var normal = [];
  var index2 = -1;
  var info2;
  var space2;
  while (++index2 < length) {
    info2 = definitions[index2];
    property.push(info2.property);
    normal.push(info2.normal);
    space2 = info2.space;
  }
  return new schema$1(
    immutable.apply(null, property),
    immutable.apply(null, normal),
    space2
  );
}
var normalize_1 = normalize2;
function normalize2(value) {
  return value.toLowerCase();
}
var info = Info;
var proto$1 = Info.prototype;
proto$1.space = null;
proto$1.attribute = null;
proto$1.property = null;
proto$1.boolean = false;
proto$1.booleanish = false;
proto$1.overloadedBoolean = false;
proto$1.number = false;
proto$1.commaSeparated = false;
proto$1.spaceSeparated = false;
proto$1.commaOrSpaceSeparated = false;
proto$1.mustUseProperty = false;
proto$1.defined = false;
function Info(property, attribute2) {
  this.property = property;
  this.attribute = attribute2;
}
var powers = 0;
var boolean_1 = increment();
var booleanish$2 = increment();
var overloadedBoolean$1 = increment();
var number$3 = increment();
var spaceSeparated$3 = increment();
var commaSeparated$2 = increment();
var commaOrSpaceSeparated$1 = increment();
function increment() {
  return Math.pow(2, ++powers);
}
var types2 = {
  boolean: boolean_1,
  booleanish: booleanish$2,
  overloadedBoolean: overloadedBoolean$1,
  number: number$3,
  spaceSeparated: spaceSeparated$3,
  commaSeparated: commaSeparated$2,
  commaOrSpaceSeparated: commaOrSpaceSeparated$1
};
var definedInfo = DefinedInfo;
DefinedInfo.prototype = new info();
DefinedInfo.prototype.defined = true;
var checks = [
  "boolean",
  "booleanish",
  "overloadedBoolean",
  "number",
  "commaSeparated",
  "spaceSeparated",
  "commaOrSpaceSeparated"
];
var checksLength = checks.length;
function DefinedInfo(property, attribute2, mask, space2) {
  var index2 = -1;
  var check2;
  mark$1(this, "space", space2);
  info.call(this, property, attribute2);
  while (++index2 < checksLength) {
    check2 = checks[index2];
    mark$1(this, check2, (mask & types2[check2]) === types2[check2]);
  }
}
function mark$1(values2, key, value) {
  if (value) {
    values2[key] = value;
  }
}
var create_1 = create;
function create(definition2) {
  var space2 = definition2.space;
  var mustUseProperty = definition2.mustUseProperty || [];
  var attributes2 = definition2.attributes || {};
  var props = definition2.properties;
  var transform2 = definition2.transform;
  var property = {};
  var normal = {};
  var prop2;
  var info2;
  for (prop2 in props) {
    info2 = new definedInfo(
      prop2,
      transform2(attributes2, prop2),
      props[prop2],
      space2
    );
    if (mustUseProperty.indexOf(prop2) !== -1) {
      info2.mustUseProperty = true;
    }
    property[prop2] = info2;
    normal[normalize_1(prop2)] = prop2;
    normal[normalize_1(info2.attribute)] = prop2;
  }
  return new schema$1(property, normal, space2);
}
var xlink = create_1({
  space: "xlink",
  transform: xlinkTransform,
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
function xlinkTransform(_2, prop2) {
  return "xlink:" + prop2.slice(5).toLowerCase();
}
var xml = create_1({
  space: "xml",
  transform: xmlTransform,
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});
function xmlTransform(_2, prop2) {
  return "xml:" + prop2.slice(3).toLowerCase();
}
var caseSensitiveTransform_1 = caseSensitiveTransform;
function caseSensitiveTransform(attributes2, attribute2) {
  return attribute2 in attributes2 ? attributes2[attribute2] : attribute2;
}
var caseInsensitiveTransform_1 = caseInsensitiveTransform;
function caseInsensitiveTransform(attributes2, property) {
  return caseSensitiveTransform_1(attributes2, property.toLowerCase());
}
var xmlns = create_1({
  space: "xmlns",
  attributes: {
    xmlnsxlink: "xmlns:xlink"
  },
  transform: caseInsensitiveTransform_1,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
});
var booleanish$1 = types2.booleanish;
var number$2 = types2.number;
var spaceSeparated$2 = types2.spaceSeparated;
var aria = create_1({
  transform: ariaTransform,
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$1,
    ariaAutoComplete: null,
    ariaBusy: booleanish$1,
    ariaChecked: booleanish$1,
    ariaColCount: number$2,
    ariaColIndex: number$2,
    ariaColSpan: number$2,
    ariaControls: spaceSeparated$2,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$2,
    ariaDetails: null,
    ariaDisabled: booleanish$1,
    ariaDropEffect: spaceSeparated$2,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$1,
    ariaFlowTo: spaceSeparated$2,
    ariaGrabbed: booleanish$1,
    ariaHasPopup: null,
    ariaHidden: booleanish$1,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$2,
    ariaLevel: number$2,
    ariaLive: null,
    ariaModal: booleanish$1,
    ariaMultiLine: booleanish$1,
    ariaMultiSelectable: booleanish$1,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$2,
    ariaPlaceholder: null,
    ariaPosInSet: number$2,
    ariaPressed: booleanish$1,
    ariaReadOnly: booleanish$1,
    ariaRelevant: null,
    ariaRequired: booleanish$1,
    ariaRoleDescription: spaceSeparated$2,
    ariaRowCount: number$2,
    ariaRowIndex: number$2,
    ariaRowSpan: number$2,
    ariaSelected: booleanish$1,
    ariaSetSize: number$2,
    ariaSort: null,
    ariaValueMax: number$2,
    ariaValueMin: number$2,
    ariaValueNow: number$2,
    ariaValueText: null,
    role: null
  }
});
function ariaTransform(_2, prop2) {
  return prop2 === "role" ? prop2 : "aria-" + prop2.slice(4).toLowerCase();
}
var boolean$1 = types2.boolean;
var overloadedBoolean = types2.overloadedBoolean;
var booleanish = types2.booleanish;
var number$1 = types2.number;
var spaceSeparated$1 = types2.spaceSeparated;
var commaSeparated$1 = types2.commaSeparated;
var html$2 = create_1({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform_1,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated$1,
    acceptCharset: spaceSeparated$1,
    accessKey: spaceSeparated$1,
    action: null,
    allow: null,
    allowFullScreen: boolean$1,
    allowPaymentRequest: boolean$1,
    allowUserMedia: boolean$1,
    alt: null,
    as: null,
    async: boolean$1,
    autoCapitalize: null,
    autoComplete: spaceSeparated$1,
    autoFocus: boolean$1,
    autoPlay: boolean$1,
    capture: boolean$1,
    charSet: null,
    checked: boolean$1,
    cite: null,
    className: spaceSeparated$1,
    cols: number$1,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean$1,
    controlsList: spaceSeparated$1,
    coords: number$1 | commaSeparated$1,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean$1,
    defer: boolean$1,
    dir: null,
    dirName: null,
    disabled: boolean$1,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean$1,
    formTarget: null,
    headers: spaceSeparated$1,
    height: number$1,
    hidden: boolean$1,
    high: number$1,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated$1,
    httpEquiv: spaceSeparated$1,
    id: null,
    imageSizes: null,
    imageSrcSet: commaSeparated$1,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean$1,
    itemId: null,
    itemProp: spaceSeparated$1,
    itemRef: spaceSeparated$1,
    itemScope: boolean$1,
    itemType: spaceSeparated$1,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loop: boolean$1,
    low: number$1,
    manifest: null,
    max: null,
    maxLength: number$1,
    media: null,
    method: null,
    min: null,
    minLength: number$1,
    multiple: boolean$1,
    muted: boolean$1,
    name: null,
    nonce: null,
    noModule: boolean$1,
    noValidate: boolean$1,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextMenu: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean$1,
    optimum: number$1,
    pattern: null,
    ping: spaceSeparated$1,
    placeholder: null,
    playsInline: boolean$1,
    poster: null,
    preload: null,
    readOnly: boolean$1,
    referrerPolicy: null,
    rel: spaceSeparated$1,
    required: boolean$1,
    reversed: boolean$1,
    rows: number$1,
    rowSpan: number$1,
    sandbox: spaceSeparated$1,
    scope: null,
    scoped: boolean$1,
    seamless: boolean$1,
    selected: boolean$1,
    shape: null,
    size: number$1,
    sizes: null,
    slot: null,
    span: number$1,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: commaSeparated$1,
    start: number$1,
    step: null,
    style: null,
    tabIndex: number$1,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean$1,
    useMap: null,
    value: booleanish,
    width: number$1,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated$1,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number$1,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number$1,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean$1,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean$1,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number$1,
    // `<img>` and `<object>`
    leftMargin: number$1,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number$1,
    // `<body>`
    marginWidth: number$1,
    // `<body>`
    noResize: boolean$1,
    // `<frame>`
    noHref: boolean$1,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean$1,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean$1,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number$1,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number$1,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number$1,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean$1,
    disableRemotePlayback: boolean$1,
    prefix: null,
    property: null,
    results: number$1,
    security: null,
    unselectable: null
  }
});
var html_1 = merge_1([xml, xlink, xmlns, aria, html$2]);
var boolean = types2.boolean;
var number = types2.number;
var spaceSeparated = types2.spaceSeparated;
var commaSeparated = types2.commaSeparated;
var commaOrSpaceSeparated = types2.commaOrSpaceSeparated;
var svg = create_1({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform_1,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
var svg_1 = merge_1([xml, xlink, xmlns, aria, svg]);
var index$2 = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "nextid",
  "param",
  "source",
  "track",
  "wbr"
];
var htmlVoidElements = Object.freeze({
  __proto__: null,
  "default": index$2
});
var unistUtilIs = is3;
function is3(test2, node2, index2, parent, context2) {
  var hasParent = parent !== null && parent !== void 0;
  var hasIndex = index2 !== null && index2 !== void 0;
  var check2 = convert(test2);
  if (hasIndex && (typeof index2 !== "number" || index2 < 0 || index2 === Infinity)) {
    throw new Error("Expected positive finite index or child node");
  }
  if (hasParent && (!is3(null, parent) || !parent.children)) {
    throw new Error("Expected parent node");
  }
  if (!node2 || !node2.type || typeof node2.type !== "string") {
    return false;
  }
  if (hasParent !== hasIndex) {
    throw new Error("Expected both parent and index");
  }
  return Boolean(check2.call(context2, node2, index2, parent));
}
function convert(test2) {
  if (typeof test2 === "string") {
    return typeFactory(test2);
  }
  if (test2 === null || test2 === void 0) {
    return ok;
  }
  if (typeof test2 === "object") {
    return ("length" in test2 ? anyFactory : matchesFactory)(test2);
  }
  if (typeof test2 === "function") {
    return test2;
  }
  throw new Error("Expected function, string, or object as test");
}
function convertAll(tests2) {
  var results = [];
  var length = tests2.length;
  var index2 = -1;
  while (++index2 < length) {
    results[index2] = convert(tests2[index2]);
  }
  return results;
}
function matchesFactory(test2) {
  return matches;
  function matches(node2) {
    var key;
    for (key in test2) {
      if (node2[key] !== test2[key]) {
        return false;
      }
    }
    return true;
  }
}
function anyFactory(tests2) {
  var checks2 = convertAll(tests2);
  var length = checks2.length;
  return matches;
  function matches() {
    var index2 = -1;
    while (++index2 < length) {
      if (checks2[index2].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  }
}
function typeFactory(test2) {
  return type2;
  function type2(node2) {
    return Boolean(node2 && node2.type === test2);
  }
}
function ok() {
  return true;
}
var hastUtilIsElement = isElement;
function isElement(node2, tagNames) {
  var name3;
  if (!(tagNames === null || tagNames === void 0 || typeof tagNames === "string" || typeof tagNames === "object" && tagNames.length !== 0)) {
    throw new Error(
      "Expected `string` or `Array.<string>` for `tagNames`, not `" + tagNames + "`"
    );
  }
  if (!node2 || typeof node2 !== "object" || node2.type !== "element" || typeof node2.tagName !== "string") {
    return false;
  }
  if (tagNames === null || tagNames === void 0) {
    return true;
  }
  name3 = node2.tagName;
  if (typeof tagNames === "string") {
    return name3 === tagNames;
  }
  return tagNames.indexOf(name3) !== -1;
}
var hastUtilWhitespace = interElementWhiteSpace;
var re2 = /[ \t\n\f\r]/g;
function interElementWhiteSpace(node2) {
  var value;
  if (node2 && typeof node2 === "object" && node2.type === "text") {
    value = node2.value || "";
  } else if (typeof node2 === "string") {
    value = node2;
  } else {
    return false;
  }
  return value.replace(re2, "") === "";
}
var before$1 = siblings(-1);
var after$2 = siblings(1);
function siblings(increment2) {
  return sibling;
  function sibling(parent, index2, includeWhiteSpace) {
    var siblings2 = parent && parent.children;
    var next;
    index2 += increment2;
    next = siblings2 && siblings2[index2];
    if (!includeWhiteSpace) {
      while (next && hastUtilWhitespace(next)) {
        index2 += increment2;
        next = siblings2[index2];
      }
    }
    return next;
  }
}
var siblings_1 = {
  before: before$1,
  after: after$2
};
var after$1 = siblings_1.after;
var first_1 = first;
function first(parent, includeWhiteSpace) {
  return after$1(parent, -1, includeWhiteSpace);
}
var place_1 = place;
function place(parent, child) {
  return parent && parent.children && parent.children.indexOf(child);
}
var whiteSpaceLeft_1 = whiteSpaceLeft;
function whiteSpaceLeft(node2) {
  return unistUtilIs("text", node2) && hastUtilWhitespace(node2.value.charAt(0));
}
var omission_1 = omission$1;
var own$5 = {}.hasOwnProperty;
function omission$1(handlers3) {
  return omit;
  function omit(node2, index2, parent) {
    var name3 = node2.tagName;
    var fn2 = own$5.call(handlers3, name3) ? handlers3[name3] : false;
    return fn2 ? fn2(node2, index2, parent) : false;
  }
}
var after = siblings_1.after;
var optionGroup = "optgroup";
var options = ["option"].concat(optionGroup);
var dataListItem = ["dt", "dd"];
var listItem = "li";
var menuContent = ["menuitem", "hr", "menu"];
var ruby = ["rp", "rt"];
var tableContainer = ["tbody", "tfoot"];
var tableRow$1 = "tr";
var tableCell = ["td", "th"];
var confusingParagraphParent = ["a", "audio", "del", "ins", "map", "noscript", "video"];
var clearParagraphSibling = [
  "address",
  "article",
  "aside",
  "blockquote",
  "details",
  "div",
  "dl",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "hr",
  "main",
  "menu",
  "nav",
  "ol",
  "p",
  "pre",
  "section",
  "table",
  "ul"
];
var closing$1 = omission_1({
  html: html$1,
  head: headOrColgroupOrCaption,
  body: body$1,
  p,
  li,
  dt: dt2,
  dd,
  rt: rubyElement,
  rp: rubyElement,
  optgroup,
  option,
  menuitem,
  colgroup: headOrColgroupOrCaption,
  caption: headOrColgroupOrCaption,
  thead,
  tbody: tbody$1,
  tfoot,
  tr: tr2,
  td: cells,
  th: cells
});
function headOrColgroupOrCaption(node2, index2, parent) {
  var next = after(parent, index2, true);
  return !next || !unistUtilIs("comment", next) && !whiteSpaceLeft_1(next);
}
function html$1(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || !unistUtilIs("comment", next);
}
function body$1(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || !unistUtilIs("comment", next);
}
function p(node2, index2, parent) {
  var next = after(parent, index2);
  return next ? hastUtilIsElement(next, clearParagraphSibling) : !parent || !hastUtilIsElement(parent, confusingParagraphParent);
}
function li(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, listItem);
}
function dt2(node2, index2, parent) {
  var next = after(parent, index2);
  return next && hastUtilIsElement(next, dataListItem);
}
function dd(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, dataListItem);
}
function rubyElement(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, ruby);
}
function optgroup(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, optionGroup);
}
function option(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, options);
}
function menuitem(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, menuContent);
}
function thead(node2, index2, parent) {
  var next = after(parent, index2);
  return next && hastUtilIsElement(next, tableContainer);
}
function tbody$1(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, tableContainer);
}
function tfoot(node2, index2, parent) {
  return !after(parent, index2);
}
function tr2(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, tableRow$1);
}
function cells(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, tableCell);
}
var before = siblings_1.before;
var own$4 = {}.hasOwnProperty;
var uniqueHeadMetadata = ["title", "base"];
var meta = ["meta", "link", "script", "style", "template"];
var tableContainers = ["thead", "tbody"];
var tableRow = "tr";
var opening$1 = omission_1({
  html,
  head,
  body,
  colgroup,
  tbody
});
function html(node2) {
  var head2 = first_1(node2);
  return !head2 || !unistUtilIs("comment", head2);
}
function head(node2) {
  var children = node2.children;
  var length = children.length;
  var map2 = {};
  var index2 = -1;
  var child;
  var name3;
  while (++index2 < length) {
    child = children[index2];
    name3 = child.tagName;
    if (hastUtilIsElement(child, uniqueHeadMetadata)) {
      if (own$4.call(map2, name3)) {
        return false;
      }
      map2[name3] = true;
    }
  }
  return Boolean(length);
}
function body(node2) {
  var head2 = first_1(node2, true);
  return !head2 || !unistUtilIs("comment", head2) && !whiteSpaceLeft_1(head2) && !hastUtilIsElement(head2, meta);
}
function colgroup(node2, index2, parent) {
  var prev = before(parent, index2);
  var head2 = first_1(node2, true);
  if (hastUtilIsElement(prev, "colgroup") && closing$1(prev, place_1(parent, prev), parent)) {
    return false;
  }
  return head2 && hastUtilIsElement(head2, "col");
}
function tbody(node2, index2, parent) {
  var prev = before(parent, index2);
  var head2 = first_1(node2);
  if (hastUtilIsElement(prev, tableContainers) && closing$1(prev, place_1(parent, prev), parent)) {
    return false;
  }
  return head2 && hastUtilIsElement(head2, tableRow);
}
var opening = opening$1;
var closing = closing$1;
var omission = {
  opening,
  closing
};
var index$1 = [
  "script",
  "style",
  "pre",
  "textarea"
];
var htmlWhitespaceSensitiveTagNames = Object.freeze({
  __proto__: null,
  "default": index$1
});
var sensitive = getCjsExportFromNamespace2(htmlWhitespaceSensitiveTagNames);
var all_1 = all$1;
function all$1(ctx, parent) {
  var children = parent && parent.children;
  var length = children && children.length;
  var index2 = -1;
  var results = [];
  let printWidthOffset = 0;
  let innerTextLength = 0;
  while (++index2 < length) {
    innerTextLength = getInnerTextLength(children[index2]);
    results[index2] = one_1(ctx, children[index2], index2, parent, printWidthOffset, innerTextLength);
    printWidthOffset = results[index2].replace(/\n+/g, "").length;
  }
  return results.join("");
}
function getInnerTextLength(node2) {
  if (sensitive.indexOf(node2.tagName) !== -1) {
    return 0;
  }
  if (!node2.children || !node2.children.length) {
    return 0;
  }
  var child = node2.children[0];
  if (child.type === "text" || child.type === "comment") {
    return child.value.split("\n")[0].length;
  }
  return 0;
}
var text_1 = text2;
function text2(ctx, node2, index2, parent) {
  var value = node2.value;
  return value;
}
var data2 = "data";
var find_1 = find;
var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap$1 = /[A-Z]/g;
function find(schema2, value) {
  var normal = normalize_1(value);
  var prop2 = value;
  var Type2 = info;
  if (normal in schema2.normal) {
    return schema2.property[schema2.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === data2 && valid.test(value)) {
    if (value.charAt(4) === "-") {
      prop2 = datasetToProperty(value);
    } else {
      value = datasetToAttribute(value);
    }
    Type2 = definedInfo;
  }
  return new Type2(prop2, value);
}
function datasetToProperty(attribute2) {
  var value = attribute2.slice(5).replace(dash, camelcase);
  return data2 + value.charAt(0).toUpperCase() + value.slice(1);
}
function datasetToAttribute(property) {
  var value = property.slice(4);
  if (dash.test(value)) {
    return property;
  }
  value = value.replace(cap$1, kebab);
  if (value.charAt(0) !== "-") {
    value = "-" + value;
  }
  return data2 + value;
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
var parse_1 = parse$22;
var stringify_1 = stringify$2;
var comma2 = ",";
var space$2 = " ";
var empty$12 = "";
function parse$22(value) {
  var values2 = [];
  var input = String(value || empty$12);
  var index2 = input.indexOf(comma2);
  var lastIndex = 0;
  var end2 = false;
  var val;
  while (!end2) {
    if (index2 === -1) {
      index2 = input.length;
      end2 = true;
    }
    val = input.slice(lastIndex, index2).trim();
    if (val || !end2) {
      values2.push(val);
    }
    lastIndex = index2 + 1;
    index2 = input.indexOf(comma2, lastIndex);
  }
  return values2;
}
function stringify$2(values2, options2) {
  var settings = options2 || {};
  var left2 = settings.padLeft === false ? empty$12 : space$2;
  var right2 = settings.padRight ? space$2 : empty$12;
  if (values2[values2.length - 1] === empty$12) {
    values2 = values2.concat(empty$12);
  }
  return values2.join(right2 + comma2 + left2).trim();
}
var commaSeparatedTokens = {
  parse: parse_1,
  stringify: stringify_1
};
var nbsp = " ";
var iexcl = "¡";
var cent = "¢";
var pound = "£";
var curren = "¤";
var yen = "¥";
var brvbar = "¦";
var sect = "§";
var uml = "¨";
var copy = "©";
var ordf = "ª";
var laquo = "«";
var not = "¬";
var shy = "­";
var reg = "®";
var macr = "¯";
var deg = "°";
var plusmn = "±";
var sup2 = "²";
var sup3 = "³";
var acute = "´";
var micro = "µ";
var para = "¶";
var middot = "·";
var cedil = "¸";
var sup1 = "¹";
var ordm = "º";
var raquo = "»";
var frac14 = "¼";
var frac12 = "½";
var frac34 = "¾";
var iquest = "¿";
var Agrave = "À";
var Aacute = "Á";
var Acirc = "Â";
var Atilde = "Ã";
var Auml = "Ä";
var Aring = "Å";
var AElig = "Æ";
var Ccedil = "Ç";
var Egrave = "È";
var Eacute = "É";
var Ecirc = "Ê";
var Euml = "Ë";
var Igrave = "Ì";
var Iacute = "Í";
var Icirc = "Î";
var Iuml = "Ï";
var ETH = "Ð";
var Ntilde = "Ñ";
var Ograve = "Ò";
var Oacute = "Ó";
var Ocirc = "Ô";
var Otilde = "Õ";
var Ouml = "Ö";
var times = "×";
var Oslash = "Ø";
var Ugrave = "Ù";
var Uacute = "Ú";
var Ucirc = "Û";
var Uuml = "Ü";
var Yacute = "Ý";
var THORN = "Þ";
var szlig = "ß";
var agrave = "à";
var aacute = "á";
var acirc = "â";
var atilde = "ã";
var auml = "ä";
var aring = "å";
var aelig = "æ";
var ccedil = "ç";
var egrave = "è";
var eacute = "é";
var ecirc = "ê";
var euml = "ë";
var igrave = "ì";
var iacute = "í";
var icirc = "î";
var iuml = "ï";
var eth = "ð";
var ntilde = "ñ";
var ograve = "ò";
var oacute = "ó";
var ocirc = "ô";
var otilde = "õ";
var ouml = "ö";
var divide = "÷";
var oslash = "ø";
var ugrave = "ù";
var uacute = "ú";
var ucirc = "û";
var uuml = "ü";
var yacute = "ý";
var thorn = "þ";
var yuml = "ÿ";
var fnof = "ƒ";
var Alpha = "Α";
var Beta = "Β";
var Gamma = "Γ";
var Delta = "Δ";
var Epsilon = "Ε";
var Zeta = "Ζ";
var Eta = "Η";
var Theta = "Θ";
var Iota = "Ι";
var Kappa = "Κ";
var Lambda = "Λ";
var Mu2 = "Μ";
var Nu2 = "Ν";
var Xi2 = "Ξ";
var Omicron = "Ο";
var Pi2 = "Π";
var Rho = "Ρ";
var Sigma = "Σ";
var Tau = "Τ";
var Upsilon = "Υ";
var Phi = "Φ";
var Chi = "Χ";
var Psi = "Ψ";
var Omega = "Ω";
var alpha = "α";
var beta = "β";
var gamma = "γ";
var delta = "δ";
var epsilon = "ε";
var zeta = "ζ";
var eta = "η";
var theta = "θ";
var iota = "ι";
var kappa = "κ";
var lambda = "λ";
var mu2 = "μ";
var nu2 = "ν";
var xi2 = "ξ";
var omicron = "ο";
var pi2 = "π";
var rho = "ρ";
var sigmaf = "ς";
var sigma = "σ";
var tau = "τ";
var upsilon = "υ";
var phi = "φ";
var chi = "χ";
var psi = "ψ";
var omega = "ω";
var thetasym = "ϑ";
var upsih = "ϒ";
var piv = "ϖ";
var bull = "•";
var hellip = "…";
var prime = "′";
var Prime = "″";
var oline = "‾";
var frasl = "⁄";
var weierp = "℘";
var image = "ℑ";
var real = "ℜ";
var trade = "™";
var alefsym = "ℵ";
var larr = "←";
var uarr = "↑";
var rarr = "→";
var darr = "↓";
var harr = "↔";
var crarr = "↵";
var lArr = "⇐";
var uArr = "⇑";
var rArr = "⇒";
var dArr = "⇓";
var hArr = "⇔";
var forall = "∀";
var part = "∂";
var exist = "∃";
var empty2 = "∅";
var nabla = "∇";
var isin = "∈";
var notin = "∉";
var ni = "∋";
var prod = "∏";
var sum2 = "∑";
var minus = "−";
var lowast = "∗";
var radic = "√";
var prop = "∝";
var infin = "∞";
var ang = "∠";
var and = "∧";
var or2 = "∨";
var cap = "∩";
var cup = "∪";
var int = "∫";
var there4 = "∴";
var sim = "∼";
var cong = "≅";
var asymp = "≈";
var ne2 = "≠";
var equiv = "≡";
var le2 = "≤";
var ge2 = "≥";
var sub = "⊂";
var sup = "⊃";
var nsub = "⊄";
var sube = "⊆";
var supe = "⊇";
var oplus = "⊕";
var otimes = "⊗";
var perp = "⊥";
var sdot = "⋅";
var lceil = "⌈";
var rceil = "⌉";
var lfloor = "⌊";
var rfloor = "⌋";
var lang = "〈";
var rang = "〉";
var loz = "◊";
var spades = "♠";
var clubs = "♣";
var hearts = "♥";
var diams = "♦";
var quot = '"';
var amp = "&";
var lt2 = "<";
var gt2 = ">";
var OElig = "Œ";
var oelig = "œ";
var Scaron = "Š";
var scaron = "š";
var Yuml = "Ÿ";
var circ = "ˆ";
var tilde = "˜";
var ensp = " ";
var emsp = " ";
var thinsp = " ";
var zwnj = "‌";
var zwj = "‍";
var lrm = "‎";
var rlm = "‏";
var ndash = "–";
var mdash = "—";
var lsquo = "‘";
var rsquo = "’";
var sbquo = "‚";
var ldquo = "“";
var rdquo = "”";
var bdquo = "„";
var dagger = "†";
var Dagger = "‡";
var permil = "‰";
var lsaquo = "‹";
var rsaquo = "›";
var euro = "€";
var index = {
  nbsp,
  iexcl,
  cent,
  pound,
  curren,
  yen,
  brvbar,
  sect,
  uml,
  copy,
  ordf,
  laquo,
  not,
  shy,
  reg,
  macr,
  deg,
  plusmn,
  sup2,
  sup3,
  acute,
  micro,
  para,
  middot,
  cedil,
  sup1,
  ordm,
  raquo,
  frac14,
  frac12,
  frac34,
  iquest,
  Agrave,
  Aacute,
  Acirc,
  Atilde,
  Auml,
  Aring,
  AElig,
  Ccedil,
  Egrave,
  Eacute,
  Ecirc,
  Euml,
  Igrave,
  Iacute,
  Icirc,
  Iuml,
  ETH,
  Ntilde,
  Ograve,
  Oacute,
  Ocirc,
  Otilde,
  Ouml,
  times,
  Oslash,
  Ugrave,
  Uacute,
  Ucirc,
  Uuml,
  Yacute,
  THORN,
  szlig,
  agrave,
  aacute,
  acirc,
  atilde,
  auml,
  aring,
  aelig,
  ccedil,
  egrave,
  eacute,
  ecirc,
  euml,
  igrave,
  iacute,
  icirc,
  iuml,
  eth,
  ntilde,
  ograve,
  oacute,
  ocirc,
  otilde,
  ouml,
  divide,
  oslash,
  ugrave,
  uacute,
  ucirc,
  uuml,
  yacute,
  thorn,
  yuml,
  fnof,
  Alpha,
  Beta,
  Gamma,
  Delta,
  Epsilon,
  Zeta,
  Eta,
  Theta,
  Iota,
  Kappa,
  Lambda,
  Mu: Mu2,
  Nu: Nu2,
  Xi: Xi2,
  Omicron,
  Pi: Pi2,
  Rho,
  Sigma,
  Tau,
  Upsilon,
  Phi,
  Chi,
  Psi,
  Omega,
  alpha,
  beta,
  gamma,
  delta,
  epsilon,
  zeta,
  eta,
  theta,
  iota,
  kappa,
  lambda,
  mu: mu2,
  nu: nu2,
  xi: xi2,
  omicron,
  pi: pi2,
  rho,
  sigmaf,
  sigma,
  tau,
  upsilon,
  phi,
  chi,
  psi,
  omega,
  thetasym,
  upsih,
  piv,
  bull,
  hellip,
  prime,
  Prime,
  oline,
  frasl,
  weierp,
  image,
  real,
  trade,
  alefsym,
  larr,
  uarr,
  rarr,
  darr,
  harr,
  crarr,
  lArr,
  uArr,
  rArr,
  dArr,
  hArr,
  forall,
  part,
  exist,
  empty: empty2,
  nabla,
  isin,
  notin,
  ni,
  prod,
  sum: sum2,
  minus,
  lowast,
  radic,
  prop,
  infin,
  ang,
  and,
  or: or2,
  cap,
  cup,
  int,
  there4,
  sim,
  cong,
  asymp,
  ne: ne2,
  equiv,
  le: le2,
  ge: ge2,
  sub,
  sup,
  nsub,
  sube,
  supe,
  oplus,
  otimes,
  perp,
  sdot,
  lceil,
  rceil,
  lfloor,
  rfloor,
  lang,
  rang,
  loz,
  spades,
  clubs,
  hearts,
  diams,
  quot,
  amp,
  lt: lt2,
  gt: gt2,
  OElig,
  oelig,
  Scaron,
  scaron,
  Yuml,
  circ,
  tilde,
  ensp,
  emsp,
  thinsp,
  zwnj,
  zwj,
  lrm,
  rlm,
  ndash,
  mdash,
  lsquo,
  rsquo,
  sbquo,
  ldquo,
  rdquo,
  bdquo,
  dagger,
  Dagger,
  permil,
  lsaquo,
  rsaquo,
  euro
};
var characterEntitiesHtml4 = Object.freeze({
  __proto__: null,
  nbsp,
  iexcl,
  cent,
  pound,
  curren,
  yen,
  brvbar,
  sect,
  uml,
  copy,
  ordf,
  laquo,
  not,
  shy,
  reg,
  macr,
  deg,
  plusmn,
  sup2,
  sup3,
  acute,
  micro,
  para,
  middot,
  cedil,
  sup1,
  ordm,
  raquo,
  frac14,
  frac12,
  frac34,
  iquest,
  Agrave,
  Aacute,
  Acirc,
  Atilde,
  Auml,
  Aring,
  AElig,
  Ccedil,
  Egrave,
  Eacute,
  Ecirc,
  Euml,
  Igrave,
  Iacute,
  Icirc,
  Iuml,
  ETH,
  Ntilde,
  Ograve,
  Oacute,
  Ocirc,
  Otilde,
  Ouml,
  times,
  Oslash,
  Ugrave,
  Uacute,
  Ucirc,
  Uuml,
  Yacute,
  THORN,
  szlig,
  agrave,
  aacute,
  acirc,
  atilde,
  auml,
  aring,
  aelig,
  ccedil,
  egrave,
  eacute,
  ecirc,
  euml,
  igrave,
  iacute,
  icirc,
  iuml,
  eth,
  ntilde,
  ograve,
  oacute,
  ocirc,
  otilde,
  ouml,
  divide,
  oslash,
  ugrave,
  uacute,
  ucirc,
  uuml,
  yacute,
  thorn,
  yuml,
  fnof,
  Alpha,
  Beta,
  Gamma,
  Delta,
  Epsilon,
  Zeta,
  Eta,
  Theta,
  Iota,
  Kappa,
  Lambda,
  Mu: Mu2,
  Nu: Nu2,
  Xi: Xi2,
  Omicron,
  Pi: Pi2,
  Rho,
  Sigma,
  Tau,
  Upsilon,
  Phi,
  Chi,
  Psi,
  Omega,
  alpha,
  beta,
  gamma,
  delta,
  epsilon,
  zeta,
  eta,
  theta,
  iota,
  kappa,
  lambda,
  mu: mu2,
  nu: nu2,
  xi: xi2,
  omicron,
  pi: pi2,
  rho,
  sigmaf,
  sigma,
  tau,
  upsilon,
  phi,
  chi,
  psi,
  omega,
  thetasym,
  upsih,
  piv,
  bull,
  hellip,
  prime,
  Prime,
  oline,
  frasl,
  weierp,
  image,
  real,
  trade,
  alefsym,
  larr,
  uarr,
  rarr,
  darr,
  harr,
  crarr,
  lArr,
  uArr,
  rArr,
  dArr,
  hArr,
  forall,
  part,
  exist,
  empty: empty2,
  nabla,
  isin,
  notin,
  ni,
  prod,
  sum: sum2,
  minus,
  lowast,
  radic,
  prop,
  infin,
  ang,
  and,
  or: or2,
  cap,
  cup,
  int,
  there4,
  sim,
  cong,
  asymp,
  ne: ne2,
  equiv,
  le: le2,
  ge: ge2,
  sub,
  sup,
  nsub,
  sube,
  supe,
  oplus,
  otimes,
  perp,
  sdot,
  lceil,
  rceil,
  lfloor,
  rfloor,
  lang,
  rang,
  loz,
  spades,
  clubs,
  hearts,
  diams,
  quot,
  amp,
  lt: lt2,
  gt: gt2,
  OElig,
  oelig,
  Scaron,
  scaron,
  Yuml,
  circ,
  tilde,
  ensp,
  emsp,
  thinsp,
  zwnj,
  zwj,
  lrm,
  rlm,
  ndash,
  mdash,
  lsquo,
  rsquo,
  sbquo,
  ldquo,
  rdquo,
  bdquo,
  dagger,
  Dagger,
  permil,
  lsaquo,
  rsaquo,
  euro,
  "default": index
});
var dangerous$1 = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];
var dangerous$2 = Object.freeze({
  __proto__: null,
  "default": dangerous$1
});
var entities2 = getCjsExportFromNamespace2(characterEntitiesHtml4);
var dangerous = getCjsExportFromNamespace2(dangerous$2);
var decimal = isDecimal;
var stringifyEntities = encode;
encode.escape = escape;
var own$3 = {}.hasOwnProperty;
var escapes = ['"', "'", "<", ">", "&", "`"];
var characters = construct();
var defaultEscapes = toExpression(escapes);
var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var bmp = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
function encode(value, options2) {
  var settings = options2 || {};
  var subset2 = settings.subset;
  var set2 = subset2 ? toExpression(subset2) : defaultEscapes;
  var escapeOnly = settings.escapeOnly;
  var omit = settings.omitOptionalSemicolons;
  value = value.replace(set2, replace);
  if (subset2 || escapeOnly) {
    return value;
  }
  return value.replace(surrogatePair, replaceSurrogatePair).replace(bmp, replace);
  function replaceSurrogatePair(pair, pos, val) {
    return toHexReference(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      val.charAt(pos + 2),
      omit
    );
  }
  function replace(char, pos, val) {
    return one$1(char, val.charAt(pos + 1), settings);
  }
}
function escape(value) {
  return encode(value, { escapeOnly: true, useNamedReferences: true });
}
function one$1(char, next, options2) {
  var shortest = options2.useShortestReferences;
  var omit = options2.omitOptionalSemicolons;
  var named;
  var code2;
  var numeric;
  var decimal2;
  if ((shortest || options2.useNamedReferences) && own$3.call(characters, char)) {
    named = toNamed(characters[char], next, omit, options2.attribute);
  }
  if (shortest || !named) {
    code2 = char.charCodeAt(0);
    numeric = toHexReference(code2, next, omit);
    if (shortest) {
      decimal2 = toDecimalReference(code2, next, omit);
      if (decimal2.length < numeric.length) {
        numeric = decimal2;
      }
    }
  }
  if (named && (!shortest || named.length < numeric.length)) {
    return named;
  }
  return numeric;
}
function toNamed(name3, next, omit, attribute2) {
  var value = "&" + name3;
  if (omit && own$3.call(legacy, name3) && dangerous.indexOf(name3) === -1 && (!attribute2 || next && next !== "=" && !isAlphanumerical(next))) {
    return value;
  }
  return value + ";";
}
function toHexReference(code2, next, omit) {
  var value = "&#x" + code2.toString(16).toUpperCase();
  return omit && next && !isHexadecimal(next) ? value : value + ";";
}
function toDecimalReference(code2, next, omit) {
  var value = "&#" + String(code2);
  return omit && next && !decimal(next) ? value : value + ";";
}
function toExpression(characters2) {
  return new RegExp("[" + characters2.join("") + "]", "g");
}
function construct() {
  var chars2 = {};
  var name3;
  for (name3 in entities2) {
    chars2[entities2[name3]] = name3;
  }
  return chars2;
}
var NULL = "\0";
var AMP = "&";
var SP = " ";
var TB = "	";
var GR = "`";
var DQ$1 = '"';
var SQ$1 = "'";
var EQ = "=";
var LT = "<";
var GT = ">";
var SO = "/";
var LF = "\n";
var CR = "\r";
var FF = "\f";
var whitespace = [SP, TB, LF, CR, FF];
var name2 = whitespace.concat(AMP, SO, GT, EQ);
var unquoted$1 = whitespace.concat(AMP, GT);
var unquotedSafe = unquoted$1.concat(NULL, DQ$1, SQ$1, LT, EQ, GR);
var singleQuoted$1 = [AMP, SQ$1];
var doubleQuoted$1 = [AMP, DQ$1];
var constants = {
  name: [[name2, name2.concat(DQ$1, SQ$1, GR)], [name2.concat(NULL, DQ$1, SQ$1, LT), name2.concat(NULL, DQ$1, SQ$1, LT, GR)]],
  unquoted: [[unquoted$1, unquotedSafe], [unquotedSafe, unquotedSafe]],
  single: [
    [singleQuoted$1, singleQuoted$1.concat(DQ$1, GR)],
    [singleQuoted$1.concat(NULL), singleQuoted$1.concat(NULL, DQ$1, GR)]
  ],
  double: [
    [doubleQuoted$1, doubleQuoted$1.concat(SQ$1, GR)],
    [doubleQuoted$1.concat(NULL), doubleQuoted$1.concat(NULL, SQ$1, GR)]
  ]
};
var spaces = spaceSeparatedTokens.stringify;
var commas = commaSeparatedTokens.stringify;
var element_1 = element;
var emptyString = "";
var space$1 = " ";
var quotationMark = '"';
var apostrophe$1 = "'";
var equalsTo = "=";
var lessThan$1 = "<";
var greaterThan = ">";
var slash$1 = "/";
var newLine = "\n";
function element(ctx, node2, index2, parent, printWidthOffset, innerTextLength) {
  var parentSchema = ctx.schema;
  var name3 = node2.tagName;
  var value = "";
  var selfClosing;
  var close;
  var omit;
  var root2 = node2;
  var content;
  var attrs2;
  var indentLevel = getNodeData(node2, "indentLevel", 0);
  var printContext = {
    offset: printWidthOffset,
    wrapAttributes: false,
    indentLevel
  };
  var isVoid = ctx.voids.indexOf(name3) !== -1;
  var ignoreAttrCollapsing = getNodeData(node2, "ignore", false) || getNodeData(node2, "preserveAttrWrapping", false);
  if (parentSchema.space === "html" && name3 === "svg") {
    ctx.schema = svg_1;
  }
  if (ctx.schema.space === "svg") {
    omit = false;
    close = true;
    selfClosing = ctx.closeEmpty;
  } else {
    omit = ctx.omit;
    close = ctx.close;
    selfClosing = isVoid;
  }
  if (selfClosing === false) {
    selfClosing = getNodeData(node2, "selfClosing", false);
  }
  printContext.offset += lessThan$1.length;
  printContext.offset += node2.tagName.length;
  if (selfClosing && !isVoid) {
    printContext.offset += slash$1.length;
  }
  printContext.offset += greaterThan.length;
  const propertyCount = Object.keys(node2.properties).length;
  if (propertyCount > 1 && ctx.wrapAttributes) {
    printContext.wrapAttributes = true;
  }
  if (propertyCount) {
    printContext.offset += propertyCount * space$1.length;
  }
  printContext.offset += innerTextLength;
  attrs2 = attributes(ctx, node2.properties, printContext, ignoreAttrCollapsing);
  const shouldCollapse = ignoreAttrCollapsing === false && printContext.wrapAttributes;
  content = all_1(ctx, root2);
  selfClosing = content ? false : selfClosing;
  if (attrs2 || !omit || !omit.opening(node2, index2, parent)) {
    value = lessThan$1 + name3;
    if (attrs2) {
      if (shouldCollapse) {
        value += attrs2;
      } else {
        value += space$1 + attrs2;
      }
    }
    let selfClosed = false;
    if (selfClosing && close) {
      if ((!ctx.tightClose || attrs2.charAt(attrs2.length - 1) === slash$1) && !shouldCollapse) {
        value += space$1;
      }
      if (shouldCollapse) {
        value += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
      }
      selfClosed = true;
      value += slash$1;
    } else if (selfClosing && !isVoid) {
      if (shouldCollapse) {
        value += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
      }
      selfClosed = true;
      value += slash$1;
    }
    if (shouldCollapse && !selfClosed) {
      value += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
    }
    value += greaterThan;
  }
  value += content;
  if (!selfClosing && (!omit || !omit.closing(node2, index2, parent))) {
    value += lessThan$1 + slash$1 + name3 + greaterThan;
  }
  ctx.schema = parentSchema;
  return value;
}
function attributes(ctx, props, printContext, ignoreIndent) {
  var values2 = [];
  var key;
  var value;
  var result;
  var length;
  var index2;
  var last;
  for (key in props) {
    value = props[key];
    if (value == null) {
      continue;
    }
    result = attribute$1(ctx, key, value);
    printContext.offset += result.length;
    if (ignoreIndent === false && printContext.offset > ctx.printWidth) {
      printContext.wrapAttributes = true;
    }
    if (result) {
      values2.push(result);
    }
  }
  length = values2.length;
  index2 = -1;
  while (++index2 < length) {
    result = values2[index2];
    last = null;
    if (last !== quotationMark && last !== apostrophe$1) {
      if (printContext.wrapAttributes) {
        values2[index2] = newLine + repeatString(ctx.tabWidth, printContext.indentLevel + 1) + result;
      } else if (index2 !== length - 1) {
        values2[index2] = result + space$1;
      } else {
        values2[index2] = result;
      }
    }
  }
  return values2.join(emptyString);
}
function attribute$1(ctx, key, value) {
  var schema2 = ctx.schema;
  var info2 = find_1(schema2, key);
  var name3 = info2.attribute;
  if (value == null || typeof value === "number" && isNaN(value) || value === false && info2.boolean) {
    return emptyString;
  }
  name3 = attributeName$1(ctx, name3);
  if (value === true && info2.boolean || value === true && info2.overloadedBoolean) {
    return name3;
  }
  return name3 + attributeValue$1(ctx, key, value, info2);
}
function attributeName$1(ctx, name3) {
  var valid2 = ctx.schema.space === "html" ? ctx.valid : 1;
  var subset2 = constants.name[valid2][ctx.safe];
  return stringifyEntities(name3, immutable(ctx.entities, { subset: subset2 }));
}
function attributeValue$1(ctx, key, value, info2) {
  var quote2 = ctx.quote;
  if (typeof value === "object" && "length" in value) {
    value = (info2.commaSeparated ? commas : spaces)(value, {
      padLeft: !ctx.tightLists
    });
  }
  value = String(value);
  if (value === "") {
    return value;
  } else {
    value = equalsTo + quote2 + value + quote2;
  }
  return value;
}
function getNodeData(node2, key, defaultValue) {
  let data3 = node2.data || {};
  return data3[key] || defaultValue;
}
var doctype_1 = doctype;
function doctype(ctx, node2) {
  var sep2 = ctx.tightDoctype ? "" : " ";
  var name3 = node2.name;
  var pub = node2.public;
  var sys = node2.system;
  var val = ["<!doctype"];
  if (name3) {
    val.push(sep2, name3);
    if (pub != null) {
      val.push(" public", sep2, smart(pub));
    } else if (sys != null) {
      val.push(" system");
    }
    if (sys != null) {
      val.push(sep2, smart(sys));
    }
  }
  return val.join("") + ">";
}
function smart(value) {
  var quote2 = value.indexOf('"') === -1 ? '"' : "'";
  return quote2 + value + quote2;
}
var comment_1 = comment;
function comment(ctx, node2) {
  return "<!--" + node2.value + "-->";
}
var raw_1 = raw;
function raw(ctx, node2) {
  return node2.value;
}
var one_1 = one;
var own$2 = {}.hasOwnProperty;
var handlers2 = {};
handlers2.root = all_1;
handlers2.text = text_1;
handlers2.element = element_1;
handlers2.doctype = doctype_1;
handlers2.comment = comment_1;
handlers2.raw = raw_1;
function one(ctx, node2, index2, parent, printWidthOffset, innerTextLength) {
  var type2 = node2 && node2.type;
  if (!type2) {
    throw new Error("Expected node, not `" + node2 + "`");
  }
  if (!own$2.call(handlers2, type2)) {
    throw new Error("Cannot compile unknown node `" + type2 + "`");
  }
  return handlers2[type2](ctx, node2, index2, parent, printWidthOffset, innerTextLength);
}
var voids = getCjsExportFromNamespace2(htmlVoidElements);
var lib$12 = toHTML;
var DQ = '"';
var SQ = "'";
function toHTML(node2, options2) {
  var settings = options2 || {};
  var quote2 = settings.singleQuote ? SQ : DQ;
  var printWidth = settings.printWidth === void 0 ? 80 : settings.printWidth;
  var useTabs = settings.useTabs;
  var tabWidth = settings.tabWidth || 2;
  var wrapAttributes = settings.wrapAttributes;
  if (useTabs) {
    tabWidth = "	";
  } else if (typeof tabWidth === "number") {
    tabWidth = repeatString(" ", tabWidth);
  }
  return one_1(
    {
      valid: settings.allowParseErrors ? 0 : 1,
      safe: settings.allowDangerousCharacters ? 0 : 1,
      schema: settings.space === "svg" ? svg_1 : html_1,
      omit: settings.omitOptionalTags && omission,
      quote: quote2,
      printWidth,
      tabWidth,
      wrapAttributes,
      tightDoctype: Boolean(settings.tightDoctype),
      tightLists: settings.tightCommaSeparatedLists,
      voids: settings.voids || voids.concat(),
      entities: settings.entities || {},
      close: settings.closeSelfClosing,
      tightClose: settings.tightSelfClosing,
      closeEmpty: settings.closeEmptyElements
    },
    node2
  );
}
var prettyhtmlHastToHtml = lib$12;
var void_els = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var RE_SVELTE_TAG = /^<svelte:([a-z]*)[\s\S]*(?:(?:svelte:[a-z]*)|(?:\/))>$/;
var RE_SVELTE_TAG_START = /(^\s*)<([\\/\s])*svelte:/;
function parse_svelte_tag(eat2, value, silent) {
  const is_svelte_tag = RE_SVELTE_TAG_START.exec(value);
  if (is_svelte_tag) {
    if (silent)
      return true;
    const trimmed_value = value.trim();
    let cbPos = 0;
    let pos = 1;
    let current_tag = "";
    let in_tag_name = false;
    while (cbPos > -1) {
      if (!trimmed_value[pos]) {
        break;
      }
      if (trimmed_value[pos].match(/</)) {
        cbPos++;
        current_tag = "";
        in_tag_name = true;
      }
      if (in_tag_name && trimmed_value[pos].match(/\s/)) {
        in_tag_name = false;
      }
      if (in_tag_name && !trimmed_value[pos].match(/</)) {
        current_tag += trimmed_value[pos];
      }
      const is_void2 = void_els.includes(current_tag);
      if (is_void2 && trimmed_value[pos].match(/>/) || (trimmed_value[pos - 1] + trimmed_value[pos]).match(/\/>/)) {
        cbPos--;
      }
      if ((trimmed_value[pos - 1] + trimmed_value[pos]).match(/<\//)) {
        let inner_indent = 0;
        while (inner_indent > -1) {
          if (trimmed_value[pos].match(/>/)) {
            pos++;
            inner_indent -= 1;
            cbPos -= 2;
          } else {
            pos++;
          }
        }
      }
      pos++;
    }
    const match = RE_SVELTE_TAG.exec(trimmed_value.substring(0, pos).trim());
    if (!match)
      return;
    return eat2(is_svelte_tag[1] + match[0])({
      type: "svelteTag",
      value: match[0],
      name: match[1]
    });
  }
}
var RE_SVELTE_BLOCK_START = /(^\s*){[#:/@]/;
var RE_SVELTE_BLOCK = /^{[#:/@](else if|[a-z]+).*}$/;
function parse_svelte_block(eat2, value, silent) {
  const is_svelte_block = RE_SVELTE_BLOCK_START.exec(value);
  if (is_svelte_block) {
    if (silent)
      return true;
    const trimmed_value = value.trim();
    let cbPos = 0;
    let pos = 1;
    while (cbPos > -1) {
      if (trimmed_value[pos].match(/{/))
        cbPos++;
      if (trimmed_value[pos].match(/}/))
        cbPos--;
      pos++;
    }
    const match = RE_SVELTE_BLOCK.exec(trimmed_value.substring(0, pos));
    if (!match)
      return;
    return eat2(is_svelte_block[1] + match[0])({
      type: "svelteBlock",
      value: `${is_svelte_block[1]}${match[0]}`,
      name: match[1]
    });
  }
}
var dotAllPolyfill = "[\0-￿]";
var attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
var singleQuoted = "'[^']*'";
var doubleQuoted = '"[^"]*"';
var jsProps = "{.*}".replace(".", dotAllPolyfill);
var attributeValue = "(?:" + unquoted + "|" + singleQuoted + "|" + doubleQuoted + "|" + jsProps + ")";
var attribute = "(?:\\s+" + attributeName + "(?:\\s*=\\s*" + attributeValue + ")?)";
var openTag = "<[A-Za-z]*[A-Za-z0-9\\.\\-]*" + attribute + "*\\s*\\/?>";
var closeTag = "<\\/[A-Za-z][A-Za-z0-9\\.\\-]*\\s*>";
"<[?].*?[?]>".replace(".", dotAllPolyfill);
var openCloseTag = new RegExp("^(?:" + openTag + "|" + closeTag + ")");
var tab = "	";
var space = " ";
var lineFeed = "\n";
var lessThan = "<";
var rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
var rawCloseExpression = /<\/(script|pre|style)>/i;
var commentOpenExpression = /^<!--/;
var commentCloseExpression = /-->/;
var instructionOpenExpression = /^<\?/;
var instructionCloseExpression = /\?>/;
var directiveOpenExpression = /^<![A-Za-z]/;
var directiveCloseExpression = />/;
var cdataOpenExpression = /^<!\[CDATA\[/;
var cdataCloseExpression = /\]\]>/;
var elementCloseExpression = /^$/;
var otherElementOpenExpression = new RegExp(openCloseTag.source + "\\s*$");
var fragmentOpenExpression = /^<>/;
function blockHtml(eat2, value, silent) {
  const blocks = "[a-z\\.]*(\\.){0,1}[a-z][a-z0-9\\.]*";
  const elementOpenExpression = new RegExp(
    "^</?(" + blocks + ")(?=(\\s|/?>|$))",
    "i"
  );
  const length = value.length;
  let index2 = 0;
  let next;
  let line2;
  let offset2;
  let character;
  let sequence;
  const sequences = [
    [rawOpenExpression, rawCloseExpression, true],
    [commentOpenExpression, commentCloseExpression, true],
    [instructionOpenExpression, instructionCloseExpression, true],
    [directiveOpenExpression, directiveCloseExpression, true],
    [cdataOpenExpression, cdataCloseExpression, true],
    [elementOpenExpression, elementCloseExpression, true],
    [fragmentOpenExpression, elementCloseExpression, true],
    [otherElementOpenExpression, elementCloseExpression, false]
  ];
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== tab && character !== space) {
      break;
    }
    index2++;
  }
  if (value.charAt(index2) !== lessThan) {
    return;
  }
  next = value.indexOf(lineFeed, index2 + 1);
  next = next === -1 ? length : next;
  line2 = value.slice(index2, next);
  offset2 = -1;
  const count = sequences.length;
  while (++offset2 < count) {
    if (sequences[offset2][0].test(line2)) {
      sequence = sequences[offset2];
      break;
    }
  }
  if (!sequence) {
    return;
  }
  if (silent) {
    return sequence[2];
  }
  index2 = next;
  if (!sequence[1].test(line2)) {
    while (index2 < length) {
      next = value.indexOf(lineFeed, index2 + 1);
      next = next === -1 ? length : next;
      line2 = value.slice(index2 + 1, next);
      if (sequence[1].test(line2)) {
        if (line2) {
          index2 = next;
        }
        break;
      }
      index2 = next;
    }
  }
  const subvalue = value.slice(0, index2);
  return eat2(subvalue)({ type: "html", value: subvalue });
}
function mdsvex_parser() {
  const Parser4 = this.Parser;
  const block_tokenizers = Parser4.prototype.blockTokenizers;
  const methods = Parser4.prototype.blockMethods;
  block_tokenizers.svelteBlock = parse_svelte_block;
  block_tokenizers.svelteTag = parse_svelte_tag;
  block_tokenizers.html = blockHtml;
  block_tokenizers.indentedCode = indentedCode;
  methods.splice(methods.indexOf("html"), 0, "svelteBlock");
  methods.splice(methods.indexOf("html"), 0, "svelteTag");
}
function indentedCode() {
  return true;
}
var unified_1 = unified().freeze();
var slice2 = [].slice;
var own$1 = {}.hasOwnProperty;
var pipeline = trough_1().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
function pipelineParse(p2, ctx) {
  ctx.tree = p2.parse(ctx.file);
}
function pipelineRun(p2, ctx, next) {
  p2.run(ctx.tree, ctx.file, done);
  function done(err, tree, file) {
    if (err) {
      next(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}
function pipelineStringify(p2, ctx) {
  ctx.file.contents = p2.stringify(ctx.tree, ctx.file);
}
function unified() {
  var attachers = [];
  var transformers = trough_1();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;
  processor.data = data3;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse5;
  processor.stringify = stringify2;
  processor.run = run2;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = unified();
    var length = attachers.length;
    var index2 = -1;
    while (++index2 < length) {
      destination.use.apply(null, attachers[index2]);
    }
    destination.data(extend$2(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values2;
    var plugin;
    var options2;
    var transformer;
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      values2 = attachers[freezeIndex];
      plugin = values2[0];
      options2 = values2[1];
      transformer = null;
      if (options2 === false) {
        continue;
      }
      if (options2 === true) {
        values2[1] = void 0;
      }
      transformer = plugin.apply(processor, values2.slice(1));
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data3(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return own$1.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function use(value) {
    var settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function") {
      addPlugin.apply(null, arguments);
    } else if (typeof value === "object") {
      if ("length" in value) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new Error("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = extend$2(namespace.settings || {}, settings);
    }
    return processor;
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = extend$2(settings || {}, result.settings);
      }
    }
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if ("length" in value2) {
          addPlugin.apply(null, value2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new Error("Expected usable value, not `" + value2 + "`");
      }
    }
    function addList(plugins) {
      var length;
      var index2;
      if (plugins === null || plugins === void 0)
        ;
      else if (typeof plugins === "object" && "length" in plugins) {
        length = plugins.length;
        index2 = -1;
        while (++index2 < length) {
          add(plugins[index2]);
        }
      } else {
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      var entry = find2(plugin);
      if (entry) {
        if (isPlainObj(entry[1]) && isPlainObj(value2)) {
          value2 = extend$2(entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push(slice2.call(arguments));
      }
    }
  }
  function find2(plugin) {
    var length = attachers.length;
    var index2 = -1;
    var entry;
    while (++index2 < length) {
      entry = attachers[index2];
      if (entry[0] === plugin) {
        return entry;
      }
    }
  }
  function parse5(doc) {
    var file = vfile(doc);
    var Parser4;
    freeze();
    Parser4 = processor.Parser;
    assertParser("parse", Parser4);
    if (newable(Parser4, "parse")) {
      return new Parser4(String(file), file).parse();
    }
    return Parser4(String(file), file);
  }
  function run2(node2, file, cb) {
    assertNode(node2);
    freeze();
    if (!cb && typeof file === "function") {
      cb = file;
      file = null;
    }
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(file), done);
      function done(err, tree, file2) {
        tree = tree || node2;
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file2);
        }
      }
    }
  }
  function runSync(node2, file) {
    var complete = false;
    var result;
    run2(node2, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(err, tree) {
      complete = true;
      bail_1(err);
      result = tree;
    }
  }
  function stringify2(node2, doc) {
    var file = vfile(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node2);
    if (newable(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function process2(doc, cb) {
    freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      var file = vfile(doc);
      pipeline.run(processor, { file }, done);
      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }
  function processSync(doc) {
    var complete = false;
    var file;
    freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    file = vfile(doc);
    process2(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(err) {
      complete = true;
      bail_1(err);
    }
  }
}
function newable(value, name3) {
  return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  (keys2(value.prototype) || name3 in value.prototype);
}
function keys2(value) {
  var key;
  for (key in value) {
    return true;
  }
  return false;
}
function assertParser(name3, Parser4) {
  if (typeof Parser4 !== "function") {
    throw new Error("Cannot `" + name3 + "` without `Parser`");
  }
}
function assertCompiler(name3, Compiler) {
  if (typeof Compiler !== "function") {
    throw new Error("Cannot `" + name3 + "` without `Compiler`");
  }
}
function assertUnfrozen(name3, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot invoke `" + name3 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!node2 || typeof node2.type !== "string") {
    throw new Error("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name3, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name3 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
var nlcstToString_1 = nlcstToString;
function nlcstToString(node2, separator) {
  var sep2 = separator || "";
  var values2;
  var length;
  var children;
  if (!node2 || !("length" in node2) && !node2.type) {
    throw new Error("Expected node, not `" + node2 + "`");
  }
  if (typeof node2.value === "string") {
    return node2.value;
  }
  children = "length" in node2 ? node2 : node2.children;
  length = children.length;
  if (length === 1 && "value" in children[0]) {
    return children[0].value;
  }
  values2 = [];
  while (length--) {
    values2[length] = nlcstToString(children[length], sep2);
  }
  return values2.join(sep2);
}
var tokenizer2 = tokenizerFactory;
function tokenizerFactory(childType, expression) {
  return tokenizer3;
  function tokenizer3(node2) {
    var children = [];
    var tokens = node2.children;
    var type2 = node2.type;
    var length = tokens.length;
    var index2 = -1;
    var lastIndex = length - 1;
    var start2 = 0;
    var first2;
    var last;
    var parent;
    while (++index2 < length) {
      if (index2 === lastIndex || tokens[index2].type === childType && expression.test(nlcstToString_1(tokens[index2]))) {
        first2 = tokens[start2];
        last = tokens[index2];
        parent = {
          type: type2,
          children: tokens.slice(start2, index2 + 1)
        };
        if (first2.position && last.position) {
          parent.position = {
            start: first2.position.start,
            end: last.position.end
          };
        }
        children.push(parent);
        start2 = index2 + 1;
      }
    }
    return children;
  }
}
var parser = parserFactory;
function parserFactory(options2) {
  var type2 = options2.type;
  var tokenizerProperty = options2.tokenizer;
  var delimiter = options2.delimiter;
  var tokenize2 = delimiter && tokenizer2(options2.delimiterType, delimiter);
  return parser2;
  function parser2(value) {
    var children = this[tokenizerProperty](value);
    return {
      type: type2,
      children: tokenize2 ? tokenize2(children) : children
    };
  }
}
var expressions = {
  affixSymbol: /^([\)\]\}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63]|["'\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21]|[!\.\?\u2026\u203D])\1*$/,
  newLine: /^[ \t]*((\r?\n|\r)[\t ]*)+$/,
  newLineMulti: /^[ \t]*((\r?\n|\r)[\t ]*){2,}$/,
  terminalMarker: /^((?:[!\.\?\u2026\u203D])+)$/,
  wordSymbolInner: /^((?:[&'\x2D\.:=\?@\xAD\xB7\u2010\u2011\u2019\u2027])|(?:_)+)$/,
  numerical: /^(?:[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C])+$/,
  digitStart: /^\d/,
  lowerInitial: /^(?:[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C3\uA7FA\uAB30-\uAB5A\uAB60-\uAB67\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/,
  surrogates: /[\uD800-\uDFFF]/,
  punctuation: /[!"'-\),-\/:;\?\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u201F\u2022-\u2027\u2032-\u203A\u203C-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,
  word: /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09F4-\u09F9\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BF2\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7E\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D63\u0D66-\u0D78\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u17F0-\u17F9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABE\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u20D0-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BA\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA672\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA830-\uA835\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE6\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD27\uDD30-\uDD39\uDE60-\uDE7E\uDF00-\uDF27\uDF30-\uDF54\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC52-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3B]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCF2\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
  whiteSpace: /[\t-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
};
var arrayIterate = iterate;
var own = {}.hasOwnProperty;
function iterate(values2, callback, context2) {
  var index2 = -1;
  var result;
  if (!values2) {
    throw new Error("Iterate requires that |this| not be " + values2);
  }
  if (!own.call(values2, "length")) {
    throw new Error("Iterate requires that |this| has a `length`");
  }
  if (typeof callback !== "function") {
    throw new Error("`callback` must be a function");
  }
  while (++index2 < values2.length) {
    if (!(index2 in values2)) {
      continue;
    }
    result = callback.call(context2, values2[index2], index2, values2);
    if (typeof result === "number") {
      if (result < 0) {
        index2 = 0;
      }
      index2 = result - 1;
    }
  }
}
var unistUtilModifyChildren = modifierFactory;
function modifierFactory(callback) {
  return iteratorFactory(wrapperFactory(callback));
}
function iteratorFactory(callback) {
  return iterator;
  function iterator(parent) {
    var children = parent && parent.children;
    if (!children) {
      throw new Error("Missing children in `parent` for `modifier`");
    }
    return arrayIterate(children, callback, parent);
  }
}
function wrapperFactory(callback) {
  return wrapper;
  function wrapper(value, index2) {
    return callback(value, index2, this);
  }
}
var mergeInitialWordSymbol_1 = unistUtilModifyChildren(mergeInitialWordSymbol);
function mergeInitialWordSymbol(child, index2, parent) {
  var children;
  var next;
  if (child.type !== "SymbolNode" && child.type !== "PunctuationNode" || nlcstToString_1(child) !== "&") {
    return;
  }
  children = parent.children;
  next = children[index2 + 1];
  if (index2 !== 0 && children[index2 - 1].type === "WordNode" || !(next && next.type === "WordNode")) {
    return;
  }
  children.splice(index2, 1);
  next.children.unshift(child);
  if (next.position && child.position) {
    next.position.start = child.position.start;
  }
  return index2 - 1;
}
var mergeFinalWordSymbol_1 = unistUtilModifyChildren(mergeFinalWordSymbol$1);
function mergeFinalWordSymbol$1(child, index2, parent) {
  var children;
  var prev;
  var next;
  if (index2 !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode") && nlcstToString_1(child) === "-") {
    children = parent.children;
    prev = children[index2 - 1];
    next = children[index2 + 1];
    if ((!next || next.type !== "WordNode") && prev && prev.type === "WordNode") {
      children.splice(index2, 1);
      prev.children.push(child);
      if (prev.position && child.position) {
        prev.position.end = child.position.end;
      }
      return index2;
    }
  }
}
var mergeInnerWordSymbol_1 = unistUtilModifyChildren(mergeInnerWordSymbol);
var wordSymbolInner = expressions.wordSymbolInner;
function mergeInnerWordSymbol(child, index2, parent) {
  var siblings2;
  var sibling;
  var prev;
  var last;
  var position2;
  var tokens;
  var queue;
  if (index2 !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode")) {
    siblings2 = parent.children;
    prev = siblings2[index2 - 1];
    if (prev && prev.type === "WordNode") {
      position2 = index2 - 1;
      tokens = [];
      queue = [];
      while (siblings2[++position2]) {
        sibling = siblings2[position2];
        if (sibling.type === "WordNode") {
          tokens = tokens.concat(queue, sibling.children);
          queue = [];
        } else if ((sibling.type === "SymbolNode" || sibling.type === "PunctuationNode") && wordSymbolInner.test(nlcstToString_1(sibling))) {
          queue.push(sibling);
        } else {
          break;
        }
      }
      if (tokens.length !== 0) {
        if (queue.length !== 0) {
          position2 -= queue.length;
        }
        siblings2.splice(index2, position2 - index2);
        prev.children = prev.children.concat(tokens);
        last = tokens[tokens.length - 1];
        if (prev.position && last.position) {
          prev.position.end = last.position.end;
        }
        return index2;
      }
    }
  }
}
var mergeInnerWordSlash_1 = unistUtilModifyChildren(mergeInnerWordSlash);
var slash = "/";
function mergeInnerWordSlash(child, index2, parent) {
  var siblings2 = parent.children;
  var prev;
  var next;
  var prevValue;
  var nextValue;
  var queue;
  var tail;
  var count;
  prev = siblings2[index2 - 1];
  next = siblings2[index2 + 1];
  if (prev && prev.type === "WordNode" && (child.type === "SymbolNode" || child.type === "PunctuationNode") && nlcstToString_1(child) === slash) {
    prevValue = nlcstToString_1(prev);
    tail = child;
    queue = [child];
    count = 1;
    if (next && next.type === "WordNode") {
      nextValue = nlcstToString_1(next);
      tail = next;
      queue = queue.concat(next.children);
      count++;
    }
    if (prevValue.length < 3 && (!nextValue || nextValue.length < 3)) {
      prev.children = prev.children.concat(queue);
      siblings2.splice(index2, count);
      if (prev.position && tail.position) {
        prev.position.end = tail.position.end;
      }
      return index2;
    }
  }
}
var mergeInitialisms_1 = unistUtilModifyChildren(mergeInitialisms);
var numerical = expressions.numerical;
function mergeInitialisms(child, index2, parent) {
  var siblings2;
  var prev;
  var children;
  var length;
  var position2;
  var otherChild;
  var isAllDigits;
  var value;
  if (index2 !== 0 && nlcstToString_1(child) === ".") {
    siblings2 = parent.children;
    prev = siblings2[index2 - 1];
    children = prev.children;
    length = children && children.length;
    if (prev.type === "WordNode" && length !== 1 && length % 2 !== 0) {
      position2 = length;
      isAllDigits = true;
      while (children[--position2]) {
        otherChild = children[position2];
        value = nlcstToString_1(otherChild);
        if (position2 % 2 === 0) {
          if (value.length > 1) {
            return;
          }
          if (!numerical.test(value)) {
            isAllDigits = false;
          }
        } else if (value !== ".") {
          if (position2 < length - 2) {
            break;
          } else {
            return;
          }
        }
      }
      if (!isAllDigits) {
        siblings2.splice(index2, 1);
        children.push(child);
        if (prev.position && child.position) {
          prev.position.end = child.position.end;
        }
        return index2;
      }
    }
  }
}
var mergeWords = unistUtilModifyChildren(mergeFinalWordSymbol);
function mergeFinalWordSymbol(child, index2, parent) {
  var siblings2 = parent.children;
  var next;
  if (child.type === "WordNode") {
    next = siblings2[index2 + 1];
    if (next && next.type === "WordNode") {
      siblings2.splice(index2 + 1, 1);
      child.children = child.children.concat(next.children);
      if (next.position && child.position) {
        child.position.end = next.position.end;
      }
      return index2;
    }
  }
}
var unistUtilVisitChildren = visitChildren;
function visitChildren(callback) {
  return visitor;
  function visitor(parent) {
    var index2 = -1;
    var children = parent && parent.children;
    if (!children) {
      throw new Error("Missing children in `parent` for `visitor`");
    }
    while (++index2 in children) {
      callback(children[index2], index2, parent);
    }
  }
}
var patchPosition_1 = unistUtilVisitChildren(patchPosition);
function patchPosition(child, index2, node2) {
  var siblings2 = node2.children;
  if (!child.position) {
    return;
  }
  if (index2 === 0 && (!node2.position || /* istanbul ignore next */
  !node2.position.start)) {
    patch(node2);
    node2.position.start = child.position.start;
  }
  if (index2 === siblings2.length - 1 && (!node2.position || !node2.position.end)) {
    patch(node2);
    node2.position.end = child.position.end;
  }
}
function patch(node2) {
  if (!node2.position) {
    node2.position = {};
  }
}
var mergeNonWordSentences_1 = unistUtilModifyChildren(mergeNonWordSentences);
function mergeNonWordSentences(child, index2, parent) {
  var children = child.children;
  var position2 = -1;
  var prev;
  var next;
  while (children[++position2]) {
    if (children[position2].type === "WordNode") {
      return;
    }
  }
  prev = parent.children[index2 - 1];
  if (prev) {
    prev.children = prev.children.concat(children);
    parent.children.splice(index2, 1);
    if (prev.position && child.position) {
      prev.position.end = child.position.end;
    }
    return index2;
  }
  next = parent.children[index2 + 1];
  if (next) {
    next.children = children.concat(next.children);
    if (next.position && child.position) {
      next.position.start = child.position.start;
    }
    parent.children.splice(index2, 1);
  }
}
var mergeAffixSymbol_1 = unistUtilModifyChildren(mergeAffixSymbol);
var affixSymbol = expressions.affixSymbol;
function mergeAffixSymbol(child, index2, parent) {
  var children = child.children;
  var first2;
  var second;
  var prev;
  if (children && children.length !== 0 && index2 !== 0) {
    first2 = children[0];
    second = children[1];
    prev = parent.children[index2 - 1];
    if ((first2.type === "SymbolNode" || first2.type === "PunctuationNode") && affixSymbol.test(nlcstToString_1(first2))) {
      prev.children.push(children.shift());
      if (first2.position && prev.position) {
        prev.position.end = first2.position.end;
      }
      if (second && second.position && child.position) {
        child.position.start = second.position.start;
      }
      return index2 - 1;
    }
  }
}
var mergeInitialLowerCaseLetterSentences_1 = unistUtilModifyChildren(mergeInitialLowerCaseLetterSentences);
var lowerInitial = expressions.lowerInitial;
function mergeInitialLowerCaseLetterSentences(child, index2, parent) {
  var children = child.children;
  var position2;
  var node2;
  var siblings2;
  var prev;
  if (children && children.length !== 0 && index2 !== 0) {
    position2 = -1;
    while (children[++position2]) {
      node2 = children[position2];
      if (node2.type === "WordNode") {
        if (!lowerInitial.test(nlcstToString_1(node2))) {
          return;
        }
        siblings2 = parent.children;
        prev = siblings2[index2 - 1];
        prev.children = prev.children.concat(children);
        siblings2.splice(index2, 1);
        if (prev.position && child.position) {
          prev.position.end = child.position.end;
        }
        return index2;
      }
      if (node2.type === "SymbolNode" || node2.type === "PunctuationNode") {
        return;
      }
    }
  }
}
var mergeInitialDigitSentences_1 = unistUtilModifyChildren(mergeInitialDigitSentences);
var digit = expressions.digitStart;
function mergeInitialDigitSentences(child, index2, parent) {
  var children = child.children;
  var siblings2 = parent.children;
  var prev = siblings2[index2 - 1];
  var head2 = children[0];
  if (prev && head2 && head2.type === "WordNode" && digit.test(nlcstToString_1(head2))) {
    prev.children = prev.children.concat(children);
    siblings2.splice(index2, 1);
    if (prev.position && child.position) {
      prev.position.end = child.position.end;
    }
    return index2;
  }
}
var mergePrefixExceptions_1 = unistUtilModifyChildren(mergePrefixExceptions);
var abbreviationPrefix = new RegExp(
  "^([0-9]{1,3}|[a-z]|al|ca|cap|cca|cent|cf|cit|con|cp|cwt|ead|etc|ff|fl|ibid|id|nem|op|pro|seq|sic|stat|tem|viz)$"
);
function mergePrefixExceptions(child, index2, parent) {
  var children = child.children;
  var period2;
  var node2;
  var next;
  if (children && children.length > 1) {
    period2 = children[children.length - 1];
    if (period2 && nlcstToString_1(period2) === ".") {
      node2 = children[children.length - 2];
      if (node2 && node2.type === "WordNode" && abbreviationPrefix.test(nlcstToString_1(node2).toLowerCase())) {
        node2.children.push(period2);
        children.pop();
        if (period2.position && node2.position) {
          node2.position.end = period2.position.end;
        }
        next = parent.children[index2 + 1];
        if (next) {
          child.children = children.concat(next.children);
          parent.children.splice(index2 + 1, 1);
          if (next.position && child.position) {
            child.position.end = next.position.end;
          }
          return index2 - 1;
        }
      }
    }
  }
}
var mergeAffixExceptions_1 = unistUtilModifyChildren(mergeAffixExceptions);
function mergeAffixExceptions(child, index2, parent) {
  var children = child.children;
  var node2;
  var position2;
  var value;
  var previousChild;
  if (!children || children.length === 0 || index2 === 0) {
    return;
  }
  position2 = -1;
  while (children[++position2]) {
    node2 = children[position2];
    if (node2.type === "WordNode") {
      return;
    }
    if (node2.type === "SymbolNode" || node2.type === "PunctuationNode") {
      value = nlcstToString_1(node2);
      if (value !== "," && value !== ";") {
        return;
      }
      previousChild = parent.children[index2 - 1];
      previousChild.children = previousChild.children.concat(children);
      if (previousChild.position && child.position) {
        previousChild.position.end = child.position.end;
      }
      parent.children.splice(index2, 1);
      return index2;
    }
  }
}
var mergeRemainingFullStops_1 = unistUtilVisitChildren(mergeRemainingFullStops);
var terminalMarker = expressions.terminalMarker;
function mergeRemainingFullStops(child) {
  var children = child.children;
  var position2 = children.length;
  var hasFoundDelimiter = false;
  var grandchild;
  var prev;
  var next;
  var nextNext;
  while (children[--position2]) {
    grandchild = children[position2];
    if (grandchild.type !== "SymbolNode" && grandchild.type !== "PunctuationNode") {
      if (grandchild.type === "WordNode") {
        hasFoundDelimiter = true;
      }
      continue;
    }
    if (!terminalMarker.test(nlcstToString_1(grandchild))) {
      continue;
    }
    if (!hasFoundDelimiter) {
      hasFoundDelimiter = true;
      continue;
    }
    if (nlcstToString_1(grandchild) !== ".") {
      continue;
    }
    prev = children[position2 - 1];
    next = children[position2 + 1];
    if (prev && prev.type === "WordNode") {
      nextNext = children[position2 + 2];
      if (next && nextNext && next.type === "WhiteSpaceNode" && nlcstToString_1(nextNext) === ".") {
        continue;
      }
      children.splice(position2, 1);
      prev.children.push(grandchild);
      if (grandchild.position && prev.position) {
        prev.position.end = grandchild.position.end;
      }
      position2--;
    } else if (next && next.type === "WordNode") {
      children.splice(position2, 1);
      next.children.unshift(grandchild);
      if (grandchild.position && next.position) {
        next.position.start = grandchild.position.start;
      }
    }
  }
}
var makeInitialWhiteSpaceSiblings_1 = unistUtilVisitChildren(makeInitialWhiteSpaceSiblings);
function makeInitialWhiteSpaceSiblings(child, index2, parent) {
  var children = child.children;
  var next;
  if (children && children.length !== 0 && children[0].type === "WhiteSpaceNode") {
    parent.children.splice(index2, 0, children.shift());
    next = children[0];
    if (next && next.position && child.position) {
      child.position.start = next.position.start;
    }
  }
}
var makeFinalWhiteSpaceSiblings_1 = unistUtilModifyChildren(makeFinalWhiteSpaceSiblings);
function makeFinalWhiteSpaceSiblings(child, index2, parent) {
  var children = child.children;
  var prev;
  if (children && children.length !== 0 && children[children.length - 1].type === "WhiteSpaceNode") {
    parent.children.splice(index2 + 1, 0, child.children.pop());
    prev = children[children.length - 1];
    if (prev && prev.position && child.position) {
      child.position.end = prev.position.end;
    }
    return index2;
  }
}
var breakImplicitSentences_1 = unistUtilModifyChildren(breakImplicitSentences);
var multiNewLine = expressions.newLineMulti;
function breakImplicitSentences(child, index2, parent) {
  var children;
  var position2;
  var length;
  var tail;
  var head2;
  var end2;
  var insertion;
  var node2;
  if (child.type !== "SentenceNode") {
    return;
  }
  children = child.children;
  length = children.length - 1;
  position2 = 0;
  while (++position2 < length) {
    node2 = children[position2];
    if (node2.type !== "WhiteSpaceNode" || !multiNewLine.test(nlcstToString_1(node2))) {
      continue;
    }
    child.children = children.slice(0, position2);
    insertion = {
      type: "SentenceNode",
      children: children.slice(position2 + 1)
    };
    tail = children[position2 - 1];
    head2 = children[position2 + 1];
    parent.children.splice(index2 + 1, 0, node2, insertion);
    if (child.position && tail.position && head2.position) {
      end2 = child.position.end;
      child.position.end = tail.position.end;
      insertion.position = {
        start: head2.position.start,
        end: end2
      };
    }
    return index2 + 1;
  }
}
var removeEmptyNodes_1 = unistUtilModifyChildren(removeEmptyNodes);
function removeEmptyNodes(child, index2, parent) {
  if ("children" in child && child.children.length === 0) {
    parent.children.splice(index2, 1);
    return index2;
  }
}
var lib2 = ParseLatin;
function ParseLatin(doc, file) {
  var value = file || doc;
  if (!(this instanceof ParseLatin)) {
    return new ParseLatin(doc, file);
  }
  this.doc = value ? String(value) : null;
}
var proto = ParseLatin.prototype;
proto.position = true;
proto.tokenizeSymbol = createTextFactory("Symbol");
proto.tokenizeWhiteSpace = createTextFactory("WhiteSpace");
proto.tokenizePunctuation = createTextFactory("Punctuation");
proto.tokenizeSource = createTextFactory("Source");
proto.tokenizeText = createTextFactory("Text");
proto.run = run;
proto.use = useFactory(function(context2, key, plugins) {
  context2[key] = context2[key].concat(plugins);
});
proto.useFirst = useFactory(function(context2, key, plugins) {
  context2[key] = plugins.concat(context2[key]);
});
proto.parse = function(value) {
  return this.tokenizeRoot(value || this.doc);
};
proto.tokenize = function(value) {
  return tokenize(this, value);
};
pluggable(ParseLatin, "tokenizeWord", function(value, eat2) {
  var add = (eat2 || noopEat)("");
  var parent = { type: "WordNode", children: [] };
  this.tokenizeText(value, eat2, parent);
  return add(parent);
});
pluggable(
  ParseLatin,
  "tokenizeSentence",
  parser({
    type: "SentenceNode",
    tokenizer: "tokenize"
  })
);
pluggable(
  ParseLatin,
  "tokenizeParagraph",
  parser({
    type: "ParagraphNode",
    delimiter: expressions.terminalMarker,
    delimiterType: "PunctuationNode",
    tokenizer: "tokenizeSentence"
  })
);
pluggable(
  ParseLatin,
  "tokenizeRoot",
  parser({
    type: "RootNode",
    delimiter: expressions.newLine,
    delimiterType: "WhiteSpaceNode",
    tokenizer: "tokenizeParagraph"
  })
);
proto.use("tokenizeSentence", [
  mergeInitialWordSymbol_1,
  mergeFinalWordSymbol_1,
  mergeInnerWordSymbol_1,
  mergeInnerWordSlash_1,
  mergeInitialisms_1,
  mergeWords,
  patchPosition_1
]);
proto.use("tokenizeParagraph", [
  mergeNonWordSentences_1,
  mergeAffixSymbol_1,
  mergeInitialLowerCaseLetterSentences_1,
  mergeInitialDigitSentences_1,
  mergePrefixExceptions_1,
  mergeAffixExceptions_1,
  mergeRemainingFullStops_1,
  makeInitialWhiteSpaceSiblings_1,
  makeFinalWhiteSpaceSiblings_1,
  breakImplicitSentences_1,
  removeEmptyNodes_1,
  patchPosition_1
]);
proto.use("tokenizeRoot", [
  makeInitialWhiteSpaceSiblings_1,
  makeFinalWhiteSpaceSiblings_1,
  removeEmptyNodes_1,
  patchPosition_1
]);
function createTextFactory(type2) {
  type2 += "Node";
  return createText;
  function createText(value, eat2, parent) {
    if (value === null || value === void 0) {
      value = "";
    }
    return (eat2 || noopEat)(value)(
      {
        type: type2,
        value: String(value)
      },
      parent
    );
  }
}
function run(key, nodes) {
  var wareKey = key + "Plugins";
  var plugins = this[wareKey];
  var index2 = -1;
  if (plugins) {
    while (plugins[++index2]) {
      plugins[index2](nodes);
    }
  }
  return nodes;
}
function pluggable(Constructor, key, callback) {
  Constructor.prototype[key] = function() {
    return this.run(key, callback.apply(this, arguments));
  };
}
function useFactory(callback) {
  return use;
  function use(key, plugins) {
    var self2 = this;
    var wareKey;
    if (!(key in self2)) {
      throw new Error(
        "Illegal Invocation: Unsupported `key` for `use(key, plugins)`. Make sure `key` is a supported function"
      );
    }
    if (!plugins) {
      return;
    }
    wareKey = key + "Plugins";
    if (typeof plugins === "function") {
      plugins = [plugins];
    } else {
      plugins = plugins.concat();
    }
    if (!self2[wareKey]) {
      self2[wareKey] = [];
    }
    callback(self2, wareKey, plugins);
  }
}
var wordRe = expressions.word;
var surrogatesRe = expressions.surrogates;
var punctuationRe = expressions.punctuation;
var whiteSpaceRe = expressions.whiteSpace;
function tokenize(parser2, value) {
  var tokens;
  var offset2;
  var line2;
  var column;
  var index2;
  var length;
  var character;
  var queue;
  var prev;
  var left2;
  var right2;
  var eater;
  if (value === null || value === void 0) {
    value = "";
  } else if (value instanceof String) {
    value = value.toString();
  }
  if (typeof value !== "string") {
    if ("length" in value && (!value[0] || value[0].type)) {
      return value;
    }
    throw new Error(
      "Illegal invocation: '" + value + "' is not a valid argument for 'ParseLatin'"
    );
  }
  tokens = [];
  if (!value) {
    return tokens;
  }
  index2 = 0;
  offset2 = 0;
  line2 = 1;
  column = 1;
  eater = parser2.position ? eat2 : noPositionEat;
  length = value.length;
  prev = "";
  queue = "";
  while (index2 < length) {
    character = value.charAt(index2);
    if (whiteSpaceRe.test(character)) {
      right2 = "WhiteSpace";
    } else if (punctuationRe.test(character)) {
      right2 = "Punctuation";
    } else if (wordRe.test(character)) {
      right2 = "Word";
    } else {
      right2 = "Symbol";
    }
    tick();
    prev = character;
    character = "";
    left2 = right2;
    right2 = null;
    index2++;
  }
  tick();
  return tokens;
  function tick() {
    if (left2 === right2 && (left2 === "Word" || left2 === "WhiteSpace" || character === prev || surrogatesRe.test(character))) {
      queue += character;
    } else {
      if (queue) {
        parser2["tokenize" + left2](queue, eater);
      }
      queue = character;
    }
  }
  function eat2(subvalue) {
    var pos = position2();
    update(subvalue);
    return apply;
    function apply() {
      return pos(add.apply(null, arguments));
    }
  }
  function noPositionEat() {
    return apply;
    function apply() {
      return add.apply(null, arguments);
    }
  }
  function add(node2, parent) {
    if (parent) {
      parent.children.push(node2);
    } else {
      tokens.push(node2);
    }
    return node2;
  }
  function position2() {
    var before2 = now2();
    function patch2(node2) {
      node2.position = new Position3(before2);
      return node2;
    }
    return patch2;
  }
  function update(subvalue) {
    var subvalueLength = subvalue.length;
    var character2 = -1;
    var lastIndex = -1;
    offset2 += subvalueLength;
    while (++character2 < subvalueLength) {
      if (subvalue.charAt(character2) === "\n") {
        lastIndex = character2;
        line2++;
      }
    }
    if (lastIndex === -1) {
      column += subvalueLength;
    } else {
      column = subvalueLength - lastIndex;
    }
  }
  function Position3(start2) {
    this.start = start2;
    this.end = now2();
  }
  function now2() {
    return {
      line: line2,
      column,
      offset: offset2
    };
  }
}
function noopAdd(node2, parent) {
  if (parent) {
    parent.children.push(node2);
  }
  return node2;
}
function noopEat() {
  return noopAdd;
}
var parseLatin = lib2;
var retextLatin = parse$12;
parse$12.Parser = parseLatin;
function parse$12() {
  this.Parser = unherit_1(parseLatin);
}
var retextStringify = stringify$1;
function stringify$1() {
  this.Compiler = compiler;
}
function compiler(tree) {
  return nlcstToString_1(tree);
}
var retext = unified_1().use(retextLatin).use(retextStringify).freeze();
var retextSmartypants = smartypants;
var punctuation = "PunctuationNode";
var symbol = "SymbolNode";
var word = "WordNode";
var whiteSpace = "WhiteSpaceNode";
var decadeExpression = /^\d\ds$/;
var threeFullStopsExpression = /^\.{3,}$/;
var fullStopsExpression = /^\.+$/;
var threeDashes = "---";
var twoDashes = "--";
var emDash = "—";
var enDash = "–";
var ellipsis = "…";
var twoBackticks = "``";
var backtick = "`";
var twoSingleQuotes = "''";
var singleQuote = "'";
var apostrophe = "’";
var doubleQuote = '"';
var openingDoubleQuote = "“";
var closingDoubleQuote = "”";
var openingSingleQuote = "‘";
var closingSingleQuote = "’";
var closingQuotes = {};
var openingQuotes = {};
openingQuotes[doubleQuote] = openingDoubleQuote;
closingQuotes[doubleQuote] = closingDoubleQuote;
openingQuotes[singleQuote] = openingSingleQuote;
closingQuotes[singleQuote] = closingSingleQuote;
var educators = {};
educators.dashes = {
  true: dashes,
  oldschool,
  inverted
};
educators.backticks = {
  true: backticks,
  all
};
educators.ellipses = {
  true: ellipses
};
educators.quotes = {
  true: quotes
};
function smartypants(options2) {
  var methods = [];
  var quotes2;
  var ellipses2;
  var backticks2;
  var dashes2;
  if (!options2) {
    options2 = {};
  }
  if ("quotes" in options2) {
    quotes2 = options2.quotes;
    if (quotes2 !== Boolean(quotes2)) {
      throw new TypeError(
        "Illegal invocation: `" + quotes2 + "` is not a valid value for `quotes` in `smartypants`"
      );
    }
  } else {
    quotes2 = true;
  }
  if ("ellipses" in options2) {
    ellipses2 = options2.ellipses;
    if (ellipses2 !== Boolean(ellipses2)) {
      throw new TypeError(
        "Illegal invocation: `" + ellipses2 + "` is not a valid value for `ellipses` in `smartypants`"
      );
    }
  } else {
    ellipses2 = true;
  }
  if ("backticks" in options2) {
    backticks2 = options2.backticks;
    if (backticks2 !== Boolean(backticks2) && backticks2 !== "all") {
      throw new TypeError(
        "Illegal invocation: `" + backticks2 + "` is not a valid value for `backticks` in `smartypants`"
      );
    }
    if (backticks2 === "all" && quotes2 === true) {
      throw new TypeError(
        "Illegal invocation: `backticks: " + backticks2 + "` is not a valid value when `quotes: " + quotes2 + "` in `smartypants`"
      );
    }
  } else {
    backticks2 = true;
  }
  if ("dashes" in options2) {
    dashes2 = options2.dashes;
    if (dashes2 !== Boolean(dashes2) && dashes2 !== "oldschool" && dashes2 !== "inverted") {
      throw new TypeError(
        "Illegal invocation: `" + dashes2 + "` is not a valid value for `dahes` in `smartypants`"
      );
    }
  } else {
    dashes2 = true;
  }
  if (quotes2 !== false) {
    methods.push(educators.quotes[quotes2]);
  }
  if (ellipses2 !== false) {
    methods.push(educators.ellipses[ellipses2]);
  }
  if (backticks2 !== false) {
    methods.push(educators.backticks[backticks2]);
  }
  if (dashes2 !== false) {
    methods.push(educators.dashes[dashes2]);
  }
  return transformFactory(methods);
}
function transformFactory(methods) {
  var length = methods.length;
  return transformer;
  function transformer(tree) {
    unistUtilVisit(tree, visitor);
  }
  function visitor(node2, position2, parent) {
    var index2 = -1;
    if (node2.type === punctuation || node2.type === symbol) {
      while (++index2 < length) {
        methods[index2](node2, position2, parent);
      }
    }
  }
}
function oldschool(node2) {
  if (node2.value === threeDashes) {
    node2.value = emDash;
  } else if (node2.value === twoDashes) {
    node2.value = enDash;
  }
}
function dashes(node2) {
  if (node2.value === twoDashes) {
    node2.value = emDash;
  }
}
function inverted(node2) {
  if (node2.value === threeDashes) {
    node2.value = enDash;
  } else if (node2.value === twoDashes) {
    node2.value = emDash;
  }
}
function backticks(node2) {
  if (node2.value === twoBackticks) {
    node2.value = openingDoubleQuote;
  } else if (node2.value === twoSingleQuotes) {
    node2.value = closingDoubleQuote;
  }
}
function all(node2) {
  backticks(node2);
  if (node2.value === backtick) {
    node2.value = openingSingleQuote;
  } else if (node2.value === singleQuote) {
    node2.value = closingSingleQuote;
  }
}
function ellipses(node2, index2, parent) {
  var value = node2.value;
  var siblings2 = parent.children;
  var position2;
  var nodes;
  var sibling;
  var type2;
  var count;
  var queue;
  if (threeFullStopsExpression.test(node2.value)) {
    node2.value = ellipsis;
    return;
  }
  if (!fullStopsExpression.test(value)) {
    return;
  }
  nodes = [];
  position2 = index2;
  count = 1;
  while (--position2 > 0) {
    sibling = siblings2[position2];
    if (sibling.type !== whiteSpace) {
      break;
    }
    queue = sibling;
    sibling = siblings2[--position2];
    type2 = sibling && sibling.type;
    if (sibling && (type2 === punctuation || type2 === symbol) && fullStopsExpression.test(sibling.value)) {
      nodes.push(queue, sibling);
      count++;
      continue;
    }
    break;
  }
  if (count < 3) {
    return;
  }
  siblings2.splice(index2 - nodes.length, nodes.length);
  node2.value = ellipsis;
}
function quotes(node2, index2, parent) {
  var siblings2 = parent.children;
  var value = node2.value;
  var next;
  var nextNext;
  var prev;
  var nextValue;
  if (value !== doubleQuote && value !== singleQuote) {
    return;
  }
  prev = siblings2[index2 - 1];
  next = siblings2[index2 + 1];
  nextNext = siblings2[index2 + 2];
  nextValue = next && nlcstToString_1(next);
  if (next && nextNext && (next.type === punctuation || next.type === symbol) && nextNext.type !== word) {
    node2.value = closingQuotes[value];
  } else if (nextNext && (nextValue === doubleQuote || nextValue === singleQuote) && nextNext.type === word) {
    node2.value = openingQuotes[value];
    next.value = openingQuotes[nextValue];
  } else if (next && decadeExpression.test(nextValue)) {
    node2.value = closingQuotes[value];
  } else if (prev && next && (prev.type === whiteSpace || prev.type === punctuation || prev.type === symbol) && next.type === word) {
    node2.value = openingQuotes[value];
  } else if (prev && prev.type !== whiteSpace && prev.type !== symbol && prev.type !== punctuation) {
    node2.value = closingQuotes[value];
  } else if (!next || next.type === whiteSpace || (value === singleQuote || value === apostrophe) && nextValue === "s") {
    node2.value = closingQuotes[value];
  } else {
    node2.value = openingQuotes[value];
  }
}
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend3(target2, source) {
  var index2, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
      key = sourceKeys[index2];
      target2[key] = source[key];
    }
  }
  return target2;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number2) {
  return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend3;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function YAMLException$1(reason, mark2) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark2;
  this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString3(compact) {
  var result = this.name + ": ";
  result += this.reason || "(unknown reason)";
  if (!compact && this.mark) {
    result += " " + this.mark.toString();
  }
  return result;
};
var exception = YAMLException$1;
function Mark(name3, buffer, position2, line2, column) {
  this.name = name3;
  this.buffer = buffer;
  this.position = position2;
  this.line = line2;
  this.column = column;
}
Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head2, start2, tail, end2, snippet;
  if (!this.buffer)
    return null;
  indent = indent || 4;
  maxLength = maxLength || 75;
  head2 = "";
  start2 = this.position;
  while (start2 > 0 && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(start2 - 1)) === -1) {
    start2 -= 1;
    if (this.position - start2 > maxLength / 2 - 1) {
      head2 = " ... ";
      start2 += 5;
      break;
    }
  }
  tail = "";
  end2 = this.position;
  while (end2 < this.buffer.length && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(end2)) === -1) {
    end2 += 1;
    if (end2 - this.position > maxLength / 2 - 1) {
      tail = " ... ";
      end2 -= 5;
      break;
    }
  }
  snippet = this.buffer.slice(start2, end2);
  return common.repeat(" ", indent) + head2 + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start2 + head2.length) + "^";
};
Mark.prototype.toString = function toString4(compact) {
  var snippet, where = "";
  if (this.name) {
    where += 'in "' + this.name + '" ';
  }
  where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
  if (!compact) {
    snippet = this.getSnippet();
    if (snippet) {
      where += ":\n" + snippet;
    }
  }
  return where;
};
var mark = Mark;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag3, options2) {
  options2 = options2 || {};
  Object.keys(options2).forEach(function(name3) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name3) === -1) {
      throw new exception('Unknown option "' + name3 + '" is met in definition of "' + tag3 + '" YAML type.');
    }
  });
  this.tag = tag3;
  this.kind = options2["kind"] || null;
  this.resolve = options2["resolve"] || function() {
    return true;
  };
  this.construct = options2["construct"] || function(data3) {
    return data3;
  };
  this.instanceOf = options2["instanceOf"] || null;
  this.predicate = options2["predicate"] || null;
  this.represent = options2["represent"] || null;
  this.defaultStyle = options2["defaultStyle"] || null;
  this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag3 + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name3, result) {
  var exclude = [];
  schema2.include.forEach(function(includedSchema) {
    result = compileList(includedSchema, name3, result);
  });
  schema2[name3].forEach(function(currentType) {
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });
    result.push(currentType);
  });
  return result.filter(function(type2, index2) {
    return exclude.indexOf(index2) === -1;
  });
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  }, index2, length;
  function collectType(type2) {
    result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result;
}
function Schema$1(definition2) {
  this.include = definition2.include || [];
  this.implicit = definition2.implicit || [];
  this.explicit = definition2.explicit || [];
  this.implicit.forEach(function(type2) {
    if (type2.loadKind && type2.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
  });
  this.compiledImplicit = compileList(this, "implicit", []);
  this.compiledExplicit = compileList(this, "explicit", []);
  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}
Schema$1.DEFAULT = null;
Schema$1.create = function createSchema() {
  var schemas, types3;
  switch (arguments.length) {
    case 1:
      schemas = Schema$1.DEFAULT;
      types3 = arguments[0];
      break;
    case 2:
      schemas = arguments[0];
      types3 = arguments[1];
      break;
    default:
      throw new exception("Wrong number of arguments for Schema.create function");
  }
  schemas = common.toArray(schemas);
  types3 = common.toArray(types3);
  if (!schemas.every(function(schema2) {
    return schema2 instanceof Schema$1;
  })) {
    throw new exception("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
  }
  if (!types3.every(function(type$1) {
    return type$1 instanceof type;
  })) {
    throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  }
  return new Schema$1({
    include: schemas,
    explicit: types3
  });
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data3) {
    return data3 !== null ? data3 : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data3) {
    return data3 !== null ? data3 : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data3) {
    return data3 !== null ? data3 : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data3) {
  if (data3 === null)
    return true;
  var max = data3.length;
  return max === 1 && data3 === "~" || max === 4 && (data3 === "null" || data3 === "Null" || data3 === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data3) {
  if (data3 === null)
    return false;
  var max = data3.length;
  return max === 4 && (data3 === "true" || data3 === "True" || data3 === "TRUE") || max === 5 && (data3 === "false" || data3 === "False" || data3 === "FALSE");
}
function constructYamlBoolean(data3) {
  return data3 === "true" || data3 === "True" || data3 === "TRUE";
}
function isBoolean3(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean3,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data3) {
  if (data3 === null)
    return false;
  var max = data3.length, index2 = 0, hasDigits = false, ch2;
  if (!max)
    return false;
  ch2 = data3[index2];
  if (ch2 === "-" || ch2 === "+") {
    ch2 = data3[++index2];
  }
  if (ch2 === "0") {
    if (index2 + 1 === max)
      return true;
    ch2 = data3[++index2];
    if (ch2 === "b") {
      index2++;
      for (; index2 < max; index2++) {
        ch2 = data3[index2];
        if (ch2 === "_")
          continue;
        if (ch2 !== "0" && ch2 !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch2 !== "_";
    }
    if (ch2 === "x") {
      index2++;
      for (; index2 < max; index2++) {
        ch2 = data3[index2];
        if (ch2 === "_")
          continue;
        if (!isHexCode(data3.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch2 !== "_";
    }
    for (; index2 < max; index2++) {
      ch2 = data3[index2];
      if (ch2 === "_")
        continue;
      if (!isOctCode(data3.charCodeAt(index2)))
        return false;
      hasDigits = true;
    }
    return hasDigits && ch2 !== "_";
  }
  if (ch2 === "_")
    return false;
  for (; index2 < max; index2++) {
    ch2 = data3[index2];
    if (ch2 === "_")
      continue;
    if (ch2 === ":")
      break;
    if (!isDecCode(data3.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch2 === "_")
    return false;
  if (ch2 !== ":")
    return true;
  return /^(:[0-5]?[0-9])+$/.test(data3.slice(index2));
}
function constructYamlInteger(data3) {
  var value = data3, sign = 1, ch2, base, digits = [];
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch2 = value[0];
  if (ch2 === "-" || ch2 === "+") {
    if (ch2 === "-")
      sign = -1;
    value = value.slice(1);
    ch2 = value[0];
  }
  if (value === "0")
    return 0;
  if (ch2 === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }
  if (value.indexOf(":") !== -1) {
    value.split(":").forEach(function(v2) {
      digits.unshift(parseInt(v2, 10));
    });
    value = 0;
    base = 1;
    digits.forEach(function(d2) {
      value += d2 * base;
      base *= 60;
    });
    return sign * value;
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int_1 = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data3) {
  if (data3 === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data3) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data3[data3.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data3) {
  var value, sign, base, digits;
  value = data3.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  digits = [];
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  } else if (value.indexOf(":") >= 0) {
    value.split(":").forEach(function(v2) {
      digits.unshift(parseFloat(v2, 10));
    });
    value = 0;
    base = 1;
    digits.forEach(function(d2) {
      value += d2 * base;
      base *= 60;
    });
    return sign * value;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res2;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res2 = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res2) ? res2.replace("e", ".e") : res2;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float_1 = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = new schema({
  include: [
    failsafe
  ],
  implicit: [
    _null,
    bool,
    int_1,
    float_1
  ]
});
var core = new schema({
  include: [
    json
  ]
});
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data3) {
  if (data3 === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data3) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data3) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data3) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta2 = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data3);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data3);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta2 = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta2 = -delta2;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta2)
    date.setTime(date.getTime() - delta2);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data3) {
  return data3 === "<<" || data3 === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var NodeBuffer;
try {
  _require$1 = commonjsRequire;
  NodeBuffer = _require$1("buffer").Buffer;
} catch (__) {
}
var _require$1;
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data3) {
  if (data3 === null)
    return false;
  var code2, idx, bitlen = 0, max = data3.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code2 = map2.indexOf(data3.charAt(idx));
    if (code2 > 64)
      continue;
    if (code2 < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data3) {
  var idx, tailbits, input = data3.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  if (NodeBuffer) {
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }
  return result;
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data3) {
  if (data3 === null)
    return true;
  var objectKeys2 = [], index2, length, pair, pairKey, pairHasKey, object = data3;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys2.indexOf(pairKey) === -1)
      objectKeys2.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data3) {
  return data3 !== null ? data3 : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data3) {
  if (data3 === null)
    return true;
  var index2, length, pair, keys3, result, object = data3;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys3 = Object.keys(pair);
    if (keys3.length !== 1)
      return false;
    result[index2] = [keys3[0], pair[keys3[0]]];
  }
  return true;
}
function constructYamlPairs(data3) {
  if (data3 === null)
    return [];
  var index2, length, pair, keys3, result, object = data3;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    keys3 = Object.keys(pair);
    result[index2] = [keys3[0], pair[keys3[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data3) {
  if (data3 === null)
    return true;
  var key, object = data3;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data3) {
  return data3 !== null ? data3 : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var default_safe = new schema({
  include: [
    core
  ],
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
function resolveJavascriptUndefined() {
  return true;
}
function constructJavascriptUndefined() {
  return void 0;
}
function representJavascriptUndefined() {
  return "";
}
function isUndefined(object) {
  return typeof object === "undefined";
}
var _undefined = new type("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});
function resolveJavascriptRegExp(data3) {
  if (data3 === null)
    return false;
  if (data3.length === 0)
    return false;
  var regexp2 = data3, tail = /\/([gim]*)$/.exec(data3), modifiers = "";
  if (regexp2[0] === "/") {
    if (tail)
      modifiers = tail[1];
    if (modifiers.length > 3)
      return false;
    if (regexp2[regexp2.length - modifiers.length - 1] !== "/")
      return false;
  }
  return true;
}
function constructJavascriptRegExp(data3) {
  var regexp2 = data3, tail = /\/([gim]*)$/.exec(data3), modifiers = "";
  if (regexp2[0] === "/") {
    if (tail)
      modifiers = tail[1];
    regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1);
  }
  return new RegExp(regexp2, modifiers);
}
function representJavascriptRegExp(object) {
  var result = "/" + object.source + "/";
  if (object.global)
    result += "g";
  if (object.multiline)
    result += "m";
  if (object.ignoreCase)
    result += "i";
  return result;
}
function isRegExp2(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
}
var regexp = new type("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp2,
  represent: representJavascriptRegExp
});
var esprima;
try {
  _require = commonjsRequire;
  esprima = _require("esprima");
} catch (_2) {
  if (typeof window !== "undefined")
    esprima = window.esprima;
}
var _require;
function resolveJavascriptFunction(data3) {
  if (data3 === null)
    return false;
  try {
    var source = "(" + data3 + ")", ast2 = esprima.parse(source, { range: true });
    if (ast2.type !== "Program" || ast2.body.length !== 1 || ast2.body[0].type !== "ExpressionStatement" || ast2.body[0].expression.type !== "ArrowFunctionExpression" && ast2.body[0].expression.type !== "FunctionExpression") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
function constructJavascriptFunction(data3) {
  var source = "(" + data3 + ")", ast2 = esprima.parse(source, { range: true }), params = [], body2;
  if (ast2.type !== "Program" || ast2.body.length !== 1 || ast2.body[0].type !== "ExpressionStatement" || ast2.body[0].expression.type !== "ArrowFunctionExpression" && ast2.body[0].expression.type !== "FunctionExpression") {
    throw new Error("Failed to resolve function");
  }
  ast2.body[0].expression.params.forEach(function(param) {
    params.push(param.name);
  });
  body2 = ast2.body[0].expression.body.range;
  if (ast2.body[0].expression.body.type === "BlockStatement") {
    return new Function(params, source.slice(body2[0] + 1, body2[1] - 1));
  }
  return new Function(params, "return " + source.slice(body2[0], body2[1]));
}
function representJavascriptFunction(object) {
  return object.toString();
}
function isFunction2(object) {
  return Object.prototype.toString.call(object) === "[object Function]";
}
var _function = new type("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction2,
  represent: representJavascriptFunction
});
var default_full = schema.DEFAULT = new schema({
  include: [
    default_safe
  ],
  explicit: [
    _undefined,
    regexp,
    _function
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc2;
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  lc2 = c2 | 32;
  if (97 <= lc2 && lc2 <= 102) {
    return lc2 - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c2) {
  if (c2 === 120) {
    return 2;
  }
  if (c2 === 117) {
    return 4;
  }
  if (c2 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c2) {
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "" : c2 === 95 ? " " : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  if (c2 <= 65535) {
    return String.fromCharCode(c2);
  }
  return String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options2) {
  this.input = input;
  this.filename = options2["filename"] || null;
  this.schema = options2["schema"] || default_full;
  this.onWarning = options2["onWarning"] || null;
  this.legacy = options2["legacy"] || false;
  this.json = options2["json"] || false;
  this.listener = options2["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.documents = [];
}
function generateError(state, message2) {
  return new exception(
    message2,
    new mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
  );
}
function throwError(state, message2) {
  throw generateError(state, message2);
}
function throwWarning(state, message2) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message2));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name3, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name3, args) {
    var handle2, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle2 = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle2)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle2)) {
      throwError(state, 'there is a previously declared suffix for "' + handle2 + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    state.tagMap[handle2] = prefix;
  }
};
function captureSegment(state, start2, end2, checkJson) {
  var _position, _length, _character, _result;
  if (start2 < end2) {
    _result = state.input.slice(start2, end2);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index2, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 === 10) {
    state.position++;
  } else if (ch2 === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch2 = state.input.charCodeAt(state.position);
  while (ch2 !== 0) {
    while (is_WHITE_SPACE(ch2)) {
      ch2 = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch2 === 35) {
      do {
        ch2 = state.input.charCodeAt(++state.position);
      } while (ch2 !== 10 && ch2 !== 13 && ch2 !== 0);
    }
    if (is_EOL(ch2)) {
      readLineBreak(state);
      ch2 = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch2 === 32) {
        state.lineIndent++;
        ch2 = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch2;
  ch2 = state.input.charCodeAt(_position);
  if ((ch2 === 45 || ch2 === 46) && ch2 === state.input.charCodeAt(_position + 1) && ch2 === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch2 = state.input.charCodeAt(_position);
    if (ch2 === 0 || is_WS_OR_EOL(ch2)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch2) || is_FLOW_INDICATOR(ch2) || ch2 === 35 || ch2 === 38 || ch2 === 42 || ch2 === 33 || ch2 === 124 || ch2 === 62 || ch2 === 39 || ch2 === 34 || ch2 === 37 || ch2 === 64 || ch2 === 96) {
    return false;
  }
  if (ch2 === 63 || ch2 === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch2 !== 0) {
    if (ch2 === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch2 === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch2)) {
      break;
    } else if (is_EOL(ch2)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch2 = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch2)) {
      captureEnd = state.position + 1;
    }
    ch2 = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch2, captureStart, captureEnd;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
    if (ch2 === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch2 = state.input.charCodeAt(++state.position);
      if (ch2 === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch2)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
    if (ch2 === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch2 === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch2 = state.input.charCodeAt(++state.position);
      if (is_EOL(ch2)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch2 < 256 && simpleEscapeCheck[ch2]) {
        state.result += simpleEscapeMap[ch2];
        state.position++;
      } else if ((tmp = escapedHexLen(ch2)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch2 = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch2)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch2)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch2 === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch2 = state.input.charCodeAt(++state.position);
  while (ch2 !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch2 === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch2 = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch2 === 58) {
      isPair = true;
      ch2 = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 === 44) {
      readNext = true;
      ch2 = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 === 124) {
    folding = false;
  } else if (ch2 === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch2 !== 0) {
    ch2 = state.input.charCodeAt(++state.position);
    if (ch2 === 43 || ch2 === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch2 === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch2)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch2)) {
    do {
      ch2 = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch2));
    if (ch2 === 35) {
      do {
        ch2 = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch2) && ch2 !== 0);
    }
  }
  while (ch2 !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch2 = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch2 === 32) {
      state.lineIndent++;
      ch2 = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch2)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch2)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch2) && ch2 !== 0) {
      ch2 = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch2;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch2 = state.input.charCodeAt(state.position);
  while (ch2 !== 0) {
    if (ch2 !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch2 = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch2 = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch2 !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch2;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch2 = state.input.charCodeAt(state.position);
  while (ch2 !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    _pos = state.position;
    if ((ch2 === 63 || ch2 === 58) && is_WS_OR_EOL(following)) {
      if (ch2 === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch2 = following;
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
      if (state.line === _line) {
        ch2 = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch2)) {
          ch2 = state.input.charCodeAt(++state.position);
        }
        if (ch2 === 58) {
          ch2 = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch2)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    } else {
      break;
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch2 = state.input.charCodeAt(state.position);
    }
    if (state.lineIndent > nodeIndent && ch2 !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch2 = state.input.charCodeAt(++state.position);
  if (ch2 === 60) {
    isVerbatim = true;
    ch2 = state.input.charCodeAt(++state.position);
  } else if (ch2 === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch2 = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch2 = state.input.charCodeAt(++state.position);
    } while (ch2 !== 0 && ch2 !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch2 = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
      if (ch2 === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch2 = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch2 = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch2 !== 0 && !is_WS_OR_EOL(ch2) && !is_FLOW_INDICATOR(ch2)) {
    ch2 = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch2;
  ch2 = state.input.charCodeAt(state.position);
  if (ch2 !== 42)
    return false;
  ch2 = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch2 !== 0 && !is_WS_OR_EOL(ch2) && !is_FLOW_INDICATOR(ch2)) {
    ch2 = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag !== null && state.tag !== "!") {
    if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch2;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};
  while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch2 = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch2 !== 37) {
      break;
    }
    hasDirectives = true;
    ch2 = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
      ch2 = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch2 !== 0) {
      while (is_WHITE_SPACE(ch2)) {
        ch2 = state.input.charCodeAt(++state.position);
      }
      if (ch2 === 35) {
        do {
          ch2 = state.input.charCodeAt(++state.position);
        } while (ch2 !== 0 && !is_EOL(ch2));
        break;
      }
      if (is_EOL(ch2))
        break;
      _position = state.position;
      while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
        ch2 = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch2 !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options2) {
  input = String(input);
  options2 = options2 || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options2);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options2) {
  if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
    options2 = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options2);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
    iterator(documents[index2]);
  }
}
function load$1(input, options2) {
  var documents = loadDocuments(input, options2);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
function safeLoadAll$1(input, iterator, options2) {
  if (typeof iterator === "object" && iterator !== null && typeof options2 === "undefined") {
    options2 = iterator;
    iterator = null;
  }
  return loadAll$1(input, iterator, common.extend({ schema: default_safe }, options2));
}
function safeLoad$1(input, options2) {
  return load$1(input, common.extend({ schema: default_safe }, options2));
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var safeLoadAll_1 = safeLoadAll$1;
var safeLoad_1 = safeLoad$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1,
  safeLoadAll: safeLoadAll_1,
  safeLoad: safeLoad_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
function compileStyleMap(schema2, map2) {
  var result, keys3, index2, length, tag3, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys3 = Object.keys(map2);
  for (index2 = 0, length = keys3.length; index2 < length; index2 += 1) {
    tag3 = keys3[index2];
    style = String(map2[tag3]);
    if (tag3.slice(0, 2) === "!!") {
      tag3 = "tag:yaml.org,2002:" + tag3.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag3];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag3] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle2, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle2 = "x";
    length = 2;
  } else if (character <= 65535) {
    handle2 = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle2 = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle2 + common.repeat("0", length - string.length) + string;
}
function State(options2) {
  this.schema = options2["schema"] || default_full;
  this.indent = Math.max(1, options2["indent"] || 2);
  this.noArrayIndent = options2["noArrayIndent"] || false;
  this.skipInvalid = options2["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
  this.sortKeys = options2["sortKeys"] || false;
  this.lineWidth = options2["lineWidth"] || 80;
  this.noRefs = options2["noRefs"] || false;
  this.noCompatMode = options2["noCompatMode"] || false;
  this.condenseFlow = options2["condenseFlow"] || false;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces2) {
  var ind = common.repeat(" ", spaces2), position2 = 0, next = -1, result = "", line2, length = string.length;
  while (position2 < length) {
    next = string.indexOf("\n", position2);
    if (next === -1) {
      line2 = string.slice(position2);
      position2 = length;
    } else {
      line2 = string.slice(position2, next + 1);
      position2 = next + 1;
    }
    if (line2.length && line2 !== "\n")
      result += ind;
    result += line2;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index2, length, type2;
  for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
    type2 = state.implicitTypes[index2];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c2) {
  return c2 === CHAR_SPACE || c2 === CHAR_TAB;
}
function isPrintable(c2) {
  return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
}
function isNsChar(c2) {
  return isPrintable(c2) && !isWhitespace(c2) && c2 !== 65279 && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
}
function isPlainSafe(c2, prev) {
  return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON && (c2 !== CHAR_SHARP || prev && isNsChar(prev));
}
function isPlainSafeFirst(c2) {
  return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
  if (singleLineOnly) {
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
  } else {
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}
function writeScalar(state, string, level, iskey) {
  state.dump = function() {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line2 = match[2];
    moreIndented = line2[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line2 !== "" ? "\n" : "") + foldLine(line2, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line2, width) {
  if (line2 === "" || line2[0] === " ")
    return line2;
  var breakRe = / [^ ]/g;
  var match;
  var start2 = 0, end2, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line2)) {
    next = match.index;
    if (next - start2 > width) {
      end2 = curr > start2 ? curr : next;
      result += "\n" + line2.slice(start2, end2);
      start2 = end2 + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line2.length - start2 > width && curr > start2) {
    result += line2.slice(start2, curr) + "\n" + line2.slice(curr + 1);
  } else {
    result += line2.slice(start2);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char, nextChar;
  var escapeSeq;
  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    if (char >= 55296 && char <= 56319) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 56320 && nextChar <= 57343) {
        result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
        i++;
        continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index2, length;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    if (writeNode(state, level, object[index2], false, false)) {
      if (index2 !== 0)
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index2, length;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    if (writeNode(state, level + 1, object[index2], true, true)) {
      if (!compact || index2 !== 0) {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (index2 !== 0)
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (!compact || index2 !== 0) {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index2, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
    type2 = typeList[index2];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      state.tag = explicit ? type2.tag : "?";
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block2, compact, iskey) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  if (block2) {
    block2 = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block2 && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
      if (block2 && state.dump.length !== 0) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      state.dump = "!<" + state.tag + "> " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index2, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index2]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index2, length;
  if (object !== null && typeof object === "object") {
    index2 = objects.indexOf(object);
    if (index2 !== -1) {
      if (duplicatesIndexes.indexOf(index2) === -1) {
        duplicatesIndexes.push(index2);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
          inspectNode(object[index2], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
          inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options2) {
  options2 = options2 || {};
  var state = new State(options2);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  if (writeNode(state, 0, input, true, true))
    return state.dump + "\n";
  return "";
}
function safeDump$1(input, options2) {
  return dump$1(input, common.extend({ schema: default_safe }, options2));
}
var dump_1 = dump$1;
var safeDump_1 = safeDump$1;
var dumper = {
  dump: dump_1,
  safeDump: safeDump_1
};
function deprecated(name3) {
  return function() {
    throw new Error("Function " + name3 + " is deprecated and cannot be used.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SAFE_SCHEMA = default_safe;
var DEFAULT_FULL_SCHEMA = default_full;
var load = loader.load;
var loadAll = loader.loadAll;
var safeLoad = loader.safeLoad;
var safeLoadAll = loader.safeLoadAll;
var dump = dumper.dump;
var safeDump = dumper.safeDump;
var YAMLException = exception;
var MINIMAL_SCHEMA = failsafe;
var SAFE_SCHEMA = default_safe;
var DEFAULT_SCHEMA = default_full;
var scan = deprecated("scan");
var parse4 = deprecated("parse");
var compose = deprecated("compose");
var addConstructor = deprecated("addConstructor");
var jsYaml$1 = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SAFE_SCHEMA,
  DEFAULT_FULL_SCHEMA,
  load,
  loadAll,
  safeLoad,
  safeLoadAll,
  dump,
  safeDump,
  YAMLException,
  MINIMAL_SCHEMA,
  SAFE_SCHEMA,
  DEFAULT_SCHEMA,
  scan,
  parse: parse4,
  compose,
  addConstructor
};
var jsYaml = jsYaml$1;
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml;
function escapeHtml(string) {
  var str2 = "" + string;
  var match = matchHtmlRegExp.exec(str2);
  if (!match) {
    return str2;
  }
  var escape2;
  var html2 = "";
  var index2 = 0;
  var lastIndex = 0;
  for (index2 = match.index; index2 < str2.length; index2++) {
    switch (str2.charCodeAt(index2)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html2 += str2.substring(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html2 += escape2;
  }
  return lastIndex !== index2 ? html2 + str2.substring(lastIndex, index2) : html2;
}
function _optionalChain(ops) {
  let lastAccessLHS = void 0;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op2 = ops[i];
    const fn2 = ops[i + 1];
    i += 2;
    if ((op2 === "optionalAccess" || op2 === "optionalCall") && value == null) {
      return void 0;
    }
    if (op2 === "access" || op2 === "optionalAccess") {
      lastAccessLHS = value;
      value = fn2(value);
    } else if (op2 === "call" || op2 === "optionalCall") {
      value = fn2((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = void 0;
    }
  }
  return value;
}
var newline = "\n";
function default_frontmatter(value, messages2) {
  try {
    return jsYaml.safeLoad(value);
  } catch (e) {
    messages2.push(new vfileMessage("YAML failed to parse"));
  }
}
function parse_frontmatter({
  parse: parse5,
  type: type2
}) {
  const transformer = (tree, vFile) => {
    unistUtilVisit(tree, type2, (node2) => {
      const data3 = parse5(node2.value, vFile.messages);
      if (data3) {
        vFile.data.fm = data3;
      }
    });
  };
  return transformer;
}
var entites = [
  [/</g, "&lt;"],
  [/>/g, "&gt;"],
  [/{/g, "&#123;"],
  [/}/g, "&#125;"]
];
function escape_code({ blocks }) {
  return function(tree) {
    if (!blocks) {
      unistUtilVisit(tree, "code", escape2);
    }
    unistUtilVisit(tree, "inlineCode", escape2);
    function escape2(node2) {
      for (let i = 0; i < entites.length; i += 1) {
        node2.value = node2.value.replace(entites[i][0], entites[i][1]);
      }
    }
  };
}
function smartypants_transformer(options2 = {}) {
  const processor = retext().use(retextSmartypants, options2);
  return function(tree) {
    unistUtilVisit(tree, "text", (node2) => {
      node2.value = String(processor.processSync(node2.value));
    });
  };
}
var attrs = `(?:\\s{0,1}[a-zA-z]+=(?:"){0,1}[a-zA-Z0-9]+(?:"){0,1})*`;
var context = `(?:\\s{0,1}context)=(?:"){0,1}module(?:"){0,1}`;
var RE_BLANK = /^\n+$|^\s+$/;
var RE_SCRIPT = new RegExp(`^(<script` + attrs + `>)`);
var RE_MODULE_SCRIPT = new RegExp(
  `^(<script` + attrs + context + attrs + `>)`
);
function extract_parts(nodes) {
  const parts = {
    special: [],
    html: [],
    instance: [],
    module: [],
    css: []
  };
  children:
    for (let i = 0; i < nodes.length; i += 1) {
      const empty_node = nodes[i].type === "text" && RE_BLANK.exec(nodes[i].value);
      if (empty_node || !nodes[i].value) {
        if (!parts.html.length || !(RE_BLANK.exec(nodes[i].value) && RE_BLANK.exec(parts.html[parts.html.length - 1].value))) {
          parts.html.push(nodes[i]);
        }
        continue children;
      }
      let result;
      try {
        result = parse$b(nodes[i].value);
      } catch (e) {
        parts.html.push(nodes[i]);
        continue children;
      }
      if (!result.html || !result.html.children)
        return parts;
      const _parts = result.html.children.map((v2) => {
        if (v2.type === "Options" || v2.type === "Head" || v2.type === "Window" || v2.type === "Body") {
          return ["special", v2.start, v2.end];
        } else {
          return ["html", v2.start, v2.end];
        }
      });
      results:
        for (const key in result) {
          if (key === "html" || !result[key])
            continue results;
          _parts.push([
            key,
            result[key].start,
            result[key].end
          ]);
        }
      const sorted = _parts.sort((a, b) => a[1] - b[1]);
      sorted.forEach((next) => {
        parts[next[0]].push({
          type: "raw",
          value: nodes[i].value.substring(next[1], next[2])
        });
      });
    }
  return parts;
}
function map_layout_to_path(filename, layout_map) {
  const match = Object.keys(layout_map).find(
    (l2) => new RegExp(`\\${path.sep}${l2}\\${path.sep}`).test(
      path.normalize(filename).replace(process.cwd(), "")
    )
  );
  if (match) {
    return layout_map[match];
  } else {
    return layout_map["_"] ? layout_map["_"] : void 0;
  }
}
function generate_layout_import(layout) {
  if (!layout)
    return false;
  return `import Layout_MDSVEX_DEFAULT${layout.components.length ? `, * as Components` : ""} from '${layout.path}';`;
}
function generate_layout({
  frontmatter_layout,
  layout_options,
  layout_mode,
  filename
}) {
  let selected_layout;
  const error2 = { reason: "" };
  if (!layout_options || frontmatter_layout === false) {
    return [false, false, false];
  } else if (layout_mode === "single") {
    selected_layout = layout_options.__mdsvex_default;
    if (frontmatter_layout)
      error2.reason = `You attempted to apply a named layout in the front-matter of "${filename}", but did not provide any named layouts as options to the preprocessor. `;
  } else if (frontmatter_layout) {
    selected_layout = layout_options[frontmatter_layout];
    if (!selected_layout)
      error2.reason = `Could not find a layout with the name "${frontmatter_layout}" and no fall back layout ("_") was provided.`;
  } else {
    selected_layout = map_layout_to_path(filename, layout_options);
  }
  return [
    generate_layout_import(selected_layout),
    selected_layout !== void 0 && selected_layout.components.length > 0 && selected_layout.components,
    error2.reason ? error2 : false
  ];
}
function transform_hast({
  layout,
  layout_mode
}) {
  return function transformer(tree, vFile) {
    unistUtilVisit(tree, "element", (node2) => {
      if (node2.tagName === "a" && node2.properties && typeof node2.properties.href === "string") {
        node2.properties.href = node2.properties.href.replace(/%7B/g, "{").replace(/%7D/g, "}");
      }
      if (node2.tagName === "img" && node2.properties && typeof node2.properties.src === "string") {
        node2.properties.src = node2.properties.src.replace(/%7B/g, "{").replace(/%7D/g, "}");
      }
    });
    if (!layout && !vFile.data.fm)
      return tree;
    unistUtilVisit(tree, "root", (node2) => {
      const { special, html: html2, instance, module: _module, css } = extract_parts(
        node2.children
      );
      const { fm: metadata } = vFile.data;
      const stringified = metadata && JSON.stringify(metadata).replace(/<(\/?script|\/?style)/g, '<"+"$1');
      const fm = metadata && `export const metadata = ${stringified};${newline}	const { ${Object.keys(metadata).join(", ")} } = metadata;`;
      const frontmatter_layout = metadata && metadata.layout;
      const [import_script, components, error2] = generate_layout({
        frontmatter_layout,
        layout_options: layout,
        layout_mode,
        //@ts-ignore
        filename: vFile.filename
      });
      if (error2)
        vFile.messages.push(new vfileMessage(error2.reason));
      if (components) {
        for (let i = 0; i < components.length; i++) {
          unistUtilVisit(tree, "element", (node3) => {
            if (node3.tagName === components[i]) {
              node3.tagName = `Components.${components[i]}`;
            }
          });
        }
      }
      if (import_script && !instance[0]) {
        instance.push({
          type: "raw",
          value: `${newline}<script>${newline}	${import_script}${newline}<\/script>${newline}`
        });
      } else if (import_script) {
        instance[0].value = instance[0].value.replace(
          RE_SCRIPT,
          `$1${newline}	${import_script}`
        );
      }
      if (!_module[0] && fm) {
        _module.push({
          type: "raw",
          value: `<script context="module">${newline}	${fm}${newline}<\/script>`
        });
      } else if (fm) {
        _module[0].value = _module[0].value.replace(
          RE_MODULE_SCRIPT,
          `$1${newline}	${fm}`
        );
      }
      node2.children = [
        //@ts-ignore
        ..._module,
        //@ts-ignore
        { type: "raw", value: _module[0] ? newline : "" },
        //@ts-ignore
        ...instance,
        //@ts-ignore
        { type: "raw", value: instance[0] ? newline : "" },
        //@ts-ignore
        ...css,
        //@ts-ignore
        { type: "raw", value: css[0] ? newline : "" },
        //@ts-ignore
        ...special,
        //@ts-ignore
        { type: "raw", value: special[0] ? newline : "" },
        {
          //@ts-ignore
          type: "raw",
          value: import_script ? `<Layout_MDSVEX_DEFAULT {...$$props}${fm ? " {...metadata}" : ""}>` : ""
        },
        //@ts-ignore
        { type: "raw", value: newline },
        //@ts-ignore
        ...html2,
        //@ts-ignore
        { type: "raw", value: newline },
        //@ts-ignore
        { type: "raw", value: import_script ? "</Layout_MDSVEX_DEFAULT>" : "" }
      ];
    });
  };
}
var langs = {};
var Prism;
var make_path = (base_path, id2) => base_path.replace("{id}", id2);
function get_lang_info(name3, lang_meta, base_path) {
  const _lang_meta = {
    name: name3,
    path: `prismjs/${make_path(base_path, name3)}`,
    deps: /* @__PURE__ */ new Set()
  };
  const aliases = /* @__PURE__ */ new Set();
  if (lang_meta.require) {
    if (Array.isArray(lang_meta.require)) {
      lang_meta.require.forEach((id2) => _lang_meta.deps.add(id2));
    } else {
      _lang_meta.deps.add(lang_meta.require);
    }
  }
  if (lang_meta.peerDependencies) {
    if (Array.isArray(lang_meta.peerDependencies)) {
      lang_meta.peerDependencies.forEach((id2) => _lang_meta.deps.add(id2));
    } else {
      _lang_meta.deps.add(lang_meta.peerDependencies);
    }
  }
  if (lang_meta.alias) {
    if (Array.isArray(lang_meta.alias)) {
      lang_meta.alias.forEach((id2) => aliases.add(id2));
    } else {
      aliases.add(lang_meta.alias);
    }
  }
  return [{ ..._lang_meta, aliases }, aliases];
}
function load_language_metadata() {
  if (!process.browser) {
    const {
      meta: meta2,
      ...languages
    } = require_components().languages;
    for (const lang2 in languages) {
      const [lang_info, aliases] = get_lang_info(
        lang2,
        languages[lang2],
        meta2.path
      );
      langs[lang2] = lang_info;
      aliases.forEach((_n2) => {
        langs[_n2] = langs[lang2];
      });
    }
    const svelte_meta = {
      name: "svelte",
      aliases: /* @__PURE__ */ new Set(["sv"]),
      path: "prism-svelte",
      deps: /* @__PURE__ */ new Set(["javscript", "css"])
    };
    langs.svelte = svelte_meta;
    langs.sv = svelte_meta;
  }
}
function load_language(lang2) {
  if (!process.browser) {
    if (!langs[lang2])
      return;
    langs[lang2].deps.forEach((name3) => load_language(name3));
    __require(langs[lang2].path);
  }
}
function highlight_blocks({
  highlighter: highlight_fn,
  alias
} = {}) {
  if (highlight_fn && !process.browser) {
    load_language_metadata();
    if (alias) {
      for (const lang2 in alias) {
        langs[lang2] = langs[alias[lang2]];
      }
    }
  }
  return async function(tree) {
    if (highlight_fn) {
      const nodes = [];
      unistUtilVisit(tree, "code", (node2) => {
        nodes.push(node2);
      });
      await Promise.all(
        nodes.map(async (node2) => {
          node2.type = "html";
          node2.value = await highlight_fn(
            node2.value,
            node2.lang,
            node2.meta
          );
        })
      );
    }
  };
}
var escape_svelty = (str2) => str2.replace(
  /[{}`]/g,
  //@ts-ignore
  (c2) => ({ "{": "&#123;", "}": "&#125;", "`": "&#96;" })[c2]
).replace(/\\([trn])/g, "&#92;$1");
var code_highlight = (code2, lang2) => {
  const normalised_lang = _optionalChain([lang2, "optionalAccess", (_2) => _2.toLowerCase, "call", (_2) => _2()]);
  if (!process.browser) {
    let _lang = !!normalised_lang && langs[normalised_lang];
    if (!Prism)
      Prism = require_prism();
    if (_lang && !Prism.languages[_lang.name]) {
      load_language(_lang.name);
    }
    if (!_lang && normalised_lang && Prism.languages[normalised_lang]) {
      langs[normalised_lang] = { name: lang2 };
      _lang = langs[normalised_lang];
    }
    const highlighted = escape_svelty(
      _lang ? Prism.highlight(code2, Prism.languages[_lang.name], _lang.name) : escapeHtml_1(code2)
    );
    return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
  } else {
    const highlighted = escape_svelty(escapeHtml_1(code2));
    return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
  }
};
function stringify(options2 = {}) {
  this.Compiler = compiler2;
  function compiler2(tree) {
    return prettyhtmlHastToHtml(tree, options2);
  }
}
var apply_plugins = (plugins, parser2) => {
  plugins.forEach((plugin) => {
    if (Array.isArray(plugin)) {
      if (plugin[1] && plugin[1])
        parser2.use(plugin[0], plugin[1]);
      else
        parser2.use(plugin[0]);
    } else {
      parser2.use(plugin);
    }
  });
  return parser2;
};
function transform({
  remarkPlugins = [],
  rehypePlugins = [],
  frontmatter: frontmatter2,
  smartypants: smartypants2,
  layout,
  layout_mode,
  highlight
} = { layout_mode: "single" }) {
  const fm_opts = frontmatter2 ? frontmatter2 : { parse: default_frontmatter, type: "yaml", marker: "-" };
  const toMDAST = unified_1$1().use(remarkParse).use(mdsvex_parser).use(remarkExternalLinks, { target: false, rel: ["nofollow"] }).use(escape_code, { blocks: !!highlight }).use(remarkFrontmatter, [{ type: fm_opts.type, marker: fm_opts.marker }]).use(parse_frontmatter, { parse: fm_opts.parse, type: fm_opts.type });
  if (smartypants2) {
    toMDAST.use(
      smartypants_transformer,
      typeof smartypants2 === "boolean" ? {} : smartypants2
    );
  }
  apply_plugins(remarkPlugins, toMDAST).use(highlight_blocks, highlight || {});
  const toHAST = toMDAST.use(remarkRehype, {
    // @ts-ignore
    allowDangerousHtml: true,
    allowDangerousCharacters: true
  }).use(transform_hast, { layout, layout_mode });
  apply_plugins(rehypePlugins, toHAST);
  const processor = toHAST.use(stringify, {
    allowDangerousHtml: true,
    allowDangerousCharacters: true
  });
  return processor;
}
var defaults = {
  remarkPlugins: [],
  rehypePlugins: [],
  smartypants: true,
  extension: ".svx",
  highlight: { highlighter: code_highlight }
};
function to_posix(_path) {
  const isExtendedLengthPath = /^\\\\\?\\/.test(_path);
  const hasNonAscii = /[^\u0000-\u0080]+/.test(_path);
  if (isExtendedLengthPath || hasNonAscii) {
    return _path;
  }
  return _path.replace(/\\/g, "/");
}
function resolve_layout(layout_path) {
  try {
    return to_posix(__require.resolve(layout_path));
  } catch (e) {
    try {
      const _path = (0, import_path.join)(process.cwd(), layout_path);
      return to_posix(__require.resolve(_path));
    } catch (e2) {
      throw new Error(
        `The layout path you provided couldn't be found at either ${layout_path} or ${(0, import_path.join)(
          process.cwd(),
          layout_path
        )}. Please double-check it and try again.`
      );
    }
  }
}
function process_layouts(layouts) {
  const _layouts = layouts;
  for (const key in _layouts) {
    const layout = import_fs.default.readFileSync(_layouts[key].path, { encoding: "utf8" });
    let ast2;
    try {
      ast2 = parse$b(layout);
    } catch (e) {
      throw new Error(e.toString() + `
	at ${_layouts[key].path}`);
    }
    if (ast2.module) {
      const component_exports = ast2.module.content.body.filter(
        (node2) => node2.type === "ExportNamedDeclaration"
      );
      if (component_exports.length) {
        _layouts[key].components = [];
        for (let i = 0; i < component_exports.length; i++) {
          if (component_exports[i].specifiers && component_exports[i].specifiers.length) {
            for (let j = 0; j < component_exports[i].specifiers.length; j++) {
              _layouts[key].components.push(
                component_exports[i].specifiers[j].exported.name
              );
            }
          } else if (component_exports[i].declaration.declarations) {
            const declarations = component_exports[i].declaration.declarations;
            for (let j = 0; j < declarations.length; j++) {
              _layouts[key].components.push(declarations[j].id.name);
            }
          } else if (component_exports[i].declaration) {
            _layouts[key].components.push(
              //@ts-ignore
              component_exports[i].declaration.id.name
            );
          }
        }
      }
    }
  }
  return _layouts;
}
var mdsvex = (options2 = defaults) => {
  const {
    remarkPlugins = [],
    rehypePlugins = [],
    smartypants: smartypants2 = true,
    extension = ".svx",
    extensions,
    layout = false,
    highlight = { highlighter: code_highlight },
    frontmatter: frontmatter2
  } = options2;
  if (options2.layouts) {
    throw new Error(
      `mdsvex: "layouts" is not a valid option. Did you mean "layout"?`
    );
  }
  const unknown_opts = [];
  const known_opts = [
    "filename",
    "remarkPlugins",
    "rehypePlugins",
    "smartypants",
    "extension",
    "extensions",
    "layout",
    "highlight",
    "frontmatter"
  ];
  for (const opt in options2) {
    if (!known_opts.includes(opt))
      unknown_opts.push(opt);
  }
  if (unknown_opts.length) {
    console.warn(
      `mdsvex: Received unknown options: ${unknown_opts.join(
        ", "
      )}. Valid options are: ${known_opts.join(", ")}.`
    );
  }
  let _layout = {};
  let layout_mode = "single";
  if (typeof layout === "string") {
    _layout.__mdsvex_default = { path: resolve_layout(layout), components: [] };
  } else if (typeof layout === "object") {
    layout_mode = "named";
    for (const name3 in layout) {
      _layout[name3] = { path: resolve_layout(layout[name3]), components: [] };
    }
  }
  if (highlight && highlight.highlighter === void 0) {
    highlight.highlighter = code_highlight;
  }
  _layout = process_layouts(_layout);
  const parser2 = transform({
    remarkPlugins,
    rehypePlugins,
    smartypants: smartypants2,
    layout: _layout,
    layout_mode,
    highlight,
    frontmatter: frontmatter2
  });
  return {
    markup: async ({ content, filename }) => {
      const extensionsParts = (extensions || [extension]).map(
        (ext) => ext.split(".").pop()
      );
      if (!extensionsParts.includes(filename.split(".").pop()))
        return;
      const parsed = await parser2.process({ contents: content, filename });
      return {
        code: parsed.contents,
        data: parsed.data,
        map: ""
      };
    }
  };
};
var _compile = (source, opts) => mdsvex(opts).markup({
  content: source,
  filename: opts && opts.filename || `file${opts && (opts.extensions && opts.extensions[0] || opts.extension) || ".svx"}`
});
export {
  _compile as compile,
  defineConfig as defineMDSveXConfig,
  escape_svelty as escapeSvelte,
  mdsvex
};
/*! Bundled license information:

mdsvex/dist/main.es.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)
*/
//# sourceMappingURL=mdsvex.js.map
